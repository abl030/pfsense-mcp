"""
Auto-generated pfSense MCP server.

Generated by: python -m generator
Source: openapi-spec.json (pfSense REST API v2)
Tools: {{ tool_count }}

DO NOT EDIT THIS FILE DIRECTLY.
Fix the generator or templates instead, then re-run.
"""

from __future__ import annotations

import os
from typing import Any

import httpx
from fastmcp import FastMCP

mcp = FastMCP(
    "pfSense",
    instructions=(
        "pfSense firewall management. {{ tool_count }} tools available. "
        "Call pfsense_search_tools first to find the right tool by keyword "
        "before browsing the full tool list. "
        "Call pfsense_get_overview for system status."
    ),
)


class PfSenseClient:
    """HTTP client for pfSense REST API v2."""

    def __init__(self) -> None:
        self.host = os.environ.get("PFSENSE_HOST", "https://192.168.1.1")
        self.api_key = os.environ.get("PFSENSE_API_KEY", "")
        self.verify_ssl = os.environ.get("PFSENSE_VERIFY_SSL", "false").lower() in (
            "true",
            "1",
            "yes",
        )
        self._client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None or self._client.is_closed:
            self._client = httpx.AsyncClient(
                base_url=self.host.rstrip("/"),
                headers={"X-API-Key": self.api_key},
                verify=self.verify_ssl,
                timeout=30.0,
            )
        return self._client

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | list | None = None,
    ) -> dict[str, Any]:
        """Make an API request and return the response."""
        client = await self._get_client()

        # Filter out None values from params
        if params:
            params = {k: v for k, v in params.items() if v is not None}

        try:
            resp = await client.request(
                method=method.upper(),
                url=path,
                params=params or None,
                json=json_body,
            )
            try:
                data = resp.json()
            except Exception:
                data = {"code": resp.status_code, "status": "error", "data": resp.text}

            # Unwrap successful responses
            if isinstance(data, dict) and data.get("code") == 200:
                return data.get("data", data)

            return data
        except httpx.ConnectError as e:
            return {"error": f"Connection failed: {e}. Check PFSENSE_HOST."}
        except httpx.ReadTimeout:
            return {"error": "Request timed out. The pfSense host may be slow or unreachable."}
        except Exception as e:
            return {"error": f"Request failed: {type(e).__name__}: {e}"}


_client = PfSenseClient()

# --- Module and read-only gating ---
_ALL_MODULES = {{ all_modules }}
_PFSENSE_MODULES = set(
    m.strip()
    for m in os.environ.get("PFSENSE_MODULES", ",".join(sorted(_ALL_MODULES))).split(",")
    if m.strip()
)
_PFSENSE_READ_ONLY = os.environ.get("PFSENSE_READ_ONLY", "false").lower() in (
    "true",
    "1",
    "yes",
)


@mcp.tool()
async def pfsense_report_issue(
    tool_name: str,
    error_message: str,
    parameters_used: dict[str, Any],
    notes: str = "",
) -> str:
    """Report an unexpected pfSense MCP tool error by composing a GitHub issue command.

    This tool does NOT make any HTTP calls. It returns a ready-to-paste
    `gh issue create` command that the user can run to file a bug report.

    tool_name: The MCP tool that produced the error (e.g. pfsense_get_firewall_rules)
    error_message: The error message or response body returned by the tool
    parameters_used: The parameters that were passed to the failing tool call
    notes: Any additional context about what you were trying to accomplish
    """
    import json as _json

    params_block = _json.dumps(parameters_used, indent=2, default=str)
    notes_section = f"\n\n## Notes\n\n{notes}" if notes else ""

    body = (
        f"## Tool\n\n`{tool_name}`\n\n"
        f"## Error\n\n```\n{error_message}\n```\n\n"
        f"## Parameters\n\n```json\n{params_block}\n```\n\n"
        f"## Repro Steps\n\n"
        f"1. Call `{tool_name}` with the parameters above\n"
        f"2. Observe the error response"
        f"{notes_section}"
    )

    escaped_body = body.replace("'", "'\\''")
    escaped_title = f"Bug: {tool_name} returns unexpected error".replace("'", "'\\''")

    return (
        f"Run this command to file the issue:\n\n"
        f"gh issue create --repo abl030/pfsense-mcp "
        f"--label bug --label mcp-reported "
        f"--title '{escaped_title}' "
        f"--body '{escaped_body}'"
    )

@mcp.tool()
async def pfsense_get_overview() -> dict[str, Any]:
    """Get a concise pfSense system overview: version, interfaces, gateways, and services.

    Calls multiple status endpoints in parallel and returns a unified summary.
    Service status for package-installed services (WireGuard, HAProxy, BIND,
    FreeRADIUS) is annotated because the REST API incorrectly reports them as
    disabled/stopped due to a known bug in the Service model.

    If this tool returns an unexpected error, call pfsense_report_issue to report it.
    """
    import asyncio as _asyncio

    _BUGGY_SERVICES = {"wireguard", "haproxy", "named", "radiusd"}

    version_coro = _client.request("GET", "/api/v2/system/version")
    interfaces_coro = _client.request("GET", "/api/v2/status/interfaces")
    gateways_coro = _client.request("GET", "/api/v2/status/gateways")
    services_coro = _client.request("GET", "/api/v2/status/services")

    version, interfaces, gateways, services = await _asyncio.gather(
        version_coro, interfaces_coro, gateways_coro, services_coro,
    )

    # Annotate package services affected by the REST API Service model bug
    if isinstance(services, list):
        for svc in services:
            if isinstance(svc, dict) and svc.get("name") in _BUGGY_SERVICES:
                svc["_note"] = (
                    "REST API bug: enabled/status fields are always false for "
                    "package-installed services. The service may actually be "
                    "running. Use diagnostics/command_prompt with "
                    "is_service_running() for accurate status."
                )

    return {
        "version": version,
        "interfaces": interfaces,
        "gateways": gateways,
        "services": services,
    }


# --- Tool index for discovery ({{ tool_index_count }} entries, auto-generated) ---
_TOOL_INDEX = [
{{ tool_index_code }}
]


@mcp.tool()
async def pfsense_search_tools(
    query: str,
    module: str | None = None,
    limit: int = 25,
) -> list[dict[str, Any]]:
    """Search for pfSense tools by keyword. Call this first to discover which tools to use.

    Uses AND logic: all space-separated terms must match.
    Returns tool name, module, HTTP method, description, and whether the tool
    is currently registered (respects PFSENSE_MODULES and PFSENSE_READ_ONLY).

    query: Space-separated search terms (e.g. 'dhcp static mapping')
    module: Optional module filter (e.g. 'firewall', 'vpn_wireguard', 'services_dhcp')
    limit: Max results to return (default 25)
    """
    terms = query.lower().split()
    if not terms:
        return []
    results: list[dict[str, Any]] = []
    for entry in _TOOL_INDEX:
        if module and entry["module"] != module:
            continue
        searchable = (
            f"{entry['name']} {entry['module']} {entry['desc']} "
            f"{' '.join(entry['kw'])}"
        ).lower()
        if all(t in searchable for t in terms):
            # Determine if tool is currently registered
            if entry["module"] == "_always_on":
                registered = True
            else:
                is_mut = entry["method"] in ("post", "patch", "put", "delete")
                registered = (
                    entry["module"] in _PFSENSE_MODULES
                    and (not is_mut or not _PFSENSE_READ_ONLY)
                )
            results.append({
                "name": entry["name"],
                "module": entry["module"],
                "method": entry["method"],
                "description": entry["desc"],
                "registered": registered,
            })
            if len(results) >= limit:
                break
    return results

{{ module_code }}
