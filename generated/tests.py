"""
Auto-generated integration tests for pfSense REST API v2.

Generated by: python -m generator
Tests every endpoint against a live pfSense VM.

DO NOT EDIT THIS FILE DIRECTLY.
Fix the generator instead, then re-run.
"""

from __future__ import annotations

import json
import os
import time

import httpx
import pytest

BASE_URL = os.environ.get("PFSENSE_TEST_URL", "https://127.0.0.1:18443")
API_KEY = os.environ.get("PFSENSE_TEST_API_KEY", "")
AUTH_USER = os.environ.get("PFSENSE_TEST_USER", "admin")
AUTH_PASS = os.environ.get("PFSENSE_TEST_PASS", "pfsense")

# Pre-generated test certificates (self-signed, 10-year validity)
CA_CERT_PEM = "-----BEGIN CERTIFICATE-----\nMIIDITCCAgmgAwIBAgICMDkwDQYJKoZIhvcNAQELBQAwKTEQMA4GA1UEAwwHVGVz\ndCBDQTEVMBMGA1UECgwMcGZTZW5zZSBUZXN0MB4XDTI2MDIwNzA4NDMwOFoXDTM2\nMDIwNTA4NDMwOFowKTEQMA4GA1UEAwwHVGVzdCBDQTEVMBMGA1UECgwMcGZTZW5z\nZSBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsHyXY8NQRm6C\nOKfrDVjrVjWGePxOILQcpaU1GRGpbfXyjXQMbMOcHYDeXa853857iMhcH17bbBes\nyEIYb0uy/dr42bAxLthnk7waOVefm4xkcG51MEe6tDIzsKC6kDfAclHb0Hjb9kgT\nK20cW1yL6z9BHIghgas2kzwxJR9mM2ZirW5tVetdspDJi3755O6Q3j1nGK5KZBMC\nsxTxVMyvldhZpaEEw3Rnz216lUlchcNDW1DlDoPuif9x4XfGWlijhX5B+/KNwnVT\nJ3WeW/obh2RtOn7fwZsweB9R7ZNgNeZK2SZytqYyOET25+iSWEAtlUg4zmug0SYE\n/uErP4+yiwIDAQABo1MwUTAdBgNVHQ4EFgQUdNDSsN13N5F8L4E/zoSE/h+XN/Mw\nHwYDVR0jBBgwFoAUdNDSsN13N5F8L4E/zoSE/h+XN/MwDwYDVR0TAQH/BAUwAwEB\n/zANBgkqhkiG9w0BAQsFAAOCAQEAS+ML0N+Z2F6txyF/OUdV1Y9kf9DDQi9c48kJ\n5jkFxX/m7Ur8XmKUY3QgucVvcIg9gHY4aOkW226DfMBrv/gC7Ko3i+Kz4SfdaZg6\nXbNgJhWTdnGR/vYbuRoVw/UUA+Xs6aHMlA60pIYLacNVBigBsrEKznREjDceG+Bw\nBixkx+/UkmNf0J3dvzNYZTc1Hy27sm5wI2zsZlYAHOCgocU5fcXwICBqlVYbEejv\nERGkEIg2k3Sd+6Yh7gRxGkeQv9vMq7yZfEiTaQ9NMAD7FRjM5Mms1Fs2qkxG8JX3\nv2DrRM6dA1e+yXyHDGCOmQcLsYnYXBD932W+EF14SQaaIELJ1g==\n-----END CERTIFICATE-----"
CA_KEY_PEM = "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCwfJdjw1BGboI4\np+sNWOtWNYZ4/E4gtBylpTUZEalt9fKNdAxsw5wdgN5drznfznuIyFwfXttsF6zI\nQhhvS7L92vjZsDEu2GeTvBo5V5+bjGRwbnUwR7q0MjOwoLqQN8ByUdvQeNv2SBMr\nbRxbXIvrP0EciCGBqzaTPDElH2YzZmKtbm1V612ykMmLfvnk7pDePWcYrkpkEwKz\nFPFUzK+V2FmloQTDdGfPbXqVSVyFw0NbUOUOg+6J/3Hhd8ZaWKOFfkH78o3CdVMn\ndZ5b+huHZG06ft/BmzB4H1Htk2A15krZJnK2pjI4RPbn6JJYQC2VSDjOa6DRJgT+\n4Ss/j7KLAgMBAAECggEAFsQbq0zYoB1FQxW2JoSf5wEElbrGQUW6pEuJa/BxULP3\nU/PyXl1lWBD1nlQqPQqfuOdPquRLncf4C+UqzcCQGFsU2s/1qDtWMSKEp3z8I86a\nbj5xc4btOK15KYGyT0RB2P1iQ6Qzi7OEdYefrtFjYzdHqOyOlfGGGrwbAtToFB0c\nFYT188F+R1i9K3CC3sX0I/A6xkRPBWNLkl6nDxKh9egHhrSCxecEzPcNTGoZo2Em\nE309RGwnpvafeVc6jZfESGtiutpCf+trxKU+S/qlcmvC6222ZjPa18k+o4KSHpGm\n9xBtbQxqYTVd16fKBLZF2OYcEAFezbhHsBeF6YGPYQKBgQDgl5sySL718A1AnWM0\nhjJZOXuv08LyHEEWvQiIOVU2Cac1FrdV2lakMU8+aN899H//uY8W5PImR2/+gm6i\nBFBFpfuEt/bytJ6/uyG1ztTq5YUjPENM7jD/p/KTyTlXd9SxaZ5cxMqKLIsINrKE\nmrBsxKAeIsf94VngfadXeV14cwKBgQDJKs8RXMUk7u+vUlmYsjoKKfv0ucXwPg9N\nuFPz7RWx2t0ZNfHQgrXgkTj+9d2NDNkdGC20rPK9zy3uULi3qTyTZ7oepMsNwUn1\nOv+yffnYHgzpuO3v2m6zhORq59AFrgbFzoNJUW5rAnfEBl+7HgeXLDqyvaTDPo6g\n49ivGjaPiQKBgQCyzgBw+BmQE515Y9QnbO+IuYsPYLhDqNrpD3ZLfdmpO+YzDfLI\nFxwDfH5qYXPaD14YadLRl1RxxU4UgiMyOdzulka4Uv34HHSGkKU16YT5veFRPBkY\nlknMQBmQLxPH308mL8A0ezgE6ZGG6IUXrU/oSGJxm589MLwtTdx8d9NCoQKBgQDG\nafLSrS3Fv+WohxDYCvI0FDTurE0PKCbwAV7MuIstYTGyLALWJhY96P7OerKK7KE4\nkSCDlBHYJQCojfWjMMkOmsB4eRHN/1dzCT4qTxaekwUpgb0tVcTaS7j/uKT09TC4\n6XeUWT0PTt/R+Hdzl6rk8Dr1ERfxe0IybojKLJCkAQKBgExKn6TG43y8gM9rxaSD\nzRA8kLMI96LniQImjhHH/mSrWtW3t8Z5zDMn5vuPoaScv84SAiAWGDl6bmInNKpA\nyA/IibZNOenOUHmFzS87uzoDrC7ch8eqEa43KhBcsryMYNqphwjw6CNL1gZkGVpT\n1IgDA7lYJ4B3TIjIFzk/Pknn\n-----END PRIVATE KEY-----"
CERT_PEM = "-----BEGIN CERTIFICATE-----\nMIIDGjCCAgKgAwIBAgIDAQkyMA0GCSqGSIb3DQEBCwUAMCkxEDAOBgNVBAMMB1Rl\nc3QgQ0ExFTATBgNVBAoMDHBmU2Vuc2UgVGVzdDAeFw0yNjAyMDcwODQzMDhaFw0z\nNjAyMDUwODQzMDhaMDIxGTAXBgNVBAMMEHRlc3QuZXhhbXBsZS5jb20xFTATBgNV\nBAoMDHBmU2Vuc2UgVGVzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB\nAMVJuOo0Uc/W/SmJ5VeWxbDmc4ERs1oYgN4iJfYbPTAyVOcncKcvRJfnn/7yzKBm\n+8VJ6vEW85w4l9i1TpZGJcjVztcxGWyShQset4dGCEO/dlN5Mdjk40SUJagjnqJx\nv5CiKRadBGonFC4q9OgzLTo49Pp67FTBLkJ2YOYfSKfff1jsRPWkVLh1DryhfhrG\nMnIkSqiwd8GcH1CvLQgJXl+gkwW+aj0bFN/p8tqFdhzkOXNBuhDNV1cm7s9koLda\nwRwEZC61kDBLD03F1BpTC3SCjwrffOSe9iaW6xu3Zd6thkWLk+qUbo7jVqssefEU\nirI2TwwdIcoEcj+IKn2XDJkCAwEAAaNCMEAwHQYDVR0OBBYEFLpeQt6fkePzG8Rv\nNVVxDg1TaFVSMB8GA1UdIwQYMBaAFHTQ0rDddzeRfC+BP86EhP4flzfzMA0GCSqG\nSIb3DQEBCwUAA4IBAQBvvfaGdkf69515YpbZL3l7RPJV5xs/SEd0hWS9NiX1ccv9\nL07Ldy0IbqYRochnWMZq/nZfTC6u2U2n1nMKeFlos5D351pZt7sNqSDBx28Uq2rN\nx8Yh7h9UR18jkDJhv/SvFRWy7n2uQ4GQEZLoHzzhQMSoiCW2xGXl/28NZuY7br5a\nFTnr7FQ+iqiVoX+mPocCYnhnD4gqtLQYlrkcnf9YAXtT1m01ICLWGImgIFp86kVY\nDfr8SxzwH1GAcFn0xB6I50yqxPCbGZBZqWvSAiynsxEK+TqWEk+cWN4Y+vkRWAbZ\nf/gVTMr8CvCVTVmE3UTbWPD/YjzuN1WuDgqjDRjD\n-----END CERTIFICATE-----"
CERT_KEY_PEM = "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDFSbjqNFHP1v0p\nieVXlsWw5nOBEbNaGIDeIiX2Gz0wMlTnJ3CnL0SX55/+8sygZvvFSerxFvOcOJfY\ntU6WRiXI1c7XMRlskoULHreHRghDv3ZTeTHY5ONElCWoI56icb+QoikWnQRqJxQu\nKvToMy06OPT6euxUwS5CdmDmH0in339Y7ET1pFS4dQ68oX4axjJyJEqosHfBnB9Q\nry0ICV5foJMFvmo9GxTf6fLahXYc5DlzQboQzVdXJu7PZKC3WsEcBGQutZAwSw9N\nxdQaUwt0go8K33zknvYmlusbt2XerYZFi5PqlG6O41arLHnxFIqyNk8MHSHKBHI/\niCp9lwyZAgMBAAECggEAK4X6D2D/c3SgYRuUxt/yOPZ+IMlA4e1p8Jdj/IlB1HIm\nHOCsj5Vz8ncc6uexkOlnPbzy4cEIeTxa82n8LlbHWykf+oVQcI1aYHukTWl7xUZl\n2kBwaMMGCEkOjateAcRKWKQNoHl/UdPRNeYwJVG09pU+Jkwb+w6rH+pxshLQuofG\npD1BZWzs9EfuVXeuo1h4pk8T9JL0VsYQWBr97Le5EGMgGEkPEvVS3SgT8if0tAU+\nLd3kOv7GgGKeNjos3PMpCp82kHYsA+KXKpwQIrut/LRnBm3eSzOqjbh3QQF7UbxH\n1ah28lnTzwc5GUi3A9Aj0WupDTwimtSnV2evgDh/IQKBgQDnAsfLP/AxPsFIzld3\nDiydfD5jWWvCHwElBex7yDHxHXPdoywvRBueT+EoG8IhvTcroCUIWy82Af7TQ6WL\nm/WmjWlmsnZ8ah1r42gx4rObRc18q2yNnAPksDVbBLoSY4vp8o2o56vme321G02A\nr/I0lzqaYIX7lxJmDsscNgExLQKBgQDaoRP6vg4v2TsKJZGGO/Z4VUUWu9QLexzj\nTllWogMqZZ6flMQshhyBP7N/hiO1VbDE0aiuAsO/ZTbdPVXZ8pA8oM2cEfWNNDsc\nrvlm4vQrJ+awp2RnEQsniRizgxeYwzQjo1am7uv2udrYenwhgnNVDQEdlTlOzO8a\n9N9a2BH0nQKBgAM1KK0L0Dv+0RQ/uTsv+TKenQcoILTrVUq8UFJPr1HXxNoY/+4Q\nFgoWtdumtwVc6T0z1g/NpFQtpuosEEpl+f08DXCdncOQfaQX3kSDD1dimr3Wa4Vz\n2yH7yGHhKOxEcZboBUuJG/vxTweKv4K/7q8IQooOOQ4LRPgh0HQt08ppAoGBANki\ne5ZfpfVtuU5Vi5eW/C38+jYe6/VPG5zB1sbM93nnHUh+1uslczAG1T5FOjfB2GNR\nm0bfpgvz+S532UkxuIEOb8aeq5LHGiJdwYOmyjwGT/6I8ZXPfpWQesDm5Muqq6Dt\ne4Ul66LKaYjw9VHOnr8MwFviNd2Geb77Ds3JpOOdAoGBAMZ0cH7TID2qhOhbHNbq\n1oe1VMJ2wABJQ923jPwNa8UqzoZtE/NGkzaEPBZ91SpHSo88DmzcvY06C7tKi//H\nk4i7T0WIbj93UPzwEzamnI+KF1rrzsZpImoJ5vvEe7EnQMXUwcGwXsJZphNjFhUp\nwpkYG2WCI0nyfqoM9noi/oj1\n-----END PRIVATE KEY-----"


class RetryClient(httpx.Client):
    """httpx.Client that retries on 503 (dispatcher busy)."""
    def request(self, method, url, **kwargs):
        for attempt in range(6):
            resp = super().request(method, url, **kwargs)
            if resp.status_code != 503:
                return resp
            time.sleep(10 * (attempt + 1))
        return resp


@pytest.fixture(scope="session")
def client() -> httpx.Client:
    """Authenticated httpx client for the test VM."""
    if API_KEY:
        c = RetryClient(
            base_url=BASE_URL,
            headers={"X-API-Key": API_KEY},
            verify=False,
            timeout=30,
        )
    else:
        c = RetryClient(
            base_url=BASE_URL,
            auth=(AUTH_USER, AUTH_PASS),
            verify=False,
            timeout=30,
        )
    yield c
    c.close()


def _ok(resp: httpx.Response) -> dict:
    """Assert response is 200 and return data."""
    assert resp.status_code == 200, f"{resp.request.method} {resp.request.url} -> {resp.status_code}: {resp.text[:500]}"
    body = resp.json()
    assert body.get("code") == 200, f"API error: {body}"
    return body.get("data", body)


def _delete_with_retry(client: httpx.Client, path: str, obj_id, params: dict | None = None) -> None:
    """Delete a resource with retry for 503 (busy) and accept 404 (already gone)."""
    p = {"id": obj_id}
    if params:
        p.update(params)
    for _attempt in range(3):
        resp = client.delete(path, params=p)
        if resp.status_code != 503:
            break
        time.sleep(5)
    assert resp.status_code in (200, 404), f"Delete {path} id={obj_id} failed: {resp.text[:500]}"
# Total generated tests: 208

def test_crud_firewall_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/alias"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/alias",
        json={
        "name": "pft_firewall_a",
        "type": 'host',
        "address": ["10.99.99.1"],
        "descr": "Test created by generator",
        "detail": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/alias",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/aliases",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/alias",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/alias",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_one_to_one_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/one_to_one/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/one_to_one/mapping",
        json={
        "destination": "any",
        "external": "10.99.99.1",
        "interface": "wan",
        "source": "any",
        "descr": "Test created by generator",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nobinat": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/one_to_one/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/one_to_one/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_outbound_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/outbound/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/outbound/mapping",
        json={
        "destination": "any",
        "interface": "wan",
        "source": "any",
        "target": "127.0.0.1",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "nat_port": "443",
        "nonat": False,
        "nosync": False,
        "poolopts": 'round-robin',
        "protocol": "tcp",
        "source_hash_key": "test_firewall_nat_outbound_mapping",
        "source_port": "443",
        "static_nat_port": False,
        "target_subnet": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/outbound/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/outbound/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/outbound/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/outbound/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_port_forward(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/port_forward"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/port_forward",
        json={
        "destination": "any",
        "interface": "wan",
        "local_port": "8080",
        "protocol": "tcp",
        "source": "any",
        "target": "127.0.0.1",
        "associated_rule_id": "",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nordr": False,
        "nosync": False,
        "source_port": "443",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/port_forward",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/port_forwards",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/port_forward",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/port_forward",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_rule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/rule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/rule",
        json={
        "destination": "any",
        "interface": ["wan"],
        "ipprotocol": "inet",
        "source": "any",
        "type": 'pass',
        "descr": "Test created by generator",
        "destination_port": "80",
        "direction": 'any',
        "disabled": False,
        "floating": False,
        "icmptype": [],
        "log": False,
        "protocol": "tcp",
        "quick": False,
        "source_port": "443",
        "statetype": 'keep state',
        "tag": "test_firewall_rule",
        "tcp_flags_any": False,
        "tcp_flags_out_of": [],
        "tcp_flags_set": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/rule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/rules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/rule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/rule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_schedule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/schedule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/schedule",
        json={
        "name": "pft_firewall_s",
        "timerange": [{"month": "1,2,3", "day": "1,2,3", "hour": "0:00-23:59", "position": []}],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/schedule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/schedules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/schedule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/schedule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_schedule_time_range(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/schedule/time_range (needs: firewall/schedule)"""
    # Setup: create parent firewall/schedule
    p0_resp = client.post(
        "/api/v2/firewall/schedule",
        json={
        "name": 'pft_sched_tr',
        "timerange": [{'month': '1,2,3', 'day': '1,2,3', 'hour': '0:00-23:59', 'position': []}],
        "descr": 'Test schedule for time_range',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "month": [4, 5, 6],
                "day": [10, 11, 12],
                "hour": '8:00-17:00',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/schedule/time_range",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/schedule/time_range",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/schedule/time_range", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/schedule", p0_id)


def test_crud_firewall_traffic_shaper(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper",
        json={
        "bandwidth": 100,
        "bandwidthtype": "Mb",
        "interface": "wan",
        "scheduler": "HFSC",
        "enabled": False,
        "qlimit": 50,
        "queue": [],
        "tbrconfig": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shapers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_traffic_shaper_limiter(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": "droptail",
        "name": "pft_firewall_t",
        "sched": "wf2q+",
        "bandwidth": [{"bw": 100, "bwscale": "Mb", "schedule": "none"}],
        "buckets": 16,
        "delay": 1,
        "description": "test_firewall_traffic_shaper_limiter",
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "param_codel_interval": 1,
        "param_codel_target": 1,
        "param_fq_codel_flows": 1,
        "param_fq_codel_interval": 1,
        "param_fq_codel_limit": 1,
        "param_fq_codel_quantum": 1,
        "param_fq_codel_target": 1,
        "param_fq_pie_alpha": 1,
        "param_fq_pie_beta": 1,
        "param_fq_pie_flows": 1,
        "param_fq_pie_limit": 1,
        "param_fq_pie_max_burst": 1,
        "param_fq_pie_max_ecnth": 1,
        "param_fq_pie_quantum": 1,
        "param_fq_pie_target": 1,
        "param_fq_pie_tupdate": 1,
        "param_gred_max_p": 1,
        "param_gred_max_th": 1,
        "param_gred_min_th": 1,
        "param_gred_w_q": 1,
        "param_pie_alpha": 1,
        "param_pie_beta": 1,
        "param_pie_max_burst": 1,
        "param_pie_max_ecnth": 1,
        "param_pie_target": 1,
        "param_pie_tupdate": 1,
        "param_red_max_p": 1,
        "param_red_max_th": 1,
        "param_red_min_th": 1,
        "param_red_w_q": 1,
        "pie_capdrop": False,
        "pie_onoff": False,
        "pie_pderand": False,
        "pie_qdelay": False,
        "plr": 1.0,
        "qlimit": 50,
        "queue": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiter",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiters",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/traffic_shaper/limiter",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper/limiter",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_traffic_shaper_limiter_bandwidth(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter/bandwidth (needs: firewall/traffic_shaper/limiter)"""
    # Setup: create parent firewall/traffic_shaper/limiter
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": 'droptail',
        "name": 'pft_lim_bw',
        "sched": 'wf2q+',
        "bandwidth": [{'bw': 100, 'bwscale': 'Mb', 'schedule': 'none'}],
        "buckets": 16,
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "queue": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "bw": 50,
                "bwscale": 'Mb',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter/bandwidth", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter", p0_id)


def test_crud_firewall_traffic_shaper_limiter_queue(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter/queue (needs: firewall/traffic_shaper/limiter)"""
    # Setup: create parent firewall/traffic_shaper/limiter
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": 'droptail',
        "name": 'pft_lim_q',
        "sched": 'wf2q+',
        "bandwidth": [{'bw': 100, 'bwscale': 'Mb', 'schedule': 'none'}],
        "buckets": 16,
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "queue": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_limq',
                "aqm": 'droptail',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/limiter/queue",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/limiter/queue",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter/queue", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter", p0_id)


def test_crud_firewall_traffic_shaper_queue(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/queue (needs: firewall/traffic_shaper)"""
    # Setup: create parent firewall/traffic_shaper
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper",
        json={
        "bandwidth": 100,
        "bandwidthtype": 'Mb',
        "interface": 'wan',
        "scheduler": 'HFSC',
        "enabled": False,
        "qlimit": 50,
        "queue": [],
        "tbrconfig": 1,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_tsq',
                "qlimit": 50,
                "bandwidth": 100,
                "upperlimit_m2": '',
                "realtime_m2": '',
                "linkshare_m2": '10%',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/queue",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/queue",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/queue", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper", p0_id)


def test_crud_firewall_virtual_ip(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/virtual_ip"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/virtual_ip",
        json={
        "carp_peer": "10.99.99.6",
        "interface": "wan",
        "mode": 'ipalias',
        "password": "Testpass123!Abc",
        "subnet": "10.99.99.100",
        "subnet_bits": 32,
        "vhid": 1,
        "advbase": 1,
        "advskew": 1,
        "carp_mode": 'mcast',
        "descr": "Test created by generator",
        "noexpand": False,
        "type": 'single',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/virtual_ip",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/virtual_ips",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/virtual_ip",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/virtual_ip",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_interface(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface (needs: interface/vlan)"""
    # Setup: create parent interface/vlan
    p0_resp = client.post(
        "/api/v2/interface/vlan",
        json={
        "if": 'em2',
        "tag": 999,
        "pcp": 0,
        "descr": 'Test VLAN for iface',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "descr": 'TESTVLAN',
                "enable": True,
                "typev4": 'static',
                "ipaddr": '10.99.99.1',
                "subnet": 24,
                "ipaddrv6": 'none',
                "subnetv6": 128,
                "prefix_6rd": '',
                "gateway_6rd": '',
                "prefix_6rd_v4plen": 0,
                "track6_interface": '',
            }
        body["if"] = p0["vlanif"]
        create_resp = client.post(
            "/api/v2/interface",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/interface",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/interface",
                json={"id": obj_id, "descr": "TESTVLAN_UPDATED"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/interface", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/interface/vlan", p0_id)


def test_crud_interface_bridge(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/bridge"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/bridge",
        json={
        "members": ["wan"],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/bridge",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/bridges",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/bridge",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/bridge",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_interface_gre(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/gre (chained)"""
    # CREATE
    body = {
            "if": 'wan',
            "remote_addr": '198.51.100.1',
            "tunnel_local_addr": '10.255.0.1',
            "tunnel_remote_addr": '10.255.0.2',
            "tunnel_remote_addr6": '',
        }
    create_resp = client.post(
        "/api/v2/interface/gre",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/gre",
            params={"id": obj_id},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/gre", obj_id)


def test_crud_interface_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/group",
        json={
        "ifname": "pf_test_interface_group",
        "descr": "Test created by generator",
        "members": ["wan"],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/group",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_interface_lagg(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/lagg (chained)"""
    # CREATE
    body = {
            "members": ['em2'],
            "proto": 'none',
            "descr": 'Test LAGG',
        }
    create_resp = client.post(
        "/api/v2/interface/lagg",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/lagg",
            params={"id": obj_id},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/lagg", obj_id)


def test_crud_interface_vlan(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/vlan (chained)"""
    # CREATE
    body = {
            "if": 'em0',
            "tag": 100,
            "pcp": 0,
            "descr": 'Test VLAN',
        }
    create_resp = client.post(
        "/api/v2/interface/vlan",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/vlan",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/vlan",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/vlan", obj_id)


def test_crud_routing_gateway(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway"""
    # CREATE
    create_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "gateway": "10.0.2.1",
        "interface": "wan",
        "ipprotocol": "inet",
        "name": "pft_routing_ga",
        "action_disable": False,
        "alert_interval": 1000,
        "data_payload": 1,
        "descr": "Test created by generator",
        "disabled": False,
        "dpinger_dont_add_static_route": False,
        "force_down": False,
        "gw_down_kill_states": '',
        "interval": 500,
        "latencyhigh": 500,
        "latencylow": 200,
        "loss_interval": 2000,
        "losshigh": 20,
        "losslow": 10,
        "monitor": "10.99.99.50",
        "monitor_disable": False,
        "nonlocalgateway": False,
        "time_period": 60000,
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/routing/gateway",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/routing/gatewaies",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/routing/gateway",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/routing/gateway",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_routing_gateway_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway/group (needs: routing/gateway)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gg',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for gg',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_gw_group',
                "descr": 'Test gateway group',
                "priorities": [{'gateway': 'pft_gw_gg', 'tier': 1}],
            }
        create_resp = client.post(
            "/api/v2/routing/gateway/group",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/routing/gateway/group",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/routing/gateway/group",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/routing/gateway/group", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_routing_gateway_group_priority(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway/group/priority (needs: routing/gateway, routing/gateway, routing/gateway/group)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gp',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for gp',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent routing/gateway
    p1_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gp2',
        "gateway": '10.0.2.99',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test GW 2 for priority',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent routing/gateway/group
    p2_resp = client.post(
        "/api/v2/routing/gateway/group",
        json={
        "name": 'pft_gw_grp_p',
        "descr": 'Test group for priority',
        "priorities": [{'gateway': 'pft_gw_gp', 'tier': 1}],
    },
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "gateway": 'pft_gw_gp2',
                        "tier": 2,
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/routing/gateway/group/priority",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/routing/gateway/group/priority",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/routing/gateway/group/priority", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/routing/gateway/group", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/routing/gateway", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_routing_static_route(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/static_route (needs: routing/gateway)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_sr',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for sr',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "network": '10.200.0.0/24',
                "descr": 'Test static route',
            }
        body["gateway"] = p0["name"]
        create_resp = client.post(
            "/api/v2/routing/static_route",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/routing/static_route",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/routing/static_route",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/routing/static_route", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_services_acme_account_key(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/account_key (chained)"""
    # CREATE
    body = {
            "name": 'pft_acme_key',
            "descr": 'Test ACME key',
            "email": 'test@example.com',
            "acmeserver": 'letsencrypt-staging-2',
        }
    create_resp = client.post(
        "/api/v2/services/acme/account_key",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/acme/account_key",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/acme/account_key",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", obj_id)


def test_crud_services_acme_certificate(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate (needs: services/acme/account_key)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_crt',
        "descr": 'Test ACME key for cert',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_acme_cert',
                "descr": 'Test ACME cert',
                "keypaste": CERT_KEY_PEM,
                "a_domainlist": [{'name': 'test.example.com', 'method': 'standalone', 'status': 'enable'}],
            }
        body["acmeaccount"] = p0["name"]
        create_resp = client.post(
            "/api/v2/services/acme/certificate",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/acme/certificate",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/acme/certificate",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_acme_certificate_action(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate/action (needs: services/acme/account_key, services/acme/certificate)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_act',
        "descr": 'Test ACME key for action',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/acme/certificate
    p1_body = {
        "name": 'pft_acme_ca',
        "descr": 'Test ACME cert for action',
        "keypaste": CERT_KEY_PEM,
        "a_domainlist": [{'name': 'test3.example.com', 'method': 'standalone', 'status': 'enable'}],
    }
    p1_body["acmeaccount"] = p0["name"]
    p1_resp = client.post(
        "/api/v2/services/acme/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "command": 'echo test',
                    "method": 'shellcommand',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/acme/certificate/action",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/acme/certificate/action",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/acme/certificate/action", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_acme_certificate_domain(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate/domain (needs: services/acme/account_key, services/acme/certificate)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_dom',
        "descr": 'Test ACME key for domain',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/acme/certificate
    p1_body = {
        "name": 'pft_acme_cd',
        "descr": 'Test ACME cert for domain',
        "keypaste": CERT_KEY_PEM,
        "a_domainlist": [{'name': 'test1.example.com', 'method': 'standalone', 'status': 'enable'}],
    }
    p1_body["acmeaccount"] = p0["name"]
    p1_resp = client.post(
        "/api/v2/services/acme/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "name": 'test2.example.com',
                    "method": 'standalone',
                    "status": 'enable',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/acme/certificate/domain",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/acme/certificate/domain",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/acme/certificate/domain", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_bind_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/access_list",
        json={
        "entries": [{"value": "10.0.0.0/8", "description": "test entry"}],
        "name": "pft_services_b",
        "description": "test_services_bind_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_access_list_entry(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/access_list/entry (needs: services/bind/access_list)"""
    # Setup: create parent services/bind/access_list
    p0_resp = client.post(
        "/api/v2/services/bind/access_list",
        json={
        "entries": [{'value': '10.0.0.0/8', 'description': 'test entry'}],
        "name": 'pft_bacl_en',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "value": '10.1.0.0/16',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/bind/access_list/entry",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/bind/access_list/entry",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/bind/access_list/entry", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/bind/access_list", p0_id)


def test_crud_services_bind_sync_remote_host(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/sync/remote_host"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/sync/remote_host",
        json={
        "ipaddress": "10.99.99.99",
        "password": "Testpass123!Abc",
        "syncport": "443",
        "syncprotocol": 'http',
        "username": "pfsense_test_user",
        "syncdestinenable": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/sync/remote_host",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/sync/remote_hosts",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/sync/remote_host",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_view(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/view"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/view",
        json={
        "name": "pft_services_b",
        "allow_recursion": [],
        "bind_custom_options": "test_services_bind_view",
        "descr": "Test created by generator",
        "match_clients": [],
        "recursion": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/view",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/views",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/view",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/view",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_zone(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/zone"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/zone",
        json={
        "baseip": "10.99.99.0",
        "forwarders": [],
        "mail": "test_services_bind_zone",
        "name": "pft_services_b",
        "nameserver": "10.99.99.99",
        "serial": 1,
        "allowquery": [],
        "allowtransfer": [],
        "allowupdate": [],
        "backupkeys": False,
        "custom": "test_services_bind_zone",
        "customzonerecords": "test_services_bind_zone",
        "description": "test_services_bind_zone",
        "disabled": False,
        "dnssec": False,
        "enable_updatepolicy": False,
        "expire": "test_services_bind_zone",
        "minimum": "test_services_bind_zone",
        "records": [],
        "refresh": "test_services_bind_zone",
        "regdhcpstatic": False,
        "retry": "test_services_bind_zone",
        "reversev4": False,
        "reversev6": False,
        "rpz": False,
        "slaveip": "test_services_bind_zone",
        "ttl": 1,
        "type": 'master',
        "updatepolicy": "test_services_bind_zone",
        "view": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/zone",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/zones",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/zone",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/zone",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_zone_record(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/zone/record (needs: services/bind/zone)"""
    # Setup: create parent services/bind/zone
    p0_resp = client.post(
        "/api/v2/services/bind/zone",
        json={
        "name": 'pftzrec.example.com',
        "nameserver": 'ns1.example.com',
        "mail": 'admin.example.com',
        "serial": 2024010101,
        "forwarders": [],
        "baseip": '10.99.99.0',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'testrec',
                "type": 'A',
                "rdata": '10.99.99.1',
                "priority": 0,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/bind/zone/record",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/bind/zone/record",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/bind/zone/record", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/bind/zone", p0_id)


def test_crud_services_cron_job(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/cron/job"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/cron/job",
        json={
        "command": "echo test",
        "hour": "0",
        "mday": "*",
        "minute": "0",
        "month": "*",
        "wday": "*",
        "who": "root",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/cron/job",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/cron/jobs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/cron/job",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dhcp_server: per-interface singleton  POST not supported by design, PATCH tested via singleton

def test_crud_services_dhcp_server_address_pool(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/address_pool (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "range_from": '192.168.1.210',
            "range_to": '192.168.1.220',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/address_pool",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/address_pool",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/address_pool", obj_id, {"parent_id": 'lan'})


def test_crud_services_dhcp_server_custom_option(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/custom_option (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "number": 252,
            "type": 'text',
            "value": 'http://wpad.example.com/wpad.dat',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/custom_option",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/custom_option",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/custom_option", obj_id, {"parent_id": 'lan'})


def test_crud_services_dhcp_server_static_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/static_mapping (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "mac": '00:11:22:33:44:55',
            "ipaddr": '192.168.1.250',
            "descr": 'Test static map',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/static_mapping",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/static_mapping",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dhcp_server/static_mapping",
            json={"id": obj_id, "parent_id": 'lan', "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/static_mapping", obj_id, {"parent_id": 'lan'})


def test_crud_services_dns_forwarder_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_forwarder/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_forwarder/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": "10.99.99.2",
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_forwarder/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_forwarder/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_forwarder/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_forwarder/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_forwarder_host_override_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_forwarder/host_override/alias (needs: services/dns_forwarder/host_override)"""
    # Setup: create parent services/dns_forwarder/host_override
    p0_resp = client.post(
        "/api/v2/services/dns_forwarder/host_override",
        json={
        "domain": 'example.com',
        "host": 'pft-dnsfwd-al',
        "ip": '10.99.99.2',
        "aliases": [],
        "descr": 'Test host override for alias',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "host": 'testalias',
                "domain": 'alias.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_forwarder/host_override/alias",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_forwarder/host_override/alias",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_forwarder/host_override/alias", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_forwarder/host_override", p0_id)


def test_crud_services_dns_resolver_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/access_list",
        json={
        "action": 'allow',
        "name": "pft_services_d",
        "networks": [],
        "description": "test_services_dns_resolver_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_access_list_network(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/access_list/network (needs: services/dns_resolver/access_list)"""
    # Setup: create parent services/dns_resolver/access_list
    p0_resp = client.post(
        "/api/v2/services/dns_resolver/access_list",
        json={
        "action": 'allow',
        "name": 'pft_dnsacl_nw',
        "networks": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "network": '10.1.0.0',
                "mask": 16,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_resolver/access_list/network",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_resolver/access_list/network",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_resolver/access_list/network", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_resolver/access_list", p0_id)


def test_crud_services_dns_resolver_domain_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/domain_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/domain_override",
        json={
        "domain": "example.com",
        "ip": "10.99.99.2",
        "descr": "Test created by generator",
        "forward_tls_upstream": False,
        "tls_hostname": "test_services_dns_resolver_domain_override",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/domain_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/domain_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/domain_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/domain_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": ["10.99.99.2"],
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_host_override_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/host_override/alias (needs: services/dns_resolver/host_override)"""
    # Setup: create parent services/dns_resolver/host_override
    p0_resp = client.post(
        "/api/v2/services/dns_resolver/host_override",
        json={
        "domain": 'example.com',
        "host": 'pft-dnsres-al',
        "ip": ['10.99.99.2'],
        "aliases": [],
        "descr": 'Test host override for alias',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "host": 'testalias',
                "domain": 'alias.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_resolver/host_override/alias",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_resolver/host_override/alias",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_resolver/host_override/alias", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_resolver/host_override", p0_id)


def test_crud_services_freeradius_client(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/freeradius/client"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/freeradius/client",
        json={
        "addr": "10.99.99.90",
        "secret": "TestSecret123",
        "shortname": "pft_frcl",
        "description": "test_services_freeradius_client",
        "ip_version": 'ipaddr',
        "maxconn": 1,
        "msgauth": False,
        "naslogin": "test_services_freeradius_client",
        "naspassword": "test_services_freeradius_client",
        "nastype": 'cisco',
        "proto": 'udp',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/freeradius/client",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/freeradius/client",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/freeradius/client",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_freeradius_interface(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/freeradius/interface"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/freeradius/interface",
        json={
        "addr": "127.0.0.1",
        "ip_version": "ipaddr",
        "description": "test_services_freeradius_interface",
        "port": "443",
        "type": 'auth',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/freeradius/interface",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/freeradius/interface",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/freeradius/interface",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_freeradius_user(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/freeradius/user"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/freeradius/user",
        json={
        "motp_pin": "",
        "motp_secret": "",
        "password": "TestPass123",
        "username": "pft_fruser",
        "description": "test_services_freeradius_user",
        "framed_ip_address": "10.99.99.99",
        "framed_ip_netmask": "10.99.99.99",
        "motp_authmethod": 'motp',
        "motp_enable": False,
        "motp_offset": 1,
        "password_encryption": 'Cleartext-Password',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/freeradius/user",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/freeradius/user",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/freeradius/user",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_haproxy_backend(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "agent_port": "443",
        "name": "pft_services_h",
        "persist_cookie_name": "test_services_haproxy_backend",
        "acls": [],
        "actions": [],
        "advanced": "test_services_haproxy_backend",
        "advanced_backend": "test_services_haproxy_backend",
        "agent_checks": False,
        "agent_inter": 1,
        "balance": '',
        "balance_uridepth": 1,
        "balance_urilen": 1,
        "balance_uriwhole": False,
        "check_type": 'none',
        "checkinter": 1,
        "connection_timeout": 1,
        "cookie_attribute_secure": False,
        "email_level": '',
        "email_to": "test@example.com",
        "errorfiles": [],
        "haproxy_cookie_domains": [],
        "haproxy_cookie_dynamic_cookie_key": "test_services_haproxy_backend",
        "haproxy_cookie_maxidle": 1,
        "haproxy_cookie_maxlife": 1,
        "httpcheck_method": 'OPTIONS',
        "log_health_checks": False,
        "monitor_domain": "test_services_haproxy_backend",
        "monitor_httpversion": "test_services_haproxy_backend",
        "monitor_uri": "test_services_haproxy_backend",
        "monitor_username": "test_services_haproxy_backend",
        "persist_cookie_cachable": False,
        "persist_cookie_enabled": False,
        "persist_cookie_httponly": False,
        "persist_cookie_mode": 'passive',
        "persist_cookie_postonly": False,
        "persist_cookie_secure": False,
        "persist_stick_cookiename": "test_services_haproxy_backend",
        "persist_stick_expire": "test_services_haproxy_backend",
        "persist_stick_length": 1,
        "persist_stick_tablesize": "test_services_haproxy_backend",
        "persist_sticky_type": 'none',
        "retries": 1,
        "server_timeout": 1,
        "servers": [],
        "stats_admin": "test_services_haproxy_backend",
        "stats_desc": "test_services_haproxy_backend",
        "stats_enabled": False,
        "stats_node": "test_services_haproxy_backend",
        "stats_password": "test_services_haproxy_backend",
        "stats_realm": "test_services_haproxy_backend",
        "stats_refresh": 1,
        "stats_scope": [],
        "stats_uri": "test_services_haproxy_backend",
        "stats_username": "test_services_haproxy_backend",
        "strict_transport_security": 1,
        "transparent_clientip": False,
        "transparent_interface": "test_services_haproxy_backend",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/backend",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/backends",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/haproxy/backend",
            json={"id": obj_id, "advanced": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("advanced") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/backend",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_haproxy_backend_acl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/acl (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bacl',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bacl',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_bacl',
                "expression": 'host_starts_with',
                "value": 'test.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/haproxy/backend/acl",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/backend/acl",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/backend/acl",
                json={"id": obj_id, "parent_id": p0["id"], "value": "updated.example.com"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/acl", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_backend_action(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/action (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bact',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bact',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # Setup: create sibling services/haproxy/backend/acl
        sib0_body = {
                "name": 'pft_acl_bact',
                "expression": 'host_starts_with',
                "value": 'test.example.com',
            }
        sib0_body["parent_id"] = p0["id"]
        sib0_resp = client.post(
            "/api/v2/services/haproxy/backend/acl",
            json=sib0_body,
        )
        sib0 = _ok(sib0_resp)
        sib0_id = sib0.get("id")

        # CREATE
        body = {
                "action": 'http-request_deny',
                "server": '',
                "customaction": '',
                "deny_status": '403',
                "realm": '',
                "rule": '',
                "lua_function": '',
                "name": '',
                "fmt": '',
                "find": '',
                "replace": '',
                "path": '',
                "status": '',
                "reason": 'Denied',
            }
        body["parent_id"] = p0["id"]
        body["acl"] = sib0["name"]
        create_resp = client.post(
            "/api/v2/services/haproxy/backend/action",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/backend/action",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/action", obj_id, {"parent_id": p0["id"]})
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/acl", sib0_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_backend_error_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/error_file (needs: services/haproxy/file, services/haproxy/backend)"""
    # Setup: create parent services/haproxy/file
    p0_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "name": 'pft_ha_efb',
        "content": 'PCFET0NUWVBFIGh0bWw+',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/backend
    p1_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bef',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bef',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "errorcode": 503,
                    "errorfile": 'pft_ha_efb',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/backend/error_file",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/backend/error_file",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/backend/error_file", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/file", p0_id)


def test_crud_services_haproxy_backend_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/server (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bsrv',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bsrv',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_bsrv',
                "address": '10.99.99.50',
                "port": '8080',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/haproxy/backend/server",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/backend/server",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/backend/server",
                json={"id": obj_id, "parent_id": p0["id"], "address": "10.99.99.51"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/server", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/file"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "content": "test_services_haproxy_file",
        "name": "pft_haproxy",
        "type": 'luascript',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/file",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/files",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/file",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_haproxy_frontend(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_fe',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for fe',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_fe_chain',
                "type": 'http',
                "descr": 'Test frontend',
            }
        create_resp = client.post(
            "/api/v2/services/haproxy/frontend",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/frontend",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/frontend",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_frontend_acl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/acl (needs: services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_facl',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for facl',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/frontend
    p1_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_acl',
        "type": 'http',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "name": 'pft_facl',
                    "expression": 'host_starts_with',
                    "value": 'test.example.com',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/frontend/acl",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/frontend/acl",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/services/haproxy/frontend/acl",
                    json={"id": obj_id, "parent_id": p1["id"], "value": "updated.example.com"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/acl", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_frontend_action(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/action (needs: services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_fact',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for fact',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/frontend
    p1_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_act',
        "type": 'http',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # Setup: create sibling services/haproxy/frontend/acl
            sib0_body = {
                    "name": 'pft_acl_fact',
                    "expression": 'host_starts_with',
                    "value": 'test.example.com',
                }
            sib0_body["parent_id"] = p1["id"]
            sib0_resp = client.post(
                "/api/v2/services/haproxy/frontend/acl",
                json=sib0_body,
            )
            sib0 = _ok(sib0_resp)
            sib0_id = sib0.get("id")

            # CREATE
            body = {
                    "action": 'http-request_deny',
                    "server": '',
                    "customaction": '',
                    "deny_status": '403',
                    "realm": '',
                    "rule": '',
                    "lua_function": '',
                    "name": '',
                    "fmt": '',
                    "find": '',
                    "replace": '',
                    "path": '',
                    "status": '',
                    "reason": 'Denied',
                }
            body["parent_id"] = p1["id"]
            body["acl"] = sib0["name"]
            create_resp = client.post(
                "/api/v2/services/haproxy/frontend/action",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/frontend/action",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/action", obj_id, {"parent_id": p1["id"]})
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/acl", sib0_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_frontend_address(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/address (needs: services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_faddr',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for faddr',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/frontend
    p1_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_addr',
        "type": 'http',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "extaddr": 'custom',
                    "extaddr_custom": '10.99.99.80:80',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/frontend/address",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/frontend/address",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/address", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


# SKIP /api/v2/services/haproxy/frontend/certificate: chained test missing child_body

def test_crud_services_haproxy_frontend_error_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/error_file (needs: services/haproxy/file, services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/file
    p0_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "name": 'pft_ha_eff',
        "content": 'PCFET0NUWVBFIGh0bWw+',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/backend
    p1_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_fef',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for fef',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent services/haproxy/frontend
    p2_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_ef',
        "type": 'http',
    },
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "errorcode": 503,
                        "errorfile": 'pft_ha_eff',
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/services/haproxy/frontend/error_file",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/services/haproxy/frontend/error_file",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/services/haproxy/frontend/error_file", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/file", p0_id)


# SKIP /api/v2/services/haproxy/settings/dns_resolver: 500 parent Model not constructed  GET/DELETE broken even after config.xml init (confirmed v2.7.1 bug)

# SKIP /api/v2/services/haproxy/settings/email_mailer: 500 parent Model not constructed  GET/DELETE broken even after config.xml init (confirmed v2.7.1 bug)

def test_crud_services_ntp_time_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/ntp/time_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/ntp/time_server",
        json={
        "timeserver": "10.99.99.99",
        "noselect": False,
        "prefer": False,
        "type": 'server',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/ntp/time_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/ntp/time_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/ntp/time_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_service_watchdog(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/service_watchdog"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/service_watchdog",
        json={
        "name": "sshd",
        "notify": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/service_watchdog",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/service_watchdogs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/service_watchdog",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_system_certificate(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/certificate (chained)"""
    # CREATE
    body = {
            "descr": 'Test Cert',
            "crt": CERT_PEM,
            "prv": CERT_KEY_PEM,
        }
    create_resp = client.post(
        "/api/v2/system/certificate",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/certificate",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/certificate",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/system/certificate", obj_id)


def test_crud_system_certificate_authority(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/certificate_authority (chained)"""
    # CREATE
    body = {
            "descr": 'Test CA',
            "crt": CA_CERT_PEM,
            "prv": CA_KEY_PEM,
        }
    create_resp = client.post(
        "/api/v2/system/certificate_authority",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/certificate_authority",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/certificate_authority",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", obj_id)


def test_crud_system_crl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/crl (needs: system/certificate_authority)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for CRL',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "descr": 'Test CRL',
                "method": 'internal',
                "text": '',
            }
        body["caref"] = p0["refid"]
        create_resp = client.post(
            "/api/v2/system/crl",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/system/crl",
                params={"id": obj_id},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/system/crl", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_system_crl_revoked_certificate(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/crl/revoked_certificate (needs: system/certificate_authority, system/certificate, system/crl)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'CA for CRL revoke',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Cert for CRL revoke',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent system/crl
    p2_body = {
        "descr": 'CRL for revoke',
        "method": 'internal',
        "text": '',
    }
    p2_body["caref"] = p0["refid"]
    p2_resp = client.post(
        "/api/v2/system/crl",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "revoke_time": 1700000000,
                        "reason": 0,
                    }
                body["caref"] = p0["refid"]
                body["certref"] = p1["refid"]
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/system/crl/revoked_certificate",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/system/crl/revoked_certificate",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/system/crl/revoked_certificate", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/system/crl", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_system_restapi_access_list_entry(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/restapi/access_list/entry"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/restapi/access_list/entry",
        json={
        "network": "10.99.99.0/24",
        "descr": "Test created by generator",
        "type": 'allow',
        "users": [],
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/restapi/access_list/entry",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/restapi/access_list/entries",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/restapi/access_list/entry",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/restapi/access_list/entry",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_system_tunable(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/tunable"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/tunable",
        json={
        "tunable": "test_system_tunable",
        "value": "1",
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/tunable",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/tunables",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/tunable",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/tunable",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user",
        json={
        "name": "pft_user",
        "password": "Testpass123!Abc",
        "authorizedkeys": "test_user",
        "cert": [],
        "descr": "Test created by generator",
        "disabled": False,
        "expires": "12/31/2030",
        "ipsecpsk": "test_user",
        "priv": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/users",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_auth_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/auth_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/auth_server",
        json={
        "host": "10.99.99.70",
        "ldap_bindpw": "test_user_auth_server",
        "ldap_port": "389",
        "ldap_scope": "one",
        "ldap_urltype": "Standard TCP",
        "name": "pft_user_auth_",
        "radius_nasip_attribute": "lan",
        "radius_secret": "test_user_auth_server",
        "type": "ldap",
        "ldap_allow_unauthenticated": False,
        "ldap_attr_group": "cn",
        "ldap_attr_groupobj": "posixGroup",
        "ldap_attr_member": "member",
        "ldap_attr_user": "uid",
        "ldap_authcn": "ou=people,dc=example,dc=com",
        "ldap_basedn": "dc=example,dc=com",
        "ldap_binddn": "test_user_auth_server",
        "ldap_caref": "test_user_auth_server",
        "ldap_extended_enabled": False,
        "ldap_extended_query": "test_user_auth_server",
        "ldap_nostrip_at": False,
        "ldap_pam_groupdn": "test_user_auth_server",
        "ldap_protver": 3,
        "ldap_rfc2307": False,
        "ldap_rfc2307_userdn": False,
        "ldap_timeout": 25,
        "ldap_utf8": False,
        "radius_acct_port": "1813",
        "radius_auth_port": "1812",
        "radius_protocol": 'MSCHAPv2',
        "radius_timeout": 5,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/auth_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/auth_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/auth_server",
            json={"id": obj_id, "ldap_attr_group": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("ldap_attr_group") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/auth_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/group",
        json={
        "name": "pft_user_group",
        "description": "test_user_group",
        "member": [],
        "priv": [],
        "scope": 'local',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/group",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_vpn_ipsec_phase1(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase1 (needs: system/certificate_authority, system/certificate)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for IPsec',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for IPsec',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "iketype": 'ikev2',
                    "mode": 'main',
                    "protocol": 'inet',
                    "interface": 'wan',
                    "remote_gateway": '10.99.99.20',
                    "authentication_method": 'pre_shared_key',
                    "myid_type": 'myaddress',
                    "myid_data": '',
                    "peerid_type": 'any',
                    "peerid_data": '',
                    "pre_shared_key": 'TestPSK123456789012345',
                    "descr": 'Test IPsec P1',
                    "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
                }
            body["caref"] = p0["refid"]
            body["certref"] = p1["refid"]
            create_resp = client.post(
                "/api/v2/vpn/ipsec/phase1",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/ipsec/phase1",
                    params={"id": obj_id},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/vpn/ipsec/phase1",
                    json={"id": obj_id, "descr": "Updated by test"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", obj_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase1_encryption(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase1/encryption (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P1enc',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P1enc',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.21',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for enc',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "encryption_algorithm_name": 'aes128gcm',
                        "encryption_algorithm_keylen": 128,
                        "hash_algorithm": 'sha256',
                        "dhgroup": 14,
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/vpn/ipsec/phase1/encryption",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/vpn/ipsec/phase1/encryption",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1/encryption", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase2(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase2 (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P2',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P2',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.22',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for P2',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "mode": 'tunnel',
                        "localid_type": 'network',
                        "localid_address": '10.0.0.0',
                        "localid_netbits": 24,
                        "natlocalid_address": '',
                        "natlocalid_netbits": 0,
                        "remoteid_type": 'network',
                        "remoteid_address": '10.200.0.0',
                        "remoteid_netbits": 24,
                        "descr": 'Test IPsec P2',
                        "encryption_algorithm_option": [{'name': 'aes', 'keylen': 256}],
                        "hash_algorithm_option": ['hmac_sha256'],
                    }
                body["ikeid"] = p2["ikeid"]
                create_resp = client.post(
                    "/api/v2/vpn/ipsec/phase2",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/vpn/ipsec/phase2",
                        params={"id": obj_id},
                    )
                    _ok(get_resp)

                    # UPDATE
                    update_resp = client.patch(
                        "/api/v2/vpn/ipsec/phase2",
                        json={"id": obj_id, "descr": "Updated by test"},
                    )
                    _ok(update_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2", obj_id)
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase2_encryption(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase2/encryption (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1, vpn/ipsec/phase2)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P2enc',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P2enc',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.23',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for P2enc',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    # Setup: create parent vpn/ipsec/phase2
    p3_body = {
        "mode": 'tunnel',
        "localid_type": 'network',
        "localid_address": '10.0.0.0',
        "localid_netbits": 24,
        "natlocalid_address": '',
        "natlocalid_netbits": 0,
        "remoteid_type": 'network',
        "remoteid_address": '10.200.0.0',
        "remoteid_netbits": 24,
        "descr": 'Test P2 for enc',
        "encryption_algorithm_option": [{'name': 'aes', 'keylen': 256}],
        "hash_algorithm_option": ['hmac_sha256'],
    }
    p3_body["ikeid"] = p2["ikeid"]
    p3_resp = client.post(
        "/api/v2/vpn/ipsec/phase2",
        json=p3_body,
    )
    p3 = _ok(p3_resp)
    p3_id = p3.get("id")
    assert p3_id is not None, f"No id in parent response: {p3}"

    try:
        try:
            try:
                try:
                    # CREATE
                    body = {
                            "name": 'aes128gcm',
                            "keylen": 128,
                        }
                    body["parent_id"] = p3["id"]
                    create_resp = client.post(
                        "/api/v2/vpn/ipsec/phase2/encryption",
                        json=body,
                    )
                    data = _ok(create_resp)
                    obj_id = data.get("id")
                    assert obj_id is not None, f"No id in create response: {data}"

                    try:
                        # GET (singular)
                        get_resp = client.get(
                            "/api/v2/vpn/ipsec/phase2/encryption",
                            params={"id": obj_id, "parent_id": p3["id"]},
                        )
                        _ok(get_resp)

                    finally:
                        _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2/encryption", obj_id, {"parent_id": p3["id"]})
                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2", p3_id)
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_openvpn_client(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/client (needs: system/certificate_authority)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for OVPN cli',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "mode": 'p2p_tls',
                "dev_mode": 'tun',
                "protocol": 'UDP4',
                "interface": 'wan',
                "server_addr": '10.99.99.30',
                "server_port": '1194',
                "proxy_user": '',
                "proxy_passwd": '',
                "tls_type": 'auth',
                "data_ciphers": ['AES-256-GCM'],
                "data_ciphers_fallback": 'AES-256-GCM',
                "digest": 'SHA256',
                "description": 'Test OVPN client',
            }
        body["caref"] = p0["refid"]
        create_resp = client.post(
            "/api/v2/vpn/openvpn/client",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/openvpn/client",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/vpn/openvpn/client",
                json={"id": obj_id, "description": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/openvpn/client", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


# SKIP /api/v2/vpn/openvpn/client_export/config: tested via custom test_action_vpn_openvpn_client_export (6-step chain)

def test_crud_vpn_openvpn_cso(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/cso (chained)"""
    # CREATE
    body = {
            "common_name": 'pft_ovpn_cso',
            "description": 'Test CSO',
        }
    create_resp = client.post(
        "/api/v2/vpn/openvpn/cso",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/vpn/openvpn/cso",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/vpn/openvpn/cso",
            json={"id": obj_id, "description": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/vpn/openvpn/cso", obj_id)


def test_crud_vpn_openvpn_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/server (needs: system/certificate_authority, system/certificate)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for OVPN srv',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for OVPN srv',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "mode": 'p2p_tls',
                    "dev_mode": 'tun',
                    "protocol": 'UDP4',
                    "interface": 'wan',
                    "tls_type": 'auth',
                    "dh_length": '2048',
                    "ecdh_curve": 'prime256v1',
                    "data_ciphers": ['AES-256-GCM'],
                    "data_ciphers_fallback": 'AES-256-GCM',
                    "digest": 'SHA256',
                    "description": 'Test OVPN server',
                    "serverbridge_interface": '',
                    "serverbridge_dhcp_start": '',
                    "serverbridge_dhcp_end": '',
                }
            body["caref"] = p0["refid"]
            body["certref"] = p1["refid"]
            create_resp = client.post(
                "/api/v2/vpn/openvpn/server",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/openvpn/server",
                    params={"id": obj_id},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/vpn/openvpn/server",
                    json={"id": obj_id, "description": "Updated by test"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/openvpn/server", obj_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_wireguard_peer(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/peer (needs: vpn/wireguard/tunnel)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_peer',
        "listenport": '51821',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "publickey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
                "descr": 'Test WG peer',
            }
        body["tun"] = p0["name"]
        create_resp = client.post(
            "/api/v2/vpn/wireguard/peer",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/wireguard/peer",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/vpn/wireguard/peer",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/peer", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_crud_vpn_wireguard_peer_allowed_ip(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/peer/allowed_ip (needs: vpn/wireguard/tunnel, vpn/wireguard/peer)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_aip',
        "listenport": '51823',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent vpn/wireguard/peer
    p1_resp = client.post(
        "/api/v2/vpn/wireguard/peer",
        json={
        "tun": 'pft_tun_aip',
        "publickey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "descr": 'Test WG peer for allowed_ip',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "address": '10.200.0.0',
                    "mask": 24,
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/vpn/wireguard/peer/allowed_ip",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/wireguard/peer/allowed_ip",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/wireguard/peer/allowed_ip", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/peer", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_crud_vpn_wireguard_tunnel(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/tunnel"""
    # CREATE
    create_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "privatekey": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=",
        "addresses": [],
        "descr": "Test created by generator",
        "enabled": False,
        "listenport": "51820",
        "mtu": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/vpn/wireguard/tunnel",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/vpn/wireguard/tunnels",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/vpn/wireguard/tunnel",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/vpn/wireguard/tunnel",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_vpn_wireguard_tunnel_address(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/tunnel/address (needs: vpn/wireguard/tunnel)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_addr',
        "listenport": '51822',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "address": '10.100.0.1',
                "mask": 24,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/vpn/wireguard/tunnel/address",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/wireguard/tunnel/address",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel/address", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_settings_firewall_advanced_settings(client: httpx.Client):
    """Settings read: /api/v2/firewall/advanced_settings"""
    # GET current settings
    resp = client.get("/api/v2/firewall/advanced_settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_acme_settings(client: httpx.Client):
    """Settings read: /api/v2/services/acme/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/acme/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_sync_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/sync/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/sync/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_dns_resolver_settings(client: httpx.Client):
    """Settings read: /api/v2/services/dns_resolver/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/dns_resolver/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_haproxy_settings(client: httpx.Client):
    """Settings read: /api/v2/services/haproxy/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/haproxy/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_ntp_settings(client: httpx.Client):
    """Settings read: /api/v2/services/ntp/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/ntp/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_status_logs_settings(client: httpx.Client):
    """Settings read: /api/v2/status/logs/settings"""
    # GET current settings
    resp = client.get("/api/v2/status/logs/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_restapi_settings(client: httpx.Client):
    """Settings read: /api/v2/system/restapi/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/restapi/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_webgui_settings(client: httpx.Client):
    """Settings read: /api/v2/system/webgui/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/webgui/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_vpn_wireguard_settings(client: httpx.Client):
    """Settings read: /api/v2/vpn/wireguard/settings"""
    # GET current settings
    resp = client.get("/api/v2/vpn/wireguard/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_read_auth_keys(client: httpx.Client):
    """Read-only: /api/v2/auth/keys"""
    resp = client.get("/api/v2/auth/keys")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table"""
    resp = client.get("/api/v2/diagnostics/arp_table")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table_entry(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table/entry"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/arp_table/entry", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revision(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revision"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/config_history/revision", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revisions(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revisions"""
    resp = client.get("/api/v2/diagnostics/config_history/revisions")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/table"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/table", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_firewall_aliases(client: httpx.Client):
    """Read-only: /api/v2/firewall/aliases"""
    resp = client.get("/api/v2/firewall/aliases")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_one_to_one_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/one_to_one/mappings"""
    resp = client.get("/api/v2/firewall/nat/one_to_one/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_outbound_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/outbound/mappings"""
    resp = client.get("/api/v2/firewall/nat/outbound/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_port_forwards(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/port_forwards"""
    resp = client.get("/api/v2/firewall/nat/port_forwards")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_rules(client: httpx.Client):
    """Read-only: /api/v2/firewall/rules"""
    resp = client.get("/api/v2/firewall/rules")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_schedules(client: httpx.Client):
    """Read-only: /api/v2/firewall/schedules"""
    resp = client.get("/api/v2/firewall/schedules")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_state(client: httpx.Client):
    """Read-only: /api/v2/firewall/state"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/firewall/state", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_firewall_states(client: httpx.Client):
    """Read-only: /api/v2/firewall/states"""
    resp = client.get("/api/v2/firewall/states")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_traffic_shaper_limiters(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shaper/limiters"""
    resp = client.get("/api/v2/firewall/traffic_shaper/limiters", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_firewall_traffic_shapers(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shapers"""
    resp = client.get("/api/v2/firewall/traffic_shapers")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_virtual_ips(client: httpx.Client):
    """Read-only: /api/v2/firewall/virtual_ips"""
    resp = client.get("/api/v2/firewall/virtual_ips")
    data = _ok(resp)
    assert data is not None


def test_read_interface_available_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interface/available_interfaces"""
    resp = client.get("/api/v2/interface/available_interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_bridges(client: httpx.Client):
    """Read-only: /api/v2/interface/bridges"""
    resp = client.get("/api/v2/interface/bridges", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_gres(client: httpx.Client):
    """Read-only: /api/v2/interface/gres"""
    resp = client.get("/api/v2/interface/gres")
    data = _ok(resp)
    assert data is not None


def test_read_interface_groups(client: httpx.Client):
    """Read-only: /api/v2/interface/groups"""
    resp = client.get("/api/v2/interface/groups")
    data = _ok(resp)
    assert data is not None


def test_read_interface_laggs(client: httpx.Client):
    """Read-only: /api/v2/interface/laggs"""
    resp = client.get("/api/v2/interface/laggs")
    data = _ok(resp)
    assert data is not None


def test_read_interface_vlans(client: httpx.Client):
    """Read-only: /api/v2/interface/vlans"""
    resp = client.get("/api/v2/interface/vlans")
    data = _ok(resp)
    assert data is not None


def test_read_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interfaces"""
    resp = client.get("/api/v2/interfaces")
    data = _ok(resp)
    assert data is not None


def test_read_routing_gateway_groups(client: httpx.Client):
    """Read-only: /api/v2/routing/gateway/groups"""
    resp = client.get("/api/v2/routing/gateway/groups")
    data = _ok(resp)
    assert data is not None


def test_read_routing_gateways(client: httpx.Client):
    """Read-only: /api/v2/routing/gateways"""
    resp = client.get("/api/v2/routing/gateways")
    data = _ok(resp)
    assert data is not None


def test_read_routing_static_routes(client: httpx.Client):
    """Read-only: /api/v2/routing/static_routes"""
    resp = client.get("/api/v2/routing/static_routes")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_account_key_registrations(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_key/registrations"""
    resp = client.get("/api/v2/services/acme/account_key/registrations", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_account_keys(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_keys"""
    resp = client.get("/api/v2/services/acme/account_keys")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_certificate_issuances(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/issuances"""
    resp = client.get("/api/v2/services/acme/certificate/issuances", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificate_renewals(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/renewals"""
    resp = client.get("/api/v2/services/acme/certificate/renewals", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificates(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificates"""
    resp = client.get("/api/v2/services/acme/certificates")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/bind/access_lists"""
    resp = client.get("/api/v2/services/bind/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_sync_remote_hosts(client: httpx.Client):
    """Read-only: /api/v2/services/bind/sync/remote_hosts"""
    resp = client.get("/api/v2/services/bind/sync/remote_hosts")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_views(client: httpx.Client):
    """Read-only: /api/v2/services/bind/views"""
    resp = client.get("/api/v2/services/bind/views")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_zones(client: httpx.Client):
    """Read-only: /api/v2/services/bind/zones"""
    resp = client.get("/api/v2/services/bind/zones")
    data = _ok(resp)
    assert data is not None


def test_read_services_cron_jobs(client: httpx.Client):
    """Read-only: /api/v2/services/cron/jobs"""
    resp = client.get("/api/v2/services/cron/jobs")
    data = _ok(resp)
    assert data is not None


def test_read_services_dhcp_servers(client: httpx.Client):
    """Read-only: /api/v2/services/dhcp_servers"""
    resp = client.get("/api/v2/services/dhcp_servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_dns_forwarder_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_forwarder/host_overrides"""
    resp = client.get("/api/v2/services/dns_forwarder/host_overrides")
    data = _ok(resp)
    assert data is not None


def test_read_services_dns_resolver_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/access_lists"""
    resp = client.get("/api/v2/services/dns_resolver/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_dns_resolver_domain_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/domain_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/domain_overrides")
    data = _ok(resp)
    assert data is not None


def test_read_services_dns_resolver_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/host_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/host_overrides")
    data = _ok(resp)
    assert data is not None


def test_read_services_haproxy_backends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/backends"""
    resp = client.get("/api/v2/services/haproxy/backends")
    data = _ok(resp)
    assert data is not None


def test_read_services_haproxy_files(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/files"""
    resp = client.get("/api/v2/services/haproxy/files")
    data = _ok(resp)
    assert data is not None


def test_read_services_haproxy_frontends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/frontends"""
    resp = client.get("/api/v2/services/haproxy/frontends")
    data = _ok(resp)
    assert data is not None


def test_read_services_ntp_time_servers(client: httpx.Client):
    """Read-only: /api/v2/services/ntp/time_servers"""
    resp = client.get("/api/v2/services/ntp/time_servers")
    data = _ok(resp)
    assert data is not None


def test_read_services_service_watchdogs(client: httpx.Client):
    """Read-only: /api/v2/services/service_watchdogs"""
    resp = client.get("/api/v2/services/service_watchdogs")
    data = _ok(resp)
    assert data is not None


def test_read_status_dhcp_server_leases(client: httpx.Client):
    """Read-only: /api/v2/status/dhcp_server/leases"""
    resp = client.get("/api/v2/status/dhcp_server/leases")
    data = _ok(resp)
    assert data is not None


def test_read_status_gateways(client: httpx.Client):
    """Read-only: /api/v2/status/gateways"""
    resp = client.get("/api/v2/status/gateways", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_interfaces(client: httpx.Client):
    """Read-only: /api/v2/status/interfaces"""
    resp = client.get("/api/v2/status/interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_ipsec_sas(client: httpx.Client):
    """Read-only: /api/v2/status/ipsec/sas"""
    resp = client.get("/api/v2/status/ipsec/sas", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_logs_dhcp(client: httpx.Client):
    """Read-only: /api/v2/status/logs/dhcp"""
    resp = client.get("/api/v2/status/logs/dhcp", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_logs_firewall(client: httpx.Client):
    """Read-only: /api/v2/status/logs/firewall"""
    resp = client.get("/api/v2/status/logs/firewall", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_logs_system(client: httpx.Client):
    """Read-only: /api/v2/status/logs/system"""
    resp = client.get("/api/v2/status/logs/system", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/clients"""
    resp = client.get("/api/v2/status/openvpn/clients", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/servers"""
    resp = client.get("/api/v2/status/openvpn/servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_services(client: httpx.Client):
    """Read-only: /api/v2/status/services"""
    resp = client.get("/api/v2/status/services", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_system(client: httpx.Client):
    """Read-only: /api/v2/status/system"""
    resp = client.get("/api/v2/status/system")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificate_authorities(client: httpx.Client):
    """Read-only: /api/v2/system/certificate_authorities"""
    resp = client.get("/api/v2/system/certificate_authorities")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificates(client: httpx.Client):
    """Read-only: /api/v2/system/certificates"""
    resp = client.get("/api/v2/system/certificates")
    data = _ok(resp)
    assert data is not None


def test_read_system_crls(client: httpx.Client):
    """Read-only: /api/v2/system/crls"""
    resp = client.get("/api/v2/system/crls")
    data = _ok(resp)
    assert data is not None


def test_read_system_package_available(client: httpx.Client):
    """Read-only: /api/v2/system/package/available"""
    resp = client.get("/api/v2/system/package/available", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_system_packages(client: httpx.Client):
    """Read-only: /api/v2/system/packages"""
    resp = client.get("/api/v2/system/packages")
    data = _ok(resp)
    assert data is not None


def test_read_system_restapi_access_list(client: httpx.Client):
    """Read-only: /api/v2/system/restapi/access_list"""
    resp = client.get("/api/v2/system/restapi/access_list")
    data = _ok(resp)
    assert data is not None


def test_read_system_tunables(client: httpx.Client):
    """Read-only: /api/v2/system/tunables"""
    resp = client.get("/api/v2/system/tunables")
    data = _ok(resp)
    assert data is not None


def test_read_system_version(client: httpx.Client):
    """Read-only: /api/v2/system/version"""
    resp = client.get("/api/v2/system/version")
    data = _ok(resp)
    assert data is not None


def test_read_user_auth_servers(client: httpx.Client):
    """Read-only: /api/v2/user/auth_servers"""
    resp = client.get("/api/v2/user/auth_servers")
    data = _ok(resp)
    assert data is not None


def test_read_user_groups(client: httpx.Client):
    """Read-only: /api/v2/user/groups"""
    resp = client.get("/api/v2/user/groups")
    data = _ok(resp)
    assert data is not None


def test_read_users(client: httpx.Client):
    """Read-only: /api/v2/users"""
    resp = client.get("/api/v2/users")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_ipsec_phase1s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase1s"""
    resp = client.get("/api/v2/vpn/ipsec/phase1s")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_ipsec_phase2s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase2s"""
    resp = client.get("/api/v2/vpn/ipsec/phase2s")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/clients"""
    resp = client.get("/api/v2/vpn/openvpn/clients")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_csos(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/csos"""
    resp = client.get("/api/v2/vpn/openvpn/csos")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/servers"""
    resp = client.get("/api/v2/vpn/openvpn/servers")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_wireguard_peers(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/peers"""
    resp = client.get("/api/v2/vpn/wireguard/peers")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_wireguard_tunnels(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/tunnels"""
    resp = client.get("/api/v2/vpn/wireguard/tunnels")
    data = _ok(resp)
    assert data is not None


def test_apply_firewall_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/apply"""
    resp = client.get("/api/v2/firewall/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_firewall_virtual_ip_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/virtual_ip/apply"""
    resp = client.get("/api/v2/firewall/virtual_ip/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_interface_apply(client: httpx.Client):
    """Apply status: /api/v2/interface/apply"""
    resp = client.get("/api/v2/interface/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_routing_apply(client: httpx.Client):
    """Apply status: /api/v2/routing/apply"""
    resp = client.get("/api/v2/routing/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dhcp_server_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dhcp_server/apply"""
    resp = client.get("/api/v2/services/dhcp_server/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_forwarder_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_forwarder/apply"""
    resp = client.get("/api/v2/services/dns_forwarder/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_resolver_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_resolver/apply"""
    resp = client.get("/api/v2/services/dns_resolver/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_haproxy_apply(client: httpx.Client):
    """Apply status: /api/v2/services/haproxy/apply"""
    resp = client.get("/api/v2/services/haproxy/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_ipsec_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/ipsec/apply"""
    resp = client.get("/api/v2/vpn/ipsec/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_wireguard_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/wireguard/apply"""
    resp = client.get("/api/v2/vpn/wireguard/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_singleton_firewall_nat_outbound_mode(client: httpx.Client):
    """Singleton roundtrip: /api/v2/firewall/nat/outbound/mode"""
    # GET current value
    resp = client.get("/api/v2/firewall/nat/outbound/mode")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("mode")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/firewall/nat/outbound/mode",
        json={'mode': 'hybrid'},
    )
    patched = _ok(patch_resp)
    assert patched.get("mode") == 'hybrid'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/firewall/nat/outbound/mode")
    verify = _ok(verify_resp)
    assert verify.get("mode") == 'hybrid'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/firewall/nat/outbound/mode", json={"mode": original_value})


def test_singleton_firewall_states_size(client: httpx.Client):
    """Singleton roundtrip: /api/v2/firewall/states/size"""
    # GET current value
    resp = client.get("/api/v2/firewall/states/size")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("maximumstates")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/firewall/states/size",
        json={'maximumstates': 500000},
    )
    patched = _ok(patch_resp)
    assert patched.get("maximumstates") == 500000

    # GET to verify persistence
    verify_resp = client.get("/api/v2/firewall/states/size")
    verify = _ok(verify_resp)
    assert verify.get("maximumstates") == 500000

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/firewall/states/size", json={"maximumstates": original_value})


def test_singleton_routing_gateway_default(client: httpx.Client):
    """Singleton roundtrip: /api/v2/routing/gateway/default"""
    # GET current value
    resp = client.get("/api/v2/routing/gateway/default")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("defaultgw4")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/routing/gateway/default",
        json={'defaultgw4': ''},
    )
    patched = _ok(patch_resp)
    assert patched.get("defaultgw4") == ''

    # GET to verify persistence
    verify_resp = client.get("/api/v2/routing/gateway/default")
    verify = _ok(verify_resp)
    assert verify.get("defaultgw4") == ''

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/routing/gateway/default", json={"defaultgw4": original_value})


def test_singleton_services_dhcp_relay(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/dhcp_relay"""
    # GET current value
    resp = client.get("/api/v2/services/dhcp_relay")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("enable")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/dhcp_relay",
        json={'enable': False, 'server': ['10.0.2.1']},
    )
    patched = _ok(patch_resp)
    assert patched.get("enable") == False

    # GET to verify persistence
    verify_resp = client.get("/api/v2/services/dhcp_relay")
    verify = _ok(verify_resp)
    assert verify.get("enable") == False

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/services/dhcp_relay", json={"enable": original_value, "server": ['10.0.2.1']})


def test_singleton_services_dhcp_server_backend(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/dhcp_server/backend"""
    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/dhcp_server/backend",
        json={'dhcpbackend': 'kea'},
    )
    patched = _ok(patch_resp)
    assert patched.get("dhcpbackend") == 'kea'

    # Restore original value
    client.patch(
        "/api/v2/services/dhcp_server/backend",
        json={'dhcpbackend': 'isc'},
    )


def test_singleton_services_ssh(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/ssh"""
    # GET current value
    resp = client.get("/api/v2/services/ssh")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("port")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/ssh",
        json={'port': '2222'},
    )
    patched = _ok(patch_resp)
    assert patched.get("port") == '2222'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/services/ssh")
    verify = _ok(verify_resp)
    assert verify.get("port") == '2222'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/services/ssh", json={"port": original_value})


def test_singleton_status_carp(client: httpx.Client):
    """Singleton roundtrip: /api/v2/status/carp"""
    # GET current value
    resp = client.get("/api/v2/status/carp")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("maintenance_mode")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/status/carp",
        json={'maintenance_mode': True, 'enable': True},
    )
    patched = _ok(patch_resp)
    assert patched.get("maintenance_mode") == True

    # GET to verify persistence
    verify_resp = client.get("/api/v2/status/carp")
    verify = _ok(verify_resp)
    assert verify.get("maintenance_mode") == True

    # Restore original value
    client.patch(
        "/api/v2/status/carp",
        json={'maintenance_mode': False, 'enable': True},
    )


def test_singleton_system_console(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/console"""
    # GET current value
    resp = client.get("/api/v2/system/console")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("passwd_protect_console")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/console",
        json={'passwd_protect_console': True},
    )
    patched = _ok(patch_resp)
    assert patched.get("passwd_protect_console") == True

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/console")
    verify = _ok(verify_resp)
    assert verify.get("passwd_protect_console") == True

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/console", json={"passwd_protect_console": original_value})


def test_singleton_system_dns(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/dns"""
    # GET current value
    resp = client.get("/api/v2/system/dns")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("dnsallowoverride")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/dns",
        json={'dnsallowoverride': False},
    )
    patched = _ok(patch_resp)
    assert patched.get("dnsallowoverride") == False

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/dns")
    verify = _ok(verify_resp)
    assert verify.get("dnsallowoverride") == False

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/dns", json={"dnsallowoverride": original_value})


def test_singleton_system_hostname(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/hostname"""
    # GET current value
    resp = client.get("/api/v2/system/hostname")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("hostname")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/hostname",
        json={'hostname': 'pfttest', 'domain': 'home.arpa'},
    )
    patched = _ok(patch_resp)
    assert patched.get("hostname") == 'pfttest'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/hostname")
    verify = _ok(verify_resp)
    assert verify.get("hostname") == 'pfttest'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/hostname", json={"hostname": original_value, "domain": 'home.arpa'})


def test_singleton_system_notifications_email_settings(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/notifications/email_settings"""
    # GET current value
    resp = client.get("/api/v2/system/notifications/email_settings")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("ipaddress")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/notifications/email_settings",
        json={'ipaddress': '127.0.0.1', 'username': 'test', 'password': 'test'},
    )
    patched = _ok(patch_resp)
    assert patched.get("ipaddress") == '127.0.0.1'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/notifications/email_settings")
    verify = _ok(verify_resp)
    assert verify.get("ipaddress") == '127.0.0.1'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/notifications/email_settings", json={"ipaddress": original_value, "username": 'test', "password": 'test'})


# SKIP /api/v2/system/restapi/version: PATCH triggers API version change (destructive)

def test_singleton_system_timezone(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/timezone"""
    # GET current value
    resp = client.get("/api/v2/system/timezone")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("timezone")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/timezone",
        json={'timezone': 'America/Chicago'},
    )
    assert patch_resp.status_code == 200, f"PATCH {patch_resp.status_code}: {patch_resp.text[:200]}"

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/timezone")
    verify = _ok(verify_resp)
    assert verify.get("timezone") == 'America/Chicago'

    # Restore original value
    client.patch(
        "/api/v2/system/timezone",
        json={'timezone': 'Etc/UTC'},
    )


def test_action_auth_jwt(client: httpx.Client):
    """Action: POST /api/v2/auth/jwt"""
    # Auth endpoints require BasicAuth, not API key
    ba_client = httpx.Client(
        base_url=BASE_URL,
        verify=False,
        auth=(AUTH_USER, AUTH_PASS),
        timeout=30,
    )
    resp = ba_client.post("/api/v2/auth/jwt", json={})
    data = _ok(resp)
    assert data is not None


def test_action_auth_key(client: httpx.Client):
    """Action: POST /api/v2/auth/key"""
    # Auth endpoints require BasicAuth, not API key
    ba_client = httpx.Client(
        base_url=BASE_URL,
        verify=False,
        auth=(AUTH_USER, AUTH_PASS),
        timeout=30,
    )
    resp = ba_client.post("/api/v2/auth/key", json={'descr': 'Test API key from tests', 'length_bytes': 16})
    data = _ok(resp)
    assert data is not None


def test_action_diagnostics_command_prompt(client: httpx.Client):
    """Action: POST /api/v2/diagnostics/command_prompt"""
    resp = client.post("/api/v2/diagnostics/command_prompt", json={'command': 'echo pfsense-mcp-test'})
    data = _ok(resp)
    assert data is not None


def test_action_diagnostics_ping(client: httpx.Client):
    """Action: POST /api/v2/diagnostics/ping"""
    resp = client.post("/api/v2/diagnostics/ping", json={'host': '127.0.0.1', 'count': 1})
    data = _ok(resp)
    assert data is not None


def test_action_graphql(client: httpx.Client):
    """Action: POST /api/v2/graphql"""
    resp = client.post("/api/v2/graphql", json={'query': '{ __schema { queryType { name } } }'})
    assert resp.status_code == 200, f"{resp.status_code}: {resp.text[:500]}"
    data = resp.json()
    assert data is not None


# SKIP /api/v2/services/acme/account_key/register: tested via custom test_action_acme_register_issue_renew

# SKIP /api/v2/services/acme/certificate/issue: tested via custom test_action_acme_register_issue_renew

# SKIP /api/v2/services/acme/certificate/renew: tested via custom test_action_acme_register_issue_renew

def test_action_services_wake_on_lan_send(client: httpx.Client):
    """Action: POST /api/v2/services/wake_on_lan/send"""
    resp = client.post("/api/v2/services/wake_on_lan/send", json={'interface': 'lan', 'mac_addr': '00:11:22:33:44:55'})
    data = _ok(resp)
    assert data is not None


def test_action_status_service(client: httpx.Client):
    """Action: POST /api/v2/status/service"""
    resp = client.post("/api/v2/status/service", json={'id': 0, 'action': 'restart'})
    data = _ok(resp)
    assert data is not None


def test_action_system_certificate_generate(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/generate"""
    # Generate a CA first
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for cert gen", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "Cert Gen CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco", "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    body = {'descr': 'Test Generated Cert', 'keytype': 'RSA', 'keylen': 2048, 'digest_alg': 'sha256', 'dn_commonname': 'gen-cert.test', 'lifetime': 365, 'type': 'server'}
    body["caref"] = ca["refid"]
    try:
        resp = client.post("/api/v2/system/certificate/generate", json=body)
        data = _ok(resp)
        client.delete("/api/v2/system/certificate", params={"id": data["id"]})
    finally:
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})


def test_action_system_certificate_pkcs12_export(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/pkcs12/export"""
    # Generate a CA and cert first
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for cert action", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "Cert Action CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco", "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    cert_resp = client.post("/api/v2/system/certificate/generate", json={
        "descr": "Cert for action", "caref": ca["refid"], "keytype": "RSA",
        "keylen": 2048, "digest_alg": "sha256", "dn_commonname": "action.test",
        "lifetime": 365, "type": "server",
    })
    cert = _ok(cert_resp)
    try:
        resp = client.post("/api/v2/system/certificate/pkcs12/export", json={"certref": cert["refid"]}, headers={"Accept": "application/octet-stream"})
        assert resp.status_code == 200, f"PKCS12 export {resp.status_code}: {resp.text[:200]}"
        assert len(resp.content) > 0, "PKCS12 export returned empty body"
    finally:
        client.delete("/api/v2/system/certificate", params={"id": cert["id"]})
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})


def test_action_system_certificate_renew(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/renew"""
    # Generate a CA and cert first
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for cert action", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "Cert Action CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco", "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    cert_resp = client.post("/api/v2/system/certificate/generate", json={
        "descr": "Cert for action", "caref": ca["refid"], "keytype": "RSA",
        "keylen": 2048, "digest_alg": "sha256", "dn_commonname": "action.test",
        "lifetime": 365, "type": "server",
    })
    cert = _ok(cert_resp)
    try:
        resp = client.post("/api/v2/system/certificate/renew", json={"certref": cert["refid"]})
        _ok(resp)
    finally:
        client.delete("/api/v2/system/certificate", params={"id": cert["id"]})
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})


def test_action_system_certificate_signing_request(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/signing_request"""
    resp = client.post("/api/v2/system/certificate/signing_request", json={'descr': 'Test CSR', 'keytype': 'RSA', 'keylen': 2048, 'digest_alg': 'sha256', 'dn_commonname': 'test-csr.example.com'})
    data = _ok(resp)
    assert data is not None
    data = resp.json().get('data', {})
    if data.get('id') is not None:
        client.delete("/api/v2/system/certificate", params={"id": data["id"]})


def test_action_system_certificate_signing_request_sign(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/signing_request/sign"""
    # Generate CA, create CSR, then sign it
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for CSR sign", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "CSR Sign CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco", "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    csr_resp = client.post("/api/v2/system/certificate/signing_request", json={
        "descr": "Test CSR to sign", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "csr-sign.test",
    })
    csr_data = _ok(csr_resp)
    try:
        resp = client.post("/api/v2/system/certificate/signing_request/sign", json={
            "descr": "Signed from CSR", "caref": ca["refid"],
            "csr": csr_data["csr"], "digest_alg": "sha256",
        })
        signed = _ok(resp)
    finally:
        client.delete("/api/v2/system/certificate", params={"id": csr_data["id"]})
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})


def test_action_system_certificate_authority_generate(client: httpx.Client):
    """Action: POST /api/v2/system/certificate_authority/generate"""
    resp = client.post("/api/v2/system/certificate_authority/generate", json={'descr': 'Test Generated CA', 'keytype': 'RSA', 'keylen': 2048, 'digest_alg': 'sha256', 'dn_commonname': 'Test Gen CA', 'dn_country': 'US', 'dn_state': 'California', 'dn_city': 'San Francisco', 'dn_organization': 'pfSense Test', 'dn_organizationalunit': 'Testing', 'lifetime': 3650})
    data = _ok(resp)
    assert data is not None
    data = resp.json().get('data', {})
    if data.get('id') is not None:
        client.delete("/api/v2/system/certificate_authority", params={"id": data["id"]})


def test_action_system_certificate_authority_renew(client: httpx.Client):
    """Action: POST /api/v2/system/certificate_authority/renew"""
    # Generate a CA first
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for renew test", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "Renew Test CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco", "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    try:
        resp = client.post("/api/v2/system/certificate_authority/renew", json={"caref": ca["refid"]})
        _ok(resp)
    finally:
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})


# SKIP /api/v2/system/restapi/settings/sync: HA sync endpoint times out without peer

def test_action_vpn_openvpn_client_export(client: httpx.Client):
    """Action + CRUD: /api/v2/vpn/openvpn/client_export (+config)"""
    # 1. Create CA
    ca_resp = client.post("/api/v2/system/certificate_authority/generate", json={
        "descr": "CA for OVPN export", "keytype": "RSA", "keylen": 2048,
        "digest_alg": "sha256", "dn_commonname": "OVPN Export CA", "lifetime": 3650,
        "dn_country": "US", "dn_state": "California", "dn_city": "San Francisco",
        "dn_organization": "pfSense Test", "dn_organizationalunit": "Testing",
    })
    ca = _ok(ca_resp)
    try:
        # 2. Create server certificate
        srv_cert_resp = client.post("/api/v2/system/certificate/generate", json={
            "descr": "OVPN server cert", "caref": ca["refid"], "keytype": "RSA",
            "keylen": 2048, "digest_alg": "sha256", "dn_commonname": "ovpn-server.test",
            "lifetime": 365, "type": "server",
        })
        srv_cert = _ok(srv_cert_resp)
        try:
            # 3. Create OpenVPN server (server_tls mode avoids auth issues)
            ovpn_resp = client.post("/api/v2/vpn/openvpn/server", json={
                "mode": "server_tls", "dev_mode": "tun", "protocol": "UDP4",
                "interface": "wan", "local_port": "11941",
                "caref": ca["refid"], "certref": srv_cert["refid"],
                "dh_length": "2048", "ecdh_curve": "prime256v1",
                "tunnel_network": "10.0.8.0/24",
                "description": "OVPN export test",
                "data_ciphers": ["AES-256-GCM"],
                "data_ciphers_fallback": "AES-256-GCM",
                "digest": "SHA256",
            })
            # server_tls mode may produce log output before JSON
            assert ovpn_resp.status_code == 200, f"OVPN server create {ovpn_resp.status_code}: {ovpn_resp.text[:500]}"
            text = ovpn_resp.text
            json_start = text.find("{")
            ovpn = json.loads(text[json_start:])["data"] if json_start > 0 else ovpn_resp.json()["data"]
            try:
                # 4. Create user certificate
                user_cert_resp = client.post("/api/v2/system/certificate/generate", json={
                    "descr": "OVPN user cert", "caref": ca["refid"], "keytype": "RSA",
                    "keylen": 2048, "digest_alg": "sha256", "dn_commonname": "ovpn-user.test",
                    "lifetime": 365, "type": "user",
                })
                user_cert = _ok(user_cert_resp)
                try:
                    # 5. Create export config
                    cfg_resp = client.post("/api/v2/vpn/openvpn/client_export/config", json={
                        "server": ovpn["vpnid"],
                        "pkcs11providers": [], "pkcs11id": "", "pass": "",
                        "proxyaddr": "", "proxyport": "", "useproxypass": "",
                        "proxyuser": "", "proxypass": "",
                    })
                    cfg = _ok(cfg_resp)
                    cfg_id = cfg.get("id")
                    try:
                        # 6. Export (the action under test)
                        export_resp = client.post("/api/v2/vpn/openvpn/client_export", json={
                            "id": cfg_id, "certref": user_cert["refid"],
                            "type": "confinline",
                        })
                        _ok(export_resp)
                    finally:
                        client.delete("/api/v2/vpn/openvpn/client_export/config",
                                      params={"id": cfg_id})
                finally:
                    client.delete("/api/v2/system/certificate", params={"id": user_cert["id"]})
            finally:
                client.delete("/api/v2/vpn/openvpn/server", params={"id": ovpn["id"]})
        finally:
            client.delete("/api/v2/system/certificate", params={"id": srv_cert["id"]})
    finally:
        client.delete("/api/v2/system/certificate_authority", params={"id": ca["id"]})

def test_action_acme_register_issue_renew(client: httpx.Client):
    """Action: ACME register + issue + renew (async, no external server needed)"""
    # 1. Create ACME account key
    acct_resp = client.post("/api/v2/services/acme/account_key", json={
        "name": "pft_acme_rir",
        "descr": "Test ACME key for register/issue/renew",
        "email": "test@example.com",
        "acmeserver": "letsencrypt-staging-2",
    })
    acct = _ok(acct_resp)
    try:
        # 2. Register account key (async  returns 200 with status=pending)
        reg_resp = client.post("/api/v2/services/acme/account_key/register", json={
            "name": "pft_acme_rir",
        })
        assert reg_resp.status_code == 200, f"Register {reg_resp.status_code}: {reg_resp.text[:500]}"
        reg_data = reg_resp.json()
        assert reg_data["code"] == 200
        assert reg_data["data"]["status"] in ("pending", "registered")

        # 3. Create ACME certificate with standalone domain verification
        cert_resp = client.post("/api/v2/services/acme/certificate", json={
            "name": "pft_acme_rir_cert",
            "descr": "Test ACME cert for issue/renew",
            "acmeaccount": "pft_acme_rir",
            "keylength": "2048",
            "a_domainlist": [
                {"name": "test.example.com", "method": "standalone", "status": "enable"}
            ],
        })
        cert = _ok(cert_resp)
        try:
            # 4. Issue certificate (async  returns 200 with status=pending)
            issue_resp = client.post("/api/v2/services/acme/certificate/issue", json={
                "certificate": "pft_acme_rir_cert",
            })
            assert issue_resp.status_code == 200, f"Issue {issue_resp.status_code}: {issue_resp.text[:500]}"
            issue_data = issue_resp.json()
            assert issue_data["code"] == 200
            assert issue_data["data"]["status"] in ("pending", "completed")

            # 5. Renew certificate (async  returns 200 with status=pending)
            renew_resp = client.post("/api/v2/services/acme/certificate/renew", json={
                "certificate": "pft_acme_rir_cert",
            })
            assert renew_resp.status_code == 200, f"Renew {renew_resp.status_code}: {renew_resp.text[:500]}"
            renew_data = renew_resp.json()
            assert renew_data["code"] == 200
            assert renew_data["data"]["status"] in ("pending", "completed")
        finally:
            client.delete("/api/v2/services/acme/certificate", params={"id": cert["id"]})
    finally:
        client.delete("/api/v2/services/acme/account_key", params={"id": acct["id"]})

def test_zz_action_diagnostics_reboot(client: httpx.Client):
    """Action: POST /api/v2/diagnostics/reboot"""
    resp = client.post("/api/v2/diagnostics/reboot", json={})
    data = _ok(resp)
    assert data is not None


def test_zzz_action_diagnostics_halt_system(client: httpx.Client):
    """Action: POST /api/v2/diagnostics/halt_system"""
    resp = client.post("/api/v2/diagnostics/halt_system", json={})
    data = _ok(resp)
    assert data is not None

