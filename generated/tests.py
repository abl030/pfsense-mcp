"""
Auto-generated integration tests for pfSense REST API v2.

Generated by: python -m generator
Tests every endpoint against a live pfSense VM.

DO NOT EDIT THIS FILE DIRECTLY.
Fix the generator instead, then re-run.
"""

from __future__ import annotations

import os
import time

import httpx
import pytest

BASE_URL = os.environ.get("PFSENSE_TEST_URL", "https://127.0.0.1:18443")
API_KEY = os.environ.get("PFSENSE_TEST_API_KEY", "")
AUTH_USER = os.environ.get("PFSENSE_TEST_USER", "admin")
AUTH_PASS = os.environ.get("PFSENSE_TEST_PASS", "pfsense")

# Pre-generated test certificates (self-signed, 10-year validity)
CA_CERT_PEM = "-----BEGIN CERTIFICATE-----\nMIIDMzCCAhugAwIBAgIUbtFPoQ0zYg1ScUJ7+FnklDgHgh8wDQYJKoZIhvcNAQEL\nBQAwKTEQMA4GA1UEAwwHVGVzdCBDQTEVMBMGA1UECgwMcGZTZW5zZSBUZXN0MB4X\nDTI2MDIwNzAxMjYyMloXDTM2MDIwNTAxMjYyMlowKTEQMA4GA1UEAwwHVGVzdCBD\nQTEVMBMGA1UECgwMcGZTZW5zZSBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\nMIIBCgKCAQEAs3inegnOteSWo/iRAV5YUZ7tx1pDni+cdDcNkDgPubrM9baB/EVP\nA1CqpV1F20YcHu9o2H/BS308cCwOxNFuarjsTzHgrH7WG9gwUvXfDPkJ08ivvWxS\n4WXsVqP6OQ7iOgJpDTx0ALyBLq2isW2/nn5Eubs9SL65pk8FBMe6cZ/JVRQ2KUwo\nHwKq+HR6qBhrLFeAFVBHB/NXjQHWT7Kkym9nPA8RMwvkXyQZj8vXL8gWwqFEY7dk\nx8hpJ10vnRjWz3afNeP9qRLBlIxdz0NlrbaZ/Xh/h+2pQX3i8S4cyTYDF56Cw98X\nPjWoOi45TlZ33cbh7YsgyODZcmr1WOeRSQIDAQABo1MwUTAdBgNVHQ4EFgQUNKKH\nIC1T0pAoUUXO2+TT488p45AwHwYDVR0jBBgwFoAUNKKHIC1T0pAoUUXO2+TT488p\n45AwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAonF1YEnW+vSp\njRxq+vB3foaHUkiEDP4ipDdknZgu19JKW+NSEvz9mAKU1zVnN621I1JURuDELBTN\nBa5oa1BnAQ3kzEtGr/yJZh477i15L/FBUvTjUQlnftKSJF22BD0YamALSsdHyJaS\nl6a8YdaFV2muzjk0aDFutMk1kESiUh02FY5dU8MTPcarGSqUFBxT9TqGYlf7TcEI\nA35EDCIbEzkqUofzzp70rXN1Z9TdR/rf74waSn4/tPhF5/Eosf0+hC/IRz1V+3+6\nbCIx8M+jzQZU8u92iAnZkp9rGgBZZnonZ6phI0WAR67UBSvD5939DGlqDiQjMsuX\nz+e3gqRxKQ==\n-----END CERTIFICATE-----"
CA_KEY_PEM = "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCzeKd6Cc615Jaj\n+JEBXlhRnu3HWkOeL5x0Nw2QOA+5usz1toH8RU8DUKqlXUXbRhwe72jYf8FLfTxw\nLA7E0W5quOxPMeCsftYb2DBS9d8M+QnTyK+9bFLhZexWo/o5DuI6AmkNPHQAvIEu\nraKxbb+efkS5uz1IvrmmTwUEx7pxn8lVFDYpTCgfAqr4dHqoGGssV4AVUEcH81eN\nAdZPsqTKb2c8DxEzC+RfJBmPy9cvyBbCoURjt2THyGknXS+dGNbPdp814/2pEsGU\njF3PQ2Wttpn9eH+H7alBfeLxLhzJNgMXnoLD3xc+Nag6LjlOVnfdxuHtiyDI4Nly\navVY55FJAgMBAAECggEAAWVrDsjRv1oqY9cqBZ6JcFpx/hmGf3izrmHD7L8gPDEm\n/rMEmtpNLY5B7ZcRVTiGknpepe8vKUUC+dprOP5qGKbHS9cW/jCJvjNgg4dfIgIz\n9d5Qo61v4vSrMddaZHmS//bcgK+w3//sv1i2ycuRReHfQKn4uulPl2rI9AsRDmji\nRWry7Dz5of17vvKe63N/sdmsDNo0RphucTBVnLw/MsDI5WXjMYqCILC/CBNhM3Ey\nemPUaZucUGc6AY+BMzF7XrYNaHL3IkN06dC8Iyn7h2v/gSSuknTa2zfUw5nBSlja\nm+wmFswXWf7OSsT1SV2o+ebs95nKdHQSIJJVMHAFaQKBgQD5P2hac7ivzr669lGk\nCdf+6d7ERpwInEOJBqahuUFfsZSVgxjPBVXSSb2CAF+4cVGn4Tbj5h3ZuIfUct7D\nf0wUfBG4dTdciAQ5+F4EWnVVeS1aHTyMy1VP+cvwHek4T0sxwFJLze99iiPv7IJl\nPy3N2pL0bzWI9kgIJal8YFCcRQKBgQC4VVSm+dUlUB+VExufxEljTBQw9SgAwoi0\nsE/sf2pbcRHk9mneYBLLmkat6Rig4j+S/WFFPWZdnD7JCG1NjgRhJr54iRXzR2yB\ncq5qPplTtJB7zxF+gk01LJHnuqfIOOc9vrCM2eTQTs/hhgjcWVUudWbgFxoQNcDy\nc8YyCSNLNQKBgQDGU8IBV1t56RSzSBSmZn7Mg+OSYmz+HPlQK06kGPj/4BnO7kXr\nVN95ONvmec2wwdqrrvUyWoUeHUtXrR+8h6pOEns3P24R3tkeF5cX97KtlIKV1fW8\nQn9b5/Ry2BofiFjY+aOCVhde2XDHFHadgaw8xNNyVJtQpEek0/MM2MbL0QKBgAyY\nWAZov7Wi+eV3vsV15gXQ5vhJaAhVQn4GJg/kzOGeojhg1e8J5X7f9cBgUvx7ORjU\nE1dl0J7I1ElsN/u6nnX87brSsxtCYBmgOmasDFH53n13MpzQTnI5r2aEDH7T1IkV\nhH67TLUnDXE9dVGJERbxkqvxKCi/Y4Wtf3dfxHeZAoGBAKivNGFeCgaoqwdvIP7I\nxr/D03OgdfPn2qlR1HqsZbBFncBcs8ZaqqJ8z4XtciwCJAXMqGbd2EGRB6qmLPYe\nfmXBZyQ+OJXbjaw1hYWo6UsNa4SnPSwYbZsoht3bgqM7YNoMur3xAgKTMpHK1LRv\nKExPKJsV0Kb6sQ6X2vFrnVBh\n-----END PRIVATE KEY-----"
CERT_PEM = "-----BEGIN CERTIFICATE-----\nMIIDKzCCAhOgAwIBAgIUGjPhTAHBo+rI0jwF4drOD1h07/EwDQYJKoZIhvcNAQEL\nBQAwKTEQMA4GA1UEAwwHVGVzdCBDQTEVMBMGA1UECgwMcGZTZW5zZSBUZXN0MB4X\nDTI2MDIwNzAxMjYyOFoXDTM2MDIwNTAxMjYyOFowMjEZMBcGA1UEAwwQdGVzdC5l\neGFtcGxlLmNvbTEVMBMGA1UECgwMcGZTZW5zZSBUZXN0MIIBIjANBgkqhkiG9w0B\nAQEFAAOCAQ8AMIIBCgKCAQEAsFHLy6MMYwtaV0SSr9nLOFbWlF9YZedINQV8E/z4\n26dJcBCHPLaEj8dI7jgNZnhdzoX52FG3zNs+Tw7NC8uYjFRC32gyx2nULn1T+lzC\ncPcU/wmSstgWXSUPUQkZSbua2ETH7IqKFeVMN3fCz/1eNmXR0Cjs16H7M7+qOeMH\nA/gMHCZhuyCEBsiF3uga6tg2P048CrQprmlccy3EXcDEFLYppCvycncpqVyneixL\nalV3ZLtULWetot3NMy/09bNpwDrzrzbq6BrEMnp0ANT8PpM19wVoxwWmdgkbeUk+\nIl9WirEFdTg9IUuEFworVbAkiaYNqISs85KdfmgkpOM+BwIDAQABo0IwQDAdBgNV\nHQ4EFgQUPkeP0fa/AoRDCCIjEDRCUxLu6AowHwYDVR0jBBgwFoAUNKKHIC1T0pAo\nUUXO2+TT488p45AwDQYJKoZIhvcNAQELBQADggEBAH3zwwnB/RfzmNBKm9dYf3EE\ngS3fIdRu7vOTJpRAhAxhjg92po2OyxLCINuRHQImXP3A4+Dxpvm57Gupzc8Ct098\nXyscFNebR/XrVPI11ggRhy3giVH61dS8OpkrcwRyVuTF/S11312e+ptsqpiAWh0M\nJsXqUCVjwW39FdcxBim++9LAt2XeiyaxqlJln0jN5jyLmSF90CV4NnFMOOdIMkwn\nuFouKAgxbb1q1mL1VE9c4fD9BXxqfldnkZqOG56331TVfhJ99dsIxh7aO9rk1txW\nRKgTO+dSPffND5e5lENE+BDKx9cUm2Vtc05J3vD7V4cyK8bmBzA6tt6uI/8qvsA=\n-----END CERTIFICATE-----"
CERT_KEY_PEM = "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCwUcvLowxjC1pX\nRJKv2cs4VtaUX1hl50g1BXwT/Pjbp0lwEIc8toSPx0juOA1meF3OhfnYUbfM2z5P\nDs0Ly5iMVELfaDLHadQufVP6XMJw9xT/CZKy2BZdJQ9RCRlJu5rYRMfsiooV5Uw3\nd8LP/V42ZdHQKOzXofszv6o54wcD+AwcJmG7IIQGyIXe6Brq2DY/TjwKtCmuaVxz\nLcRdwMQUtimkK/JydympXKd6LEtqVXdku1QtZ62i3c0zL/T1s2nAOvOvNuroGsQy\nenQA1Pw+kzX3BWjHBaZ2CRt5ST4iX1aKsQV1OD0hS4QXCitVsCSJpg2ohKzzkp1+\naCSk4z4HAgMBAAECggEABAZ3W23x/Z2H5vUgT4EZNBnmFTC7YRGEzae95kDrYixc\nBKxul0gSwlY03TIMuu763pj4FA8C3gY6p8MOkvsyFNtkRBsUtFu/UH5jo+lpNlCr\nEIrPPWOp2F+HuCcNMOiRB5NDvdaIgikgHSYP8v/1nif4lcLRbAzSd3h5MjrIxreM\nbc2wpu/tNgwnpcvGbhUqFBssMucvlXLeKxiP5pF7Un0+WjqC+tCJztOkryvmyE2g\njMEysclD1H7AYVqrusBmuxPW5AAb4Tv2vA4G2xm9n8BhpwpCGZdsa7ZYkb+s89Ec\nn0G/fCoRWk21p2U1N18C5QOMuxqxAFxb7YRYJszzCQKBgQDdSh6cpUgE9FeUbUkV\ntqbMjmSQKPpBEu2LF7u7x+OBPIEdFrCDMQuZHAc+MT0XFlO8jA4Pm1OoRFaI7RVZ\n8G9b/aORUg+xMKOl3o+bInY2FT/ddmp7J1J0dQDfMbU/f+jTCIzAhI094wJc3ScX\n336/nQkLRsoOdQB0gwBsodamKQKBgQDL+efd2FlP7/VJg4PGsJHGGRJ0vqtsj//c\nis1C0vCkoqtAfMtVP7wMT9SC1u+cjW13Bh6auWHL3MK31iLceymfB+73ZPBDuXz/\nlTv+hKqtYZbc1g7w9SJEqN41tFRsdMRnq18WcYAMCoQiY4R3B9lYJOqBiuvZt0mI\nvGRwYU9orwKBgQCpZSu5zewrnr/MJzxjGsbkn7vrfvLTDaI5b5mOTZ2iOKa9lbjZ\nNJokQoho21hga/79vlilKcoIbQexGYvWpW8ZhDfJ7n+ErC8Zsh1MLD1BeVLCPPuV\n+qvr6gUY1fxg95FKuqjEVrOoRDZyz/g1Fij4lUVvFGloV7hZeE7C2cBuwQKBgQCA\nZSWL4pSNmelXxf4cAqcwADY64I59fsM66vA7wRYTPAX6SNOhLMZNJa8KUQtxCyE9\ni8+V611g+uxi1dsJ2EkhvtewSIxoxQimxSSHmLDrBIP3LJMpH9TbTUTan1GJF5NO\nAnSPZxCIA9Ka5vPKDVnFfy9SLcU6PYJ/HL9IciiPJwKBgC93lXfdoyA5waYdBGYL\nVEaSfh3hxGd5sC+krUK7VXV/bCkGOX71AsiAY8Wo35yu3+24tnLaMVocgcFzjmXi\nhZu2Fa7IccV7iRh0wxoXD3BtjV37vzLq4C5yD5hgFgeNwF3LfrWVOWFAy2bjrA5+\nU1dtBhHADj/YuAIFAStvX2JE\n-----END PRIVATE KEY-----"


class RetryClient(httpx.Client):
    """httpx.Client that retries on 503 (dispatcher busy)."""
    def request(self, method, url, **kwargs):
        for attempt in range(6):
            resp = super().request(method, url, **kwargs)
            if resp.status_code != 503:
                return resp
            time.sleep(10 * (attempt + 1))
        return resp


@pytest.fixture(scope="session")
def client() -> httpx.Client:
    """Authenticated httpx client for the test VM."""
    if API_KEY:
        c = RetryClient(
            base_url=BASE_URL,
            headers={"X-API-Key": API_KEY},
            verify=False,
            timeout=30,
        )
    else:
        c = RetryClient(
            base_url=BASE_URL,
            auth=(AUTH_USER, AUTH_PASS),
            verify=False,
            timeout=30,
        )
    yield c
    c.close()


def _ok(resp: httpx.Response) -> dict:
    """Assert response is 200 and return data."""
    assert resp.status_code == 200, f"{resp.request.method} {resp.request.url} -> {resp.status_code}: {resp.text[:500]}"
    body = resp.json()
    assert body.get("code") == 200, f"API error: {body}"
    return body.get("data", body)


def _delete_with_retry(client: httpx.Client, path: str, obj_id, params: dict | None = None) -> None:
    """Delete a resource with retry for 503 (busy) and accept 404 (already gone)."""
    p = {"id": obj_id}
    if params:
        p.update(params)
    for _attempt in range(3):
        resp = client.delete(path, params=p)
        if resp.status_code != 503:
            break
        time.sleep(5)
    assert resp.status_code in (200, 404), f"Delete {path} id={obj_id} failed: {resp.text[:500]}"
# Total generated tests: 188

def test_crud_firewall_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/alias"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/alias",
        json={
        "name": "pft_firewall_a",
        "type": 'host',
        "address": ["10.99.99.1"],
        "descr": "Test created by generator",
        "detail": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/alias",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/aliases",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/alias",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/alias",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_one_to_one_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/one_to_one/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/one_to_one/mapping",
        json={
        "destination": "any",
        "external": "10.99.99.1",
        "interface": "wan",
        "source": "any",
        "descr": "Test created by generator",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nobinat": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/one_to_one/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/one_to_one/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_outbound_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/outbound/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/outbound/mapping",
        json={
        "destination": "any",
        "interface": "wan",
        "source": "any",
        "target": "127.0.0.1",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "nat_port": "443",
        "nonat": False,
        "nosync": False,
        "poolopts": 'round-robin',
        "protocol": "tcp",
        "source_hash_key": "test_firewall_nat_outbound_mapping",
        "source_port": "443",
        "static_nat_port": False,
        "target_subnet": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/outbound/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/outbound/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/outbound/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/outbound/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_port_forward(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/port_forward"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/port_forward",
        json={
        "destination": "any",
        "interface": "wan",
        "local_port": "8080",
        "protocol": "tcp",
        "source": "any",
        "target": "127.0.0.1",
        "associated_rule_id": "",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nordr": False,
        "nosync": False,
        "source_port": "443",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/port_forward",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/port_forwards",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/port_forward",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/port_forward",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_rule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/rule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/rule",
        json={
        "destination": "any",
        "interface": ["wan"],
        "ipprotocol": "inet",
        "source": "any",
        "type": 'pass',
        "descr": "Test created by generator",
        "destination_port": "80",
        "direction": 'any',
        "disabled": False,
        "floating": False,
        "icmptype": [],
        "log": False,
        "protocol": "tcp",
        "quick": False,
        "source_port": "443",
        "statetype": 'keep state',
        "tag": "test_firewall_rule",
        "tcp_flags_any": False,
        "tcp_flags_out_of": [],
        "tcp_flags_set": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/rule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/rules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/rule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/rule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_schedule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/schedule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/schedule",
        json={
        "name": "pft_firewall_s",
        "timerange": [{"month": "1,2,3", "day": "1,2,3", "hour": "0:00-23:59", "position": []}],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/schedule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/schedules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/schedule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/schedule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_schedule_time_range(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/schedule/time_range (needs: firewall/schedule)"""
    # Setup: create parent firewall/schedule
    p0_resp = client.post(
        "/api/v2/firewall/schedule",
        json={
        "name": 'pft_sched_tr',
        "timerange": [{'month': '1,2,3', 'day': '1,2,3', 'hour': '0:00-23:59', 'position': []}],
        "descr": 'Test schedule for time_range',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "month": [4, 5, 6],
                "day": [10, 11, 12],
                "hour": '8:00-17:00',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/schedule/time_range",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/schedule/time_range",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/schedule/time_range", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/schedule", p0_id)


def test_crud_firewall_traffic_shaper(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper",
        json={
        "bandwidth": 100,
        "bandwidthtype": "Mb",
        "interface": "wan",
        "scheduler": "HFSC",
        "enabled": False,
        "qlimit": 50,
        "queue": [],
        "tbrconfig": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shapers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_traffic_shaper_limiter(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": "droptail",
        "name": "pft_firewall_t",
        "sched": "wf2q+",
        "bandwidth": [{"bw": 100, "bwscale": "Mb", "schedule": "none"}],
        "buckets": 16,
        "delay": 1,
        "description": "test_firewall_traffic_shaper_limiter",
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "param_codel_interval": 1,
        "param_codel_target": 1,
        "param_fq_codel_flows": 1,
        "param_fq_codel_interval": 1,
        "param_fq_codel_limit": 1,
        "param_fq_codel_quantum": 1,
        "param_fq_codel_target": 1,
        "param_fq_pie_alpha": 1,
        "param_fq_pie_beta": 1,
        "param_fq_pie_flows": 1,
        "param_fq_pie_limit": 1,
        "param_fq_pie_max_burst": 1,
        "param_fq_pie_max_ecnth": 1,
        "param_fq_pie_quantum": 1,
        "param_fq_pie_target": 1,
        "param_fq_pie_tupdate": 1,
        "param_gred_max_p": 1,
        "param_gred_max_th": 1,
        "param_gred_min_th": 1,
        "param_gred_w_q": 1,
        "param_pie_alpha": 1,
        "param_pie_beta": 1,
        "param_pie_max_burst": 1,
        "param_pie_max_ecnth": 1,
        "param_pie_target": 1,
        "param_pie_tupdate": 1,
        "param_red_max_p": 1,
        "param_red_max_th": 1,
        "param_red_min_th": 1,
        "param_red_w_q": 1,
        "pie_capdrop": False,
        "pie_onoff": False,
        "pie_pderand": False,
        "pie_qdelay": False,
        "plr": 1.0,
        "qlimit": 50,
        "queue": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiter",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiters",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/traffic_shaper/limiter",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper/limiter",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_traffic_shaper_limiter_bandwidth(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter/bandwidth (needs: firewall/traffic_shaper/limiter)"""
    # Setup: create parent firewall/traffic_shaper/limiter
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": 'droptail',
        "name": 'pft_lim_bw',
        "sched": 'wf2q+',
        "bandwidth": [{'bw': 100, 'bwscale': 'Mb', 'schedule': 'none'}],
        "buckets": 16,
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "queue": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "bw": 50,
                "bwscale": 'Mb',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter/bandwidth", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter", p0_id)


def test_crud_firewall_traffic_shaper_limiter_queue(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter/queue (needs: firewall/traffic_shaper/limiter)"""
    # Setup: create parent firewall/traffic_shaper/limiter
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": 'droptail',
        "name": 'pft_lim_q',
        "sched": 'wf2q+',
        "bandwidth": [{'bw': 100, 'bwscale': 'Mb', 'schedule': 'none'}],
        "buckets": 16,
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "queue": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_limq',
                "aqm": 'droptail',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/limiter/queue",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/limiter/queue",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter/queue", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/limiter", p0_id)


def test_crud_firewall_traffic_shaper_queue(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/queue (needs: firewall/traffic_shaper)"""
    # Setup: create parent firewall/traffic_shaper
    p0_resp = client.post(
        "/api/v2/firewall/traffic_shaper",
        json={
        "bandwidth": 100,
        "bandwidthtype": 'Mb',
        "interface": 'wan',
        "scheduler": 'HFSC',
        "enabled": False,
        "qlimit": 50,
        "queue": [],
        "tbrconfig": 1,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_tsq',
                "qlimit": 50,
                "bandwidth": 100,
                "upperlimit_m2": '',
                "realtime_m2": '',
                "linkshare_m2": '10%',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/firewall/traffic_shaper/queue",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/firewall/traffic_shaper/queue",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/firewall/traffic_shaper/queue", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/firewall/traffic_shaper", p0_id)


def test_crud_firewall_virtual_ip(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/virtual_ip"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/virtual_ip",
        json={
        "carp_peer": "10.99.99.6",
        "interface": "wan",
        "mode": 'ipalias',
        "password": "Testpass123!Abc",
        "subnet": "10.99.99.100",
        "subnet_bits": 32,
        "vhid": 1,
        "advbase": 1,
        "advskew": 1,
        "carp_mode": 'mcast',
        "descr": "Test created by generator",
        "noexpand": False,
        "type": 'single',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/virtual_ip",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/virtual_ips",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/virtual_ip",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/virtual_ip",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/interface: interface CRUD can destabilize VM (em2 reserved for LAGG)

def test_crud_interface_bridge(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/bridge"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/bridge",
        json={
        "members": ["wan"],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/bridge",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/bridges",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/bridge",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/bridge",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_interface_gre(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/gre (chained)"""
    # CREATE
    body = {
            "if": 'wan',
            "remote_addr": '198.51.100.1',
            "tunnel_local_addr": '10.255.0.1',
            "tunnel_remote_addr": '10.255.0.2',
            "tunnel_remote_addr6": '',
        }
    create_resp = client.post(
        "/api/v2/interface/gre",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/gre",
            params={"id": obj_id},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/gre", obj_id)


def test_crud_interface_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/group",
        json={
        "ifname": "pf_test_interface_group",
        "descr": "Test created by generator",
        "members": ["wan"],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/group",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_interface_lagg(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/lagg (chained)"""
    # CREATE
    body = {
            "members": ['em2'],
            "proto": 'none',
            "descr": 'Test LAGG',
        }
    create_resp = client.post(
        "/api/v2/interface/lagg",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/lagg",
            params={"id": obj_id},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/lagg", obj_id)


def test_crud_interface_vlan(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/vlan (chained)"""
    # CREATE
    body = {
            "if": 'em0',
            "tag": 100,
            "pcp": 0,
            "descr": 'Test VLAN',
        }
    create_resp = client.post(
        "/api/v2/interface/vlan",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/vlan",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/vlan",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/interface/vlan", obj_id)


def test_crud_routing_gateway(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway"""
    # CREATE
    create_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "gateway": "10.0.2.1",
        "interface": "wan",
        "ipprotocol": "inet",
        "name": "pft_routing_ga",
        "action_disable": False,
        "alert_interval": 1000,
        "data_payload": 1,
        "descr": "Test created by generator",
        "disabled": False,
        "dpinger_dont_add_static_route": False,
        "force_down": False,
        "gw_down_kill_states": '',
        "interval": 500,
        "latencyhigh": 500,
        "latencylow": 200,
        "loss_interval": 2000,
        "losshigh": 20,
        "losslow": 10,
        "monitor": "10.99.99.50",
        "monitor_disable": False,
        "nonlocalgateway": False,
        "time_period": 60000,
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/routing/gateway",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/routing/gatewaies",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/routing/gateway",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/routing/gateway",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_routing_gateway_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway/group (needs: routing/gateway)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gg',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for gg',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_gw_group',
                "descr": 'Test gateway group',
                "priorities": [{'gateway': 'pft_gw_gg', 'tier': 1}],
            }
        create_resp = client.post(
            "/api/v2/routing/gateway/group",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/routing/gateway/group",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/routing/gateway/group",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/routing/gateway/group", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_routing_gateway_group_priority(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway/group/priority (needs: routing/gateway, routing/gateway, routing/gateway/group)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gp',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for gp',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent routing/gateway
    p1_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_gp2',
        "gateway": '10.0.2.99',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test GW 2 for priority',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent routing/gateway/group
    p2_resp = client.post(
        "/api/v2/routing/gateway/group",
        json={
        "name": 'pft_gw_grp_p',
        "descr": 'Test group for priority',
        "priorities": [{'gateway': 'pft_gw_gp', 'tier': 1}],
    },
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "gateway": 'pft_gw_gp2',
                        "tier": 2,
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/routing/gateway/group/priority",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/routing/gateway/group/priority",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/routing/gateway/group/priority", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/routing/gateway/group", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/routing/gateway", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_routing_static_route(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/static_route (needs: routing/gateway)"""
    # Setup: create parent routing/gateway
    p0_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "name": 'pft_gw_sr',
        "gateway": '10.0.2.1',
        "interface": 'wan',
        "ipprotocol": 'inet',
        "descr": 'Test gateway for sr',
        "latencylow": 200,
        "latencyhigh": 500,
        "losslow": 10,
        "losshigh": 20,
        "loss_interval": 2000,
        "time_period": 60000,
        "interval": 500,
        "alert_interval": 1000,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "network": '10.200.0.0/24',
                "descr": 'Test static route',
            }
        body["gateway"] = p0["name"]
        create_resp = client.post(
            "/api/v2/routing/static_route",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/routing/static_route",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/routing/static_route",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/routing/static_route", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/routing/gateway", p0_id)


def test_crud_services_acme_account_key(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/account_key (chained)"""
    # CREATE
    body = {
            "name": 'pft_acme_key',
            "descr": 'Test ACME key',
            "email": 'test@example.com',
            "acmeserver": 'letsencrypt-staging-2',
        }
    create_resp = client.post(
        "/api/v2/services/acme/account_key",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/acme/account_key",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/acme/account_key",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", obj_id)


def test_crud_services_acme_certificate(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate (needs: services/acme/account_key)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_crt',
        "descr": 'Test ACME key for cert',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_acme_cert',
                "descr": 'Test ACME cert',
                "keypaste": CERT_KEY_PEM,
                "a_domainlist": [{'name': 'test.example.com', 'method': 'standalone', 'status': 'enable'}],
            }
        body["acmeaccount"] = p0["name"]
        create_resp = client.post(
            "/api/v2/services/acme/certificate",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/acme/certificate",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/acme/certificate",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_acme_certificate_action(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate/action (needs: services/acme/account_key, services/acme/certificate)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_act',
        "descr": 'Test ACME key for action',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/acme/certificate
    p1_body = {
        "name": 'pft_acme_ca',
        "descr": 'Test ACME cert for action',
        "keypaste": CERT_KEY_PEM,
        "a_domainlist": [{'name': 'test3.example.com', 'method': 'standalone', 'status': 'enable'}],
    }
    p1_body["acmeaccount"] = p0["name"]
    p1_resp = client.post(
        "/api/v2/services/acme/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "command": 'echo test',
                    "method": 'shellcommand',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/acme/certificate/action",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/acme/certificate/action",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/acme/certificate/action", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_acme_certificate_domain(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/acme/certificate/domain (needs: services/acme/account_key, services/acme/certificate)"""
    # Setup: create parent services/acme/account_key
    p0_resp = client.post(
        "/api/v2/services/acme/account_key",
        json={
        "name": 'pft_acme_dom',
        "descr": 'Test ACME key for domain',
        "email": 'test@example.com',
        "acmeserver": 'letsencrypt-staging-2',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/acme/certificate
    p1_body = {
        "name": 'pft_acme_cd',
        "descr": 'Test ACME cert for domain',
        "keypaste": CERT_KEY_PEM,
        "a_domainlist": [{'name': 'test1.example.com', 'method': 'standalone', 'status': 'enable'}],
    }
    p1_body["acmeaccount"] = p0["name"]
    p1_resp = client.post(
        "/api/v2/services/acme/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "name": 'test2.example.com',
                    "method": 'standalone',
                    "status": 'enable',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/acme/certificate/domain",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/acme/certificate/domain",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/acme/certificate/domain", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/acme/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/acme/account_key", p0_id)


def test_crud_services_bind_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/access_list",
        json={
        "entries": [{"value": "10.0.0.0/8", "description": "test entry"}],
        "name": "pft_services_b",
        "description": "test_services_bind_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_access_list_entry(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/access_list/entry (needs: services/bind/access_list)"""
    # Setup: create parent services/bind/access_list
    p0_resp = client.post(
        "/api/v2/services/bind/access_list",
        json={
        "entries": [{'value': '10.0.0.0/8', 'description': 'test entry'}],
        "name": 'pft_bacl_en',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "value": '10.1.0.0/16',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/bind/access_list/entry",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/bind/access_list/entry",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/bind/access_list/entry", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/bind/access_list", p0_id)


def test_crud_services_bind_sync_remote_host(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/sync/remote_host"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/sync/remote_host",
        json={
        "ipaddress": "10.99.99.99",
        "password": "Testpass123!Abc",
        "syncport": "443",
        "syncprotocol": 'http',
        "username": "pfsense_test_user",
        "syncdestinenable": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/sync/remote_host",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/sync/remote_hosts",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/sync/remote_host",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_view(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/view"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/view",
        json={
        "name": "pft_services_b",
        "allow_recursion": [],
        "bind_custom_options": "test_services_bind_view",
        "descr": "Test created by generator",
        "match_clients": [],
        "recursion": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/view",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/views",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/view",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/view",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_zone(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/zone"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/zone",
        json={
        "baseip": "10.99.99.0",
        "forwarders": [],
        "mail": "test_services_bind_zone",
        "name": "pft_services_b",
        "nameserver": "10.99.99.99",
        "serial": 1,
        "allowquery": [],
        "allowtransfer": [],
        "allowupdate": [],
        "backupkeys": False,
        "custom": "test_services_bind_zone",
        "customzonerecords": "test_services_bind_zone",
        "description": "test_services_bind_zone",
        "disabled": False,
        "dnssec": False,
        "enable_updatepolicy": False,
        "expire": "test_services_bind_zone",
        "minimum": "test_services_bind_zone",
        "records": [],
        "refresh": "test_services_bind_zone",
        "regdhcpstatic": False,
        "retry": "test_services_bind_zone",
        "reversev4": False,
        "reversev6": False,
        "rpz": False,
        "slaveip": "test_services_bind_zone",
        "ttl": 1,
        "type": 'master',
        "updatepolicy": "test_services_bind_zone",
        "view": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/zone",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/zones",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/zone",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/zone",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_zone_record(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/zone/record (needs: services/bind/zone)"""
    # Setup: create parent services/bind/zone
    p0_resp = client.post(
        "/api/v2/services/bind/zone",
        json={
        "name": 'pftzrec.example.com',
        "nameserver": 'ns1.example.com',
        "mail": 'admin.example.com',
        "serial": 2024010101,
        "forwarders": [],
        "baseip": '10.99.99.0',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'testrec',
                "type": 'A',
                "rdata": '10.99.99.1',
                "priority": 0,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/bind/zone/record",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/bind/zone/record",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/bind/zone/record", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/bind/zone", p0_id)


def test_crud_services_cron_job(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/cron/job"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/cron/job",
        json={
        "command": "echo test",
        "hour": "0",
        "mday": "*",
        "minute": "0",
        "month": "*",
        "wday": "*",
        "who": "root",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/cron/job",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/cron/jobs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/cron/job",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dhcp_server: per-interface singleton, POST not supported

def test_crud_services_dhcp_server_address_pool(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/address_pool (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "range_from": '192.168.1.210',
            "range_to": '192.168.1.220',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/address_pool",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/address_pool",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/address_pool", obj_id, {"parent_id": 'lan'})


def test_crud_services_dhcp_server_custom_option(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/custom_option (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "number": 252,
            "type": 'text',
            "value": 'http://wpad.example.com/wpad.dat',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/custom_option",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/custom_option",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/custom_option", obj_id, {"parent_id": 'lan'})


def test_crud_services_dhcp_server_static_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dhcp_server/static_mapping (chained)"""
    # CREATE
    body = {
            "parent_id": 'lan',
            "mac": '00:11:22:33:44:55',
            "ipaddr": '192.168.1.250',
            "descr": 'Test static map',
        }
    create_resp = client.post(
        "/api/v2/services/dhcp_server/static_mapping",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dhcp_server/static_mapping",
            params={"id": obj_id, "parent_id": 'lan'},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dhcp_server/static_mapping",
            json={"id": obj_id, "parent_id": 'lan', "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/services/dhcp_server/static_mapping", obj_id, {"parent_id": 'lan'})


def test_crud_services_dns_forwarder_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_forwarder/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_forwarder/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": "10.99.99.2",
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_forwarder/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_forwarder/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_forwarder/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_forwarder/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_forwarder_host_override_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_forwarder/host_override/alias (needs: services/dns_forwarder/host_override)"""
    # Setup: create parent services/dns_forwarder/host_override
    p0_resp = client.post(
        "/api/v2/services/dns_forwarder/host_override",
        json={
        "domain": 'example.com',
        "host": 'pft-dnsfwd-al',
        "ip": '10.99.99.2',
        "aliases": [],
        "descr": 'Test host override for alias',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "host": 'testalias',
                "domain": 'alias.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_forwarder/host_override/alias",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_forwarder/host_override/alias",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_forwarder/host_override/alias", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_forwarder/host_override", p0_id)


def test_crud_services_dns_resolver_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/access_list",
        json={
        "action": 'allow',
        "name": "pft_services_d",
        "networks": [],
        "description": "test_services_dns_resolver_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_access_list_network(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/access_list/network (needs: services/dns_resolver/access_list)"""
    # Setup: create parent services/dns_resolver/access_list
    p0_resp = client.post(
        "/api/v2/services/dns_resolver/access_list",
        json={
        "action": 'allow',
        "name": 'pft_dnsacl_nw',
        "networks": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "network": '10.1.0.0',
                "mask": 16,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_resolver/access_list/network",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_resolver/access_list/network",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_resolver/access_list/network", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_resolver/access_list", p0_id)


def test_crud_services_dns_resolver_domain_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/domain_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/domain_override",
        json={
        "domain": "example.com",
        "ip": "10.99.99.2",
        "descr": "Test created by generator",
        "forward_tls_upstream": False,
        "tls_hostname": "test_services_dns_resolver_domain_override",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/domain_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/domain_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/domain_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/domain_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": ["10.99.99.2"],
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_host_override_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/host_override/alias (needs: services/dns_resolver/host_override)"""
    # Setup: create parent services/dns_resolver/host_override
    p0_resp = client.post(
        "/api/v2/services/dns_resolver/host_override",
        json={
        "domain": 'example.com',
        "host": 'pft-dnsres-al',
        "ip": ['10.99.99.2'],
        "aliases": [],
        "descr": 'Test host override for alias',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "host": 'testalias',
                "domain": 'alias.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/dns_resolver/host_override/alias",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/dns_resolver/host_override/alias",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/dns_resolver/host_override/alias", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/dns_resolver/host_override", p0_id)


# SKIP /api/v2/services/freeradius/client: freeradius routes need REST API v2.6+ (pfSense 2.8+)

# SKIP /api/v2/services/freeradius/interface: freeradius routes need REST API v2.6+ (pfSense 2.8+)

# SKIP /api/v2/services/freeradius/user: freeradius routes need REST API v2.6+ (pfSense 2.8+)

def test_crud_services_haproxy_backend(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "agent_port": "443",
        "name": "pft_services_h",
        "persist_cookie_name": "test_services_haproxy_backend",
        "acls": [],
        "actions": [],
        "advanced": "test_services_haproxy_backend",
        "advanced_backend": "test_services_haproxy_backend",
        "agent_checks": False,
        "agent_inter": 1,
        "balance": '',
        "balance_uridepth": 1,
        "balance_urilen": 1,
        "balance_uriwhole": False,
        "check_type": 'none',
        "checkinter": 1,
        "connection_timeout": 1,
        "cookie_attribute_secure": False,
        "email_level": '',
        "email_to": "test@example.com",
        "errorfiles": [],
        "haproxy_cookie_domains": [],
        "haproxy_cookie_dynamic_cookie_key": "test_services_haproxy_backend",
        "haproxy_cookie_maxidle": 1,
        "haproxy_cookie_maxlife": 1,
        "httpcheck_method": 'OPTIONS',
        "log_health_checks": False,
        "monitor_domain": "test_services_haproxy_backend",
        "monitor_httpversion": "test_services_haproxy_backend",
        "monitor_uri": "test_services_haproxy_backend",
        "monitor_username": "test_services_haproxy_backend",
        "persist_cookie_cachable": False,
        "persist_cookie_enabled": False,
        "persist_cookie_httponly": False,
        "persist_cookie_mode": 'passive',
        "persist_cookie_postonly": False,
        "persist_cookie_secure": False,
        "persist_stick_cookiename": "test_services_haproxy_backend",
        "persist_stick_expire": "test_services_haproxy_backend",
        "persist_stick_length": 1,
        "persist_stick_tablesize": "test_services_haproxy_backend",
        "persist_sticky_type": 'none',
        "retries": 1,
        "server_timeout": 1,
        "servers": [],
        "stats_admin": "test_services_haproxy_backend",
        "stats_desc": "test_services_haproxy_backend",
        "stats_enabled": False,
        "stats_node": "test_services_haproxy_backend",
        "stats_password": "test_services_haproxy_backend",
        "stats_realm": "test_services_haproxy_backend",
        "stats_refresh": 1,
        "stats_scope": [],
        "stats_uri": "test_services_haproxy_backend",
        "stats_username": "test_services_haproxy_backend",
        "strict_transport_security": 1,
        "transparent_clientip": False,
        "transparent_interface": "test_services_haproxy_backend",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/backend",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/backends",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/haproxy/backend",
            json={"id": obj_id, "advanced": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("advanced") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/backend",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_haproxy_backend_acl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/acl (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bacl',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bacl',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_bacl',
                "expression": 'host_starts_with',
                "value": 'test.example.com',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/haproxy/backend/acl",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/backend/acl",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/backend/acl",
                json={"id": obj_id, "parent_id": p0["id"], "value": "updated.example.com"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/acl", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


# SKIP /api/v2/services/haproxy/backend/action: acl field cannot be empty, requires ACL sibling chain

def test_crud_services_haproxy_backend_error_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/error_file (needs: services/haproxy/file, services/haproxy/backend)"""
    # Setup: create parent services/haproxy/file
    p0_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "name": 'pft_ha_efb',
        "content": 'PCFET0NUWVBFIGh0bWw+',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/backend
    p1_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bef',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bef',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "errorcode": 503,
                    "errorfile": 'pft_ha_efb',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/backend/error_file",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/backend/error_file",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/backend/error_file", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/file", p0_id)


def test_crud_services_haproxy_backend_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend/server (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_bsrv',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for bsrv',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_bsrv',
                "address": '10.99.99.50',
                "port": '8080',
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/services/haproxy/backend/server",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/backend/server",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/backend/server",
                json={"id": obj_id, "parent_id": p0["id"], "address": "10.99.99.51"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend/server", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/file"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "content": "test_services_haproxy_file",
        "name": "pft_haproxy",
        "type": 'luascript',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/file",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/files",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/file",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_haproxy_frontend(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend (needs: services/haproxy/backend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_fe',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for fe',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "name": 'pft_fe_chain',
                "type": 'http',
                "descr": 'Test frontend',
            }
        create_resp = client.post(
            "/api/v2/services/haproxy/frontend",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/services/haproxy/frontend",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/services/haproxy/frontend",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


def test_crud_services_haproxy_frontend_acl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/acl (needs: services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_facl',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for facl',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/frontend
    p1_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_acl',
        "type": 'http',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "name": 'pft_facl',
                    "expression": 'host_starts_with',
                    "value": 'test.example.com',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/frontend/acl",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/frontend/acl",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/services/haproxy/frontend/acl",
                    json={"id": obj_id, "parent_id": p1["id"], "value": "updated.example.com"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/acl", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


# SKIP /api/v2/services/haproxy/frontend/action: acl field cannot be empty, requires ACL sibling chain

def test_crud_services_haproxy_frontend_address(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/address (needs: services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/backend
    p0_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_faddr',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for faddr',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/frontend
    p1_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_addr',
        "type": 'http',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "extaddr": 'custom',
                    "extaddr_custom": '10.99.99.80:80',
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/services/haproxy/frontend/address",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/services/haproxy/frontend/address",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend/address", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/backend", p0_id)


# SKIP /api/v2/services/haproxy/frontend/certificate: chained test missing child_body

def test_crud_services_haproxy_frontend_error_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/frontend/error_file (needs: services/haproxy/file, services/haproxy/backend, services/haproxy/frontend)"""
    # Setup: create parent services/haproxy/file
    p0_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "name": 'pft_ha_eff',
        "content": 'PCFET0NUWVBFIGh0bWw+',
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent services/haproxy/backend
    p1_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "name": 'pft_be_fef',
        "agent_port": '0',
        "persist_cookie_name": 'SRVID',
        "descr": 'Test backend for fef',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent services/haproxy/frontend
    p2_resp = client.post(
        "/api/v2/services/haproxy/frontend",
        json={
        "name": 'pft_fe_ef',
        "type": 'http',
    },
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "errorcode": 503,
                        "errorfile": 'pft_ha_eff',
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/services/haproxy/frontend/error_file",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/services/haproxy/frontend/error_file",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/services/haproxy/frontend/error_file", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/services/haproxy/frontend", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/services/haproxy/backend", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/services/haproxy/file", p0_id)


# SKIP /api/v2/services/haproxy/settings/dns_resolver: server 500: parent model construction bug in REST API v2.4.3

# SKIP /api/v2/services/haproxy/settings/email_mailer: server 500: parent model construction bug in REST API v2.4.3

def test_crud_services_ntp_time_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/ntp/time_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/ntp/time_server",
        json={
        "timeserver": "10.99.99.99",
        "noselect": False,
        "prefer": False,
        "type": 'server',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/ntp/time_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/ntp/time_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/ntp/time_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_service_watchdog(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/service_watchdog"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/service_watchdog",
        json={
        "name": "sshd",
        "notify": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/service_watchdog",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/service_watchdogs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/service_watchdog",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_system_certificate(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/certificate (chained)"""
    # CREATE
    body = {
            "descr": 'Test Cert',
            "crt": CERT_PEM,
            "prv": CERT_KEY_PEM,
        }
    create_resp = client.post(
        "/api/v2/system/certificate",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/certificate",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/certificate",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/system/certificate", obj_id)


def test_crud_system_certificate_authority(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/certificate_authority (chained)"""
    # CREATE
    body = {
            "descr": 'Test CA',
            "crt": CA_CERT_PEM,
            "prv": CA_KEY_PEM,
        }
    create_resp = client.post(
        "/api/v2/system/certificate_authority",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/certificate_authority",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/certificate_authority",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", obj_id)


def test_crud_system_crl(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/crl (needs: system/certificate_authority)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for CRL',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "descr": 'Test CRL',
                "method": 'internal',
                "text": '',
            }
        body["caref"] = p0["refid"]
        create_resp = client.post(
            "/api/v2/system/crl",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/system/crl",
                params={"id": obj_id},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/system/crl", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


# SKIP /api/v2/system/crl/revoked_certificate: cert serial hex  PHP INT overflow (v2.4.3 bug, confirmed with imported PEM certs)

def test_crud_system_restapi_access_list_entry(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/restapi/access_list/entry"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/restapi/access_list/entry",
        json={
        "network": "10.99.99.0/24",
        "descr": "Test created by generator",
        "type": 'allow',
        "users": [],
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/restapi/access_list/entry",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/restapi/access_list/entries",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/restapi/access_list/entry",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/restapi/access_list/entry",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_system_tunable(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/tunable"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/tunable",
        json={
        "tunable": "test_system_tunable",
        "value": "1",
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/tunable",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/tunables",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/tunable",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/tunable",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user",
        json={
        "name": "pft_user",
        "password": "Testpass123!Abc",
        "authorizedkeys": "test_user",
        "cert": [],
        "descr": "Test created by generator",
        "disabled": False,
        "expires": "12/31/2030",
        "ipsecpsk": "test_user",
        "priv": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/users",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_auth_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/auth_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/auth_server",
        json={
        "host": "10.99.99.70",
        "ldap_bindpw": "test_user_auth_server",
        "ldap_port": "389",
        "ldap_scope": "one",
        "ldap_urltype": "Standard TCP",
        "name": "pft_user_auth_",
        "radius_nasip_attribute": "lan",
        "radius_secret": "test_user_auth_server",
        "type": "ldap",
        "ldap_allow_unauthenticated": False,
        "ldap_attr_group": "cn",
        "ldap_attr_groupobj": "posixGroup",
        "ldap_attr_member": "member",
        "ldap_attr_user": "uid",
        "ldap_authcn": "ou=people,dc=example,dc=com",
        "ldap_basedn": "dc=example,dc=com",
        "ldap_binddn": "test_user_auth_server",
        "ldap_caref": "test_user_auth_server",
        "ldap_extended_enabled": False,
        "ldap_extended_query": "test_user_auth_server",
        "ldap_nostrip_at": False,
        "ldap_pam_groupdn": "test_user_auth_server",
        "ldap_protver": 3,
        "ldap_rfc2307": False,
        "ldap_rfc2307_userdn": False,
        "ldap_timeout": 25,
        "ldap_utf8": False,
        "radius_acct_port": "1813",
        "radius_auth_port": "1812",
        "radius_protocol": 'MSCHAPv2',
        "radius_timeout": 5,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/auth_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/auth_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/auth_server",
            json={"id": obj_id, "ldap_attr_group": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("ldap_attr_group") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/auth_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/group",
        json={
        "name": "pft_user_group",
        "description": "test_user_group",
        "member": [],
        "priv": [],
        "scope": 'local',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/group",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_vpn_ipsec_phase1(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase1 (needs: system/certificate_authority, system/certificate)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for IPsec',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for IPsec',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "iketype": 'ikev2',
                    "mode": 'main',
                    "protocol": 'inet',
                    "interface": 'wan',
                    "remote_gateway": '10.99.99.20',
                    "authentication_method": 'pre_shared_key',
                    "myid_type": 'myaddress',
                    "myid_data": '',
                    "peerid_type": 'any',
                    "peerid_data": '',
                    "pre_shared_key": 'TestPSK123456789012345',
                    "descr": 'Test IPsec P1',
                    "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
                }
            body["caref"] = p0["refid"]
            body["certref"] = p1["refid"]
            create_resp = client.post(
                "/api/v2/vpn/ipsec/phase1",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/ipsec/phase1",
                    params={"id": obj_id},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/vpn/ipsec/phase1",
                    json={"id": obj_id, "descr": "Updated by test"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", obj_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase1_encryption(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase1/encryption (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P1enc',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P1enc',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.21',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for enc',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "encryption_algorithm_name": 'aes128gcm',
                        "encryption_algorithm_keylen": 128,
                        "hash_algorithm": 'sha256',
                        "dhgroup": 14,
                    }
                body["parent_id"] = p2["id"]
                create_resp = client.post(
                    "/api/v2/vpn/ipsec/phase1/encryption",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/vpn/ipsec/phase1/encryption",
                        params={"id": obj_id, "parent_id": p2["id"]},
                    )
                    _ok(get_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1/encryption", obj_id, {"parent_id": p2["id"]})
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase2(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase2 (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P2',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P2',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.22',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for P2',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    try:
        try:
            try:
                # CREATE
                body = {
                        "mode": 'tunnel',
                        "localid_type": 'network',
                        "localid_address": '10.0.0.0',
                        "localid_netbits": 24,
                        "natlocalid_address": '',
                        "natlocalid_netbits": 0,
                        "remoteid_type": 'network',
                        "remoteid_address": '10.200.0.0',
                        "remoteid_netbits": 24,
                        "descr": 'Test IPsec P2',
                        "encryption_algorithm_option": [{'name': 'aes', 'keylen': 256}],
                        "hash_algorithm_option": ['hmac_sha256'],
                    }
                body["ikeid"] = p2["ikeid"]
                create_resp = client.post(
                    "/api/v2/vpn/ipsec/phase2",
                    json=body,
                )
                data = _ok(create_resp)
                obj_id = data.get("id")
                assert obj_id is not None, f"No id in create response: {data}"

                try:
                    # GET (singular)
                    get_resp = client.get(
                        "/api/v2/vpn/ipsec/phase2",
                        params={"id": obj_id},
                    )
                    _ok(get_resp)

                    # UPDATE
                    update_resp = client.patch(
                        "/api/v2/vpn/ipsec/phase2",
                        json={"id": obj_id, "descr": "Updated by test"},
                    )
                    _ok(update_resp)

                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2", obj_id)
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_ipsec_phase2_encryption(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/ipsec/phase2/encryption (needs: system/certificate_authority, system/certificate, vpn/ipsec/phase1, vpn/ipsec/phase2)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for P2enc',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for P2enc',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    # Setup: create parent vpn/ipsec/phase1
    p2_body = {
        "iketype": 'ikev2',
        "mode": 'main',
        "protocol": 'inet',
        "interface": 'wan',
        "remote_gateway": '10.99.99.23',
        "authentication_method": 'pre_shared_key',
        "myid_type": 'myaddress',
        "myid_data": '',
        "peerid_type": 'any',
        "peerid_data": '',
        "pre_shared_key": 'TestPSK123456789012345',
        "descr": 'Test P1 for P2enc',
        "encryption": [{'encryption_algorithm_name': 'aes', 'encryption_algorithm_keylen': 256, 'hash_algorithm': 'sha256', 'dhgroup': 14}],
    }
    p2_body["caref"] = p0["refid"]
    p2_body["certref"] = p1["refid"]
    p2_resp = client.post(
        "/api/v2/vpn/ipsec/phase1",
        json=p2_body,
    )
    p2 = _ok(p2_resp)
    p2_id = p2.get("id")
    assert p2_id is not None, f"No id in parent response: {p2}"

    # Setup: create parent vpn/ipsec/phase2
    p3_body = {
        "mode": 'tunnel',
        "localid_type": 'network',
        "localid_address": '10.0.0.0',
        "localid_netbits": 24,
        "natlocalid_address": '',
        "natlocalid_netbits": 0,
        "remoteid_type": 'network',
        "remoteid_address": '10.200.0.0',
        "remoteid_netbits": 24,
        "descr": 'Test P2 for enc',
        "encryption_algorithm_option": [{'name': 'aes', 'keylen': 256}],
        "hash_algorithm_option": ['hmac_sha256'],
    }
    p3_body["ikeid"] = p2["ikeid"]
    p3_resp = client.post(
        "/api/v2/vpn/ipsec/phase2",
        json=p3_body,
    )
    p3 = _ok(p3_resp)
    p3_id = p3.get("id")
    assert p3_id is not None, f"No id in parent response: {p3}"

    try:
        try:
            try:
                try:
                    # CREATE
                    body = {
                            "name": 'aes128gcm',
                            "keylen": 128,
                        }
                    body["parent_id"] = p3["id"]
                    create_resp = client.post(
                        "/api/v2/vpn/ipsec/phase2/encryption",
                        json=body,
                    )
                    data = _ok(create_resp)
                    obj_id = data.get("id")
                    assert obj_id is not None, f"No id in create response: {data}"

                    try:
                        # GET (singular)
                        get_resp = client.get(
                            "/api/v2/vpn/ipsec/phase2/encryption",
                            params={"id": obj_id, "parent_id": p3["id"]},
                        )
                        _ok(get_resp)

                    finally:
                        _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2/encryption", obj_id, {"parent_id": p3["id"]})
                finally:
                    _delete_with_retry(client, "/api/v2/vpn/ipsec/phase2", p3_id)
            finally:
                _delete_with_retry(client, "/api/v2/vpn/ipsec/phase1", p2_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_openvpn_client(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/client (needs: system/certificate_authority)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for OVPN cli',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "mode": 'p2p_tls',
                "dev_mode": 'tun',
                "protocol": 'UDP4',
                "interface": 'wan',
                "server_addr": '10.99.99.30',
                "server_port": '1194',
                "proxy_user": '',
                "proxy_passwd": '',
                "tls_type": 'auth',
                "data_ciphers": ['AES-256-GCM'],
                "data_ciphers_fallback": 'AES-256-GCM',
                "digest": 'SHA256',
                "description": 'Test OVPN client',
            }
        body["caref"] = p0["refid"]
        create_resp = client.post(
            "/api/v2/vpn/openvpn/client",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/openvpn/client",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/vpn/openvpn/client",
                json={"id": obj_id, "description": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/openvpn/client", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


# SKIP /api/v2/vpn/openvpn/client_export/config: complex 5-step chain: CA+cert+OVPN server+user cert (deferred)

def test_crud_vpn_openvpn_cso(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/cso (chained)"""
    # CREATE
    body = {
            "common_name": 'pft_ovpn_cso',
            "description": 'Test CSO',
        }
    create_resp = client.post(
        "/api/v2/vpn/openvpn/cso",
        json=body,
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/vpn/openvpn/cso",
            params={"id": obj_id},
        )
        _ok(get_resp)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/vpn/openvpn/cso",
            json={"id": obj_id, "description": "Updated by test"},
        )
        _ok(update_resp)

    finally:
        _delete_with_retry(client, "/api/v2/vpn/openvpn/cso", obj_id)


def test_crud_vpn_openvpn_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/openvpn/server (needs: system/certificate_authority, system/certificate)"""
    # Setup: create parent system/certificate_authority
    p0_resp = client.post(
        "/api/v2/system/certificate_authority",
        json={
        "descr": 'Test CA for OVPN srv',
        "crt": CA_CERT_PEM,
        "prv": CA_KEY_PEM,
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent system/certificate
    p1_body = {
        "descr": 'Test Cert for OVPN srv',
        "crt": CERT_PEM,
        "prv": CERT_KEY_PEM,
    }
    p1_body["caref"] = p0["refid"]
    p1_resp = client.post(
        "/api/v2/system/certificate",
        json=p1_body,
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "mode": 'p2p_tls',
                    "dev_mode": 'tun',
                    "protocol": 'UDP4',
                    "interface": 'wan',
                    "tls_type": 'auth',
                    "dh_length": '2048',
                    "ecdh_curve": 'prime256v1',
                    "data_ciphers": ['AES-256-GCM'],
                    "data_ciphers_fallback": 'AES-256-GCM',
                    "digest": 'SHA256',
                    "description": 'Test OVPN server',
                    "serverbridge_interface": '',
                    "serverbridge_dhcp_start": '',
                    "serverbridge_dhcp_end": '',
                }
            body["caref"] = p0["refid"]
            body["certref"] = p1["refid"]
            create_resp = client.post(
                "/api/v2/vpn/openvpn/server",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/openvpn/server",
                    params={"id": obj_id},
                )
                _ok(get_resp)

                # UPDATE
                update_resp = client.patch(
                    "/api/v2/vpn/openvpn/server",
                    json={"id": obj_id, "description": "Updated by test"},
                )
                _ok(update_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/openvpn/server", obj_id)
        finally:
            _delete_with_retry(client, "/api/v2/system/certificate", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/system/certificate_authority", p0_id)


def test_crud_vpn_wireguard_peer(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/peer (needs: vpn/wireguard/tunnel)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_peer',
        "listenport": '51821',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "publickey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
                "descr": 'Test WG peer',
            }
        body["tun"] = p0["name"]
        create_resp = client.post(
            "/api/v2/vpn/wireguard/peer",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/wireguard/peer",
                params={"id": obj_id},
            )
            _ok(get_resp)

            # UPDATE
            update_resp = client.patch(
                "/api/v2/vpn/wireguard/peer",
                json={"id": obj_id, "descr": "Updated by test"},
            )
            _ok(update_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/peer", obj_id)
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_crud_vpn_wireguard_peer_allowed_ip(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/peer/allowed_ip (needs: vpn/wireguard/tunnel, vpn/wireguard/peer)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_aip',
        "listenport": '51823',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    # Setup: create parent vpn/wireguard/peer
    p1_resp = client.post(
        "/api/v2/vpn/wireguard/peer",
        json={
        "tun": 'pft_tun_aip',
        "publickey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "descr": 'Test WG peer for allowed_ip',
    },
    )
    p1 = _ok(p1_resp)
    p1_id = p1.get("id")
    assert p1_id is not None, f"No id in parent response: {p1}"

    try:
        try:
            # CREATE
            body = {
                    "address": '10.200.0.0',
                    "mask": 24,
                }
            body["parent_id"] = p1["id"]
            create_resp = client.post(
                "/api/v2/vpn/wireguard/peer/allowed_ip",
                json=body,
            )
            data = _ok(create_resp)
            obj_id = data.get("id")
            assert obj_id is not None, f"No id in create response: {data}"

            try:
                # GET (singular)
                get_resp = client.get(
                    "/api/v2/vpn/wireguard/peer/allowed_ip",
                    params={"id": obj_id, "parent_id": p1["id"]},
                )
                _ok(get_resp)

            finally:
                _delete_with_retry(client, "/api/v2/vpn/wireguard/peer/allowed_ip", obj_id, {"parent_id": p1["id"]})
        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/peer", p1_id)
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_crud_vpn_wireguard_tunnel(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/tunnel"""
    # CREATE
    create_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "privatekey": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=",
        "addresses": [],
        "descr": "Test created by generator",
        "enabled": False,
        "listenport": "51820",
        "mtu": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/vpn/wireguard/tunnel",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/vpn/wireguard/tunnels",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/vpn/wireguard/tunnel",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/vpn/wireguard/tunnel",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_vpn_wireguard_tunnel_address(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/tunnel/address (needs: vpn/wireguard/tunnel)"""
    # Setup: create parent vpn/wireguard/tunnel
    p0_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "name": 'pft_tun_addr',
        "listenport": '51822',
        "privatekey": 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=',
        "addresses": [],
    },
    )
    p0 = _ok(p0_resp)
    p0_id = p0.get("id")
    assert p0_id is not None, f"No id in parent response: {p0}"

    try:
        # CREATE
        body = {
                "address": '10.100.0.1',
                "mask": 24,
            }
        body["parent_id"] = p0["id"]
        create_resp = client.post(
            "/api/v2/vpn/wireguard/tunnel/address",
            json=body,
        )
        data = _ok(create_resp)
        obj_id = data.get("id")
        assert obj_id is not None, f"No id in create response: {data}"

        try:
            # GET (singular)
            get_resp = client.get(
                "/api/v2/vpn/wireguard/tunnel/address",
                params={"id": obj_id, "parent_id": p0["id"]},
            )
            _ok(get_resp)

        finally:
            _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel/address", obj_id, {"parent_id": p0["id"]})
    finally:
        _delete_with_retry(client, "/api/v2/vpn/wireguard/tunnel", p0_id)


def test_settings_firewall_advanced_settings(client: httpx.Client):
    """Settings read: /api/v2/firewall/advanced_settings"""
    # GET current settings
    resp = client.get("/api/v2/firewall/advanced_settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_acme_settings(client: httpx.Client):
    """Settings read: /api/v2/services/acme/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/acme/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_sync_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/sync/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/sync/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_dns_resolver_settings(client: httpx.Client):
    """Settings read: /api/v2/services/dns_resolver/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/dns_resolver/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_haproxy_settings(client: httpx.Client):
    """Settings read: /api/v2/services/haproxy/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/haproxy/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_ntp_settings(client: httpx.Client):
    """Settings read: /api/v2/services/ntp/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/ntp/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_status_logs_settings(client: httpx.Client):
    """Settings read: /api/v2/status/logs/settings"""
    # GET current settings
    resp = client.get("/api/v2/status/logs/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_restapi_settings(client: httpx.Client):
    """Settings read: /api/v2/system/restapi/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/restapi/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_webgui_settings(client: httpx.Client):
    """Settings read: /api/v2/system/webgui/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/webgui/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_vpn_wireguard_settings(client: httpx.Client):
    """Settings read: /api/v2/vpn/wireguard/settings"""
    # GET current settings
    resp = client.get("/api/v2/vpn/wireguard/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_read_auth_keys(client: httpx.Client):
    """Read-only: /api/v2/auth/keys"""
    resp = client.get("/api/v2/auth/keys")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table"""
    resp = client.get("/api/v2/diagnostics/arp_table")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table_entry(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table/entry"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/arp_table/entry", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revision(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revision"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/config_history/revision", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revisions(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revisions"""
    resp = client.get("/api/v2/diagnostics/config_history/revisions")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/table"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/table", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


# SKIP /api/v2/diagnostics/tables: phantom plural route (spec-only, not registered on server)

def test_read_firewall_aliases(client: httpx.Client):
    """Read-only: /api/v2/firewall/aliases"""
    resp = client.get("/api/v2/firewall/aliases")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_one_to_one_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/one_to_one/mappings"""
    resp = client.get("/api/v2/firewall/nat/one_to_one/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_outbound_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/outbound/mappings"""
    resp = client.get("/api/v2/firewall/nat/outbound/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_port_forwards(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/port_forwards"""
    resp = client.get("/api/v2/firewall/nat/port_forwards")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_rules(client: httpx.Client):
    """Read-only: /api/v2/firewall/rules"""
    resp = client.get("/api/v2/firewall/rules")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/firewall/schedule/time_ranges: phantom plural route (spec-only, not registered on server)

def test_read_firewall_schedules(client: httpx.Client):
    """Read-only: /api/v2/firewall/schedules"""
    resp = client.get("/api/v2/firewall/schedules")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_state(client: httpx.Client):
    """Read-only: /api/v2/firewall/state"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/firewall/state", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_firewall_states(client: httpx.Client):
    """Read-only: /api/v2/firewall/states"""
    resp = client.get("/api/v2/firewall/states")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/firewall/traffic_shaper/limiter/bandwidths: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/firewall/traffic_shaper/limiter/queues: phantom plural route (spec-only, not registered on server)

def test_read_firewall_traffic_shaper_limiters(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shaper/limiters"""
    resp = client.get("/api/v2/firewall/traffic_shaper/limiters", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/firewall/traffic_shaper/queues: phantom plural route (spec-only, not registered on server)

def test_read_firewall_traffic_shapers(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shapers"""
    resp = client.get("/api/v2/firewall/traffic_shapers")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_virtual_ips(client: httpx.Client):
    """Read-only: /api/v2/firewall/virtual_ips"""
    resp = client.get("/api/v2/firewall/virtual_ips")
    data = _ok(resp)
    assert data is not None


def test_read_interface_available_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interface/available_interfaces"""
    resp = client.get("/api/v2/interface/available_interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_bridges(client: httpx.Client):
    """Read-only: /api/v2/interface/bridges"""
    resp = client.get("/api/v2/interface/bridges", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_gres(client: httpx.Client):
    """Read-only: /api/v2/interface/gres"""
    resp = client.get("/api/v2/interface/gres")
    data = _ok(resp)
    assert data is not None


def test_read_interface_groups(client: httpx.Client):
    """Read-only: /api/v2/interface/groups"""
    resp = client.get("/api/v2/interface/groups")
    data = _ok(resp)
    assert data is not None


def test_read_interface_laggs(client: httpx.Client):
    """Read-only: /api/v2/interface/laggs"""
    resp = client.get("/api/v2/interface/laggs")
    data = _ok(resp)
    assert data is not None


def test_read_interface_vlans(client: httpx.Client):
    """Read-only: /api/v2/interface/vlans"""
    resp = client.get("/api/v2/interface/vlans")
    data = _ok(resp)
    assert data is not None


def test_read_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interfaces"""
    resp = client.get("/api/v2/interfaces")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/routing/gateway/group/priorities: phantom plural route (spec-only, not registered on server)

def test_read_routing_gateway_groups(client: httpx.Client):
    """Read-only: /api/v2/routing/gateway/groups"""
    resp = client.get("/api/v2/routing/gateway/groups")
    data = _ok(resp)
    assert data is not None


def test_read_routing_gateways(client: httpx.Client):
    """Read-only: /api/v2/routing/gateways"""
    resp = client.get("/api/v2/routing/gateways")
    data = _ok(resp)
    assert data is not None


def test_read_routing_static_routes(client: httpx.Client):
    """Read-only: /api/v2/routing/static_routes"""
    resp = client.get("/api/v2/routing/static_routes")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_account_key_registrations(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_key/registrations"""
    resp = client.get("/api/v2/services/acme/account_key/registrations", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_account_keys(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_keys"""
    resp = client.get("/api/v2/services/acme/account_keys")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_certificate_issuances(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/issuances"""
    resp = client.get("/api/v2/services/acme/certificate/issuances", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificate_renewals(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/renewals"""
    resp = client.get("/api/v2/services/acme/certificate/renewals", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificates(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificates"""
    resp = client.get("/api/v2/services/acme/certificates")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/bind/access_list/entries: phantom plural route (spec-only, not registered on server)

def test_read_services_bind_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/bind/access_lists"""
    resp = client.get("/api/v2/services/bind/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_sync_remote_hosts(client: httpx.Client):
    """Read-only: /api/v2/services/bind/sync/remote_hosts"""
    resp = client.get("/api/v2/services/bind/sync/remote_hosts")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_views(client: httpx.Client):
    """Read-only: /api/v2/services/bind/views"""
    resp = client.get("/api/v2/services/bind/views")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_zones(client: httpx.Client):
    """Read-only: /api/v2/services/bind/zones"""
    resp = client.get("/api/v2/services/bind/zones")
    data = _ok(resp)
    assert data is not None


def test_read_services_cron_jobs(client: httpx.Client):
    """Read-only: /api/v2/services/cron/jobs"""
    resp = client.get("/api/v2/services/cron/jobs")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dhcp_server/address_pools: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/dhcp_server/custom_options: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/dhcp_server/static_mappings: phantom plural route (spec-only, not registered on server)

def test_read_services_dhcp_servers(client: httpx.Client):
    """Read-only: /api/v2/services/dhcp_servers"""
    resp = client.get("/api/v2/services/dhcp_servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/services/dns_forwarder/host_override/aliases: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_forwarder_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_forwarder/host_overrides"""
    resp = client.get("/api/v2/services/dns_forwarder/host_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dns_resolver/access_list/networks: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_resolver_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/access_lists"""
    resp = client.get("/api/v2/services/dns_resolver/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_dns_resolver_domain_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/domain_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/domain_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dns_resolver/host_override/aliases: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_resolver_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/host_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/host_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/freeradius/clients: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/freeradius/interfaces: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/freeradius/users: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/acls: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/actions: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/errorfiles: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/servers: phantom plural route (spec-only, not registered on server)

def test_read_services_haproxy_backends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/backends"""
    resp = client.get("/api/v2/services/haproxy/backends")
    data = _ok(resp)
    assert data is not None


def test_read_services_haproxy_files(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/files"""
    resp = client.get("/api/v2/services/haproxy/files")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/haproxy/frontend/acls: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/actions: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/addresses: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/certificates: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/error_files: phantom plural route (spec-only, not registered on server)

def test_read_services_haproxy_frontends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/frontends"""
    resp = client.get("/api/v2/services/haproxy/frontends")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/haproxy/settings/dns_resolvers: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/settings/email_mailers: phantom plural route (spec-only, not registered on server)

def test_read_services_ntp_time_servers(client: httpx.Client):
    """Read-only: /api/v2/services/ntp/time_servers"""
    resp = client.get("/api/v2/services/ntp/time_servers")
    data = _ok(resp)
    assert data is not None


def test_read_services_service_watchdogs(client: httpx.Client):
    """Read-only: /api/v2/services/service_watchdogs"""
    resp = client.get("/api/v2/services/service_watchdogs")
    data = _ok(resp)
    assert data is not None


def test_read_status_dhcp_server_leases(client: httpx.Client):
    """Read-only: /api/v2/status/dhcp_server/leases"""
    resp = client.get("/api/v2/status/dhcp_server/leases")
    data = _ok(resp)
    assert data is not None


def test_read_status_gateways(client: httpx.Client):
    """Read-only: /api/v2/status/gateways"""
    resp = client.get("/api/v2/status/gateways", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_interfaces(client: httpx.Client):
    """Read-only: /api/v2/status/interfaces"""
    resp = client.get("/api/v2/status/interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/ipsec/child_sa: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/ipsec/child_sas: phantom plural route (spec-only, not registered on server)

def test_read_status_ipsec_sas(client: httpx.Client):
    """Read-only: /api/v2/status/ipsec/sas"""
    resp = client.get("/api/v2/status/ipsec/sas", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/logs/auth: phantom plural route (spec-only, not registered on server)

def test_read_status_logs_dhcp(client: httpx.Client):
    """Read-only: /api/v2/status/logs/dhcp"""
    resp = client.get("/api/v2/status/logs/dhcp", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_logs_firewall(client: httpx.Client):
    """Read-only: /api/v2/status/logs/firewall"""
    resp = client.get("/api/v2/status/logs/firewall", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/logs/openvpn: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/logs/packages/restapi: phantom plural route (spec-only, not registered on server)

def test_read_status_logs_system(client: httpx.Client):
    """Read-only: /api/v2/status/logs/system"""
    resp = client.get("/api/v2/status/logs/system", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/clients"""
    resp = client.get("/api/v2/status/openvpn/clients", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/openvpn/server/connection: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/connections: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/route: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/routes: phantom plural route (spec-only, not registered on server)

def test_read_status_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/servers"""
    resp = client.get("/api/v2/status/openvpn/servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_services(client: httpx.Client):
    """Read-only: /api/v2/status/services"""
    resp = client.get("/api/v2/status/services", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_system(client: httpx.Client):
    """Read-only: /api/v2/status/system"""
    resp = client.get("/api/v2/status/system")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificate_authorities(client: httpx.Client):
    """Read-only: /api/v2/system/certificate_authorities"""
    resp = client.get("/api/v2/system/certificate_authorities")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificates(client: httpx.Client):
    """Read-only: /api/v2/system/certificates"""
    resp = client.get("/api/v2/system/certificates")
    data = _ok(resp)
    assert data is not None


def test_read_system_crls(client: httpx.Client):
    """Read-only: /api/v2/system/crls"""
    resp = client.get("/api/v2/system/crls")
    data = _ok(resp)
    assert data is not None


def test_read_system_package_available(client: httpx.Client):
    """Read-only: /api/v2/system/package/available"""
    resp = client.get("/api/v2/system/package/available", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_system_packages(client: httpx.Client):
    """Read-only: /api/v2/system/packages"""
    resp = client.get("/api/v2/system/packages")
    data = _ok(resp)
    assert data is not None


def test_read_system_restapi_access_list(client: httpx.Client):
    """Read-only: /api/v2/system/restapi/access_list"""
    resp = client.get("/api/v2/system/restapi/access_list")
    data = _ok(resp)
    assert data is not None


def test_read_system_tunables(client: httpx.Client):
    """Read-only: /api/v2/system/tunables"""
    resp = client.get("/api/v2/system/tunables")
    data = _ok(resp)
    assert data is not None


def test_read_system_version(client: httpx.Client):
    """Read-only: /api/v2/system/version"""
    resp = client.get("/api/v2/system/version")
    data = _ok(resp)
    assert data is not None


def test_read_user_auth_servers(client: httpx.Client):
    """Read-only: /api/v2/user/auth_servers"""
    resp = client.get("/api/v2/user/auth_servers")
    data = _ok(resp)
    assert data is not None


def test_read_user_groups(client: httpx.Client):
    """Read-only: /api/v2/user/groups"""
    resp = client.get("/api/v2/user/groups")
    data = _ok(resp)
    assert data is not None


def test_read_users(client: httpx.Client):
    """Read-only: /api/v2/users"""
    resp = client.get("/api/v2/users")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/ipsec/phase1/encryptions: phantom plural route (spec-only, not registered on server)

def test_read_vpn_ipsec_phase1s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase1s"""
    resp = client.get("/api/v2/vpn/ipsec/phase1s")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/ipsec/phase2/encryptions: phantom plural route (spec-only, not registered on server)

def test_read_vpn_ipsec_phase2s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase2s"""
    resp = client.get("/api/v2/vpn/ipsec/phase2s")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/openvpn/client_export/configs: phantom plural route (spec-only, not registered on server)

def test_read_vpn_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/clients"""
    resp = client.get("/api/v2/vpn/openvpn/clients")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_csos(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/csos"""
    resp = client.get("/api/v2/vpn/openvpn/csos")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/servers"""
    resp = client.get("/api/v2/vpn/openvpn/servers")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/wireguard/peer/allowed_ips: phantom plural route (spec-only, not registered on server)

def test_read_vpn_wireguard_peers(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/peers"""
    resp = client.get("/api/v2/vpn/wireguard/peers")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/wireguard/tunnel/addresses: phantom plural route (spec-only, not registered on server)

def test_read_vpn_wireguard_tunnels(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/tunnels"""
    resp = client.get("/api/v2/vpn/wireguard/tunnels")
    data = _ok(resp)
    assert data is not None


def test_apply_firewall_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/apply"""
    resp = client.get("/api/v2/firewall/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_firewall_virtual_ip_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/virtual_ip/apply"""
    resp = client.get("/api/v2/firewall/virtual_ip/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_interface_apply(client: httpx.Client):
    """Apply status: /api/v2/interface/apply"""
    resp = client.get("/api/v2/interface/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_routing_apply(client: httpx.Client):
    """Apply status: /api/v2/routing/apply"""
    resp = client.get("/api/v2/routing/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dhcp_server_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dhcp_server/apply"""
    resp = client.get("/api/v2/services/dhcp_server/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_forwarder_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_forwarder/apply"""
    resp = client.get("/api/v2/services/dns_forwarder/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_resolver_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_resolver/apply"""
    resp = client.get("/api/v2/services/dns_resolver/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_haproxy_apply(client: httpx.Client):
    """Apply status: /api/v2/services/haproxy/apply"""
    resp = client.get("/api/v2/services/haproxy/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_ipsec_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/ipsec/apply"""
    resp = client.get("/api/v2/vpn/ipsec/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_wireguard_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/wireguard/apply"""
    resp = client.get("/api/v2/vpn/wireguard/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_singleton_firewall_nat_outbound_mode(client: httpx.Client):
    """Singleton roundtrip: /api/v2/firewall/nat/outbound/mode"""
    # GET current value
    resp = client.get("/api/v2/firewall/nat/outbound/mode")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("mode")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/firewall/nat/outbound/mode",
        json={'mode': 'hybrid'},
    )
    patched = _ok(patch_resp)
    assert patched.get("mode") == 'hybrid'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/firewall/nat/outbound/mode")
    verify = _ok(verify_resp)
    assert verify.get("mode") == 'hybrid'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/firewall/nat/outbound/mode", json={"mode": original_value})


def test_singleton_firewall_states_size(client: httpx.Client):
    """Singleton roundtrip: /api/v2/firewall/states/size"""
    # GET current value
    resp = client.get("/api/v2/firewall/states/size")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("maximumstates")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/firewall/states/size",
        json={'maximumstates': 500000},
    )
    patched = _ok(patch_resp)
    assert patched.get("maximumstates") == 500000

    # GET to verify persistence
    verify_resp = client.get("/api/v2/firewall/states/size")
    verify = _ok(verify_resp)
    assert verify.get("maximumstates") == 500000

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/firewall/states/size", json={"maximumstates": original_value})


def test_singleton_routing_gateway_default(client: httpx.Client):
    """Singleton roundtrip: /api/v2/routing/gateway/default"""
    # GET current value
    resp = client.get("/api/v2/routing/gateway/default")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("defaultgw4")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/routing/gateway/default",
        json={'defaultgw4': ''},
    )
    patched = _ok(patch_resp)
    assert patched.get("defaultgw4") == ''

    # GET to verify persistence
    verify_resp = client.get("/api/v2/routing/gateway/default")
    verify = _ok(verify_resp)
    assert verify.get("defaultgw4") == ''

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/routing/gateway/default", json={"defaultgw4": original_value})


def test_singleton_services_dhcp_relay(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/dhcp_relay"""
    # GET current value
    resp = client.get("/api/v2/services/dhcp_relay")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("enable")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/dhcp_relay",
        json={'enable': False, 'server': ['10.0.2.1']},
    )
    patched = _ok(patch_resp)
    assert patched.get("enable") == False

    # GET to verify persistence
    verify_resp = client.get("/api/v2/services/dhcp_relay")
    verify = _ok(verify_resp)
    assert verify.get("enable") == False

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/services/dhcp_relay", json={"enable": original_value, "server": ['10.0.2.1']})


def test_singleton_services_dhcp_server_backend(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/dhcp_server/backend"""
    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/dhcp_server/backend",
        json={'dhcpbackend': 'kea'},
    )
    patched = _ok(patch_resp)
    assert patched.get("dhcpbackend") == 'kea'

    # Restore original value
    client.patch(
        "/api/v2/services/dhcp_server/backend",
        json={'dhcpbackend': 'isc'},
    )


def test_singleton_services_ssh(client: httpx.Client):
    """Singleton roundtrip: /api/v2/services/ssh"""
    # GET current value
    resp = client.get("/api/v2/services/ssh")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("port")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/services/ssh",
        json={'port': '2222'},
    )
    patched = _ok(patch_resp)
    assert patched.get("port") == '2222'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/services/ssh")
    verify = _ok(verify_resp)
    assert verify.get("port") == '2222'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/services/ssh", json={"port": original_value})


def test_singleton_status_carp(client: httpx.Client):
    """Singleton roundtrip: /api/v2/status/carp"""
    # GET current value
    resp = client.get("/api/v2/status/carp")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("maintenance_mode")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/status/carp",
        json={'maintenance_mode': True, 'enable': True},
    )
    patched = _ok(patch_resp)
    assert patched.get("maintenance_mode") == True

    # GET to verify persistence
    verify_resp = client.get("/api/v2/status/carp")
    verify = _ok(verify_resp)
    assert verify.get("maintenance_mode") == True

    # Restore original value
    client.patch(
        "/api/v2/status/carp",
        json={'maintenance_mode': False, 'enable': True},
    )


def test_singleton_system_console(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/console"""
    # GET current value
    resp = client.get("/api/v2/system/console")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("passwd_protect_console")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/console",
        json={'passwd_protect_console': True},
    )
    patched = _ok(patch_resp)
    assert patched.get("passwd_protect_console") == True

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/console")
    verify = _ok(verify_resp)
    assert verify.get("passwd_protect_console") == True

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/console", json={"passwd_protect_console": original_value})


def test_singleton_system_dns(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/dns"""
    # GET current value
    resp = client.get("/api/v2/system/dns")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("dnsallowoverride")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/dns",
        json={'dnsallowoverride': False},
    )
    patched = _ok(patch_resp)
    assert patched.get("dnsallowoverride") == False

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/dns")
    verify = _ok(verify_resp)
    assert verify.get("dnsallowoverride") == False

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/dns", json={"dnsallowoverride": original_value})


def test_singleton_system_hostname(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/hostname"""
    # GET current value
    resp = client.get("/api/v2/system/hostname")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("hostname")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/hostname",
        json={'hostname': 'pfttest', 'domain': 'home.arpa'},
    )
    patched = _ok(patch_resp)
    assert patched.get("hostname") == 'pfttest'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/hostname")
    verify = _ok(verify_resp)
    assert verify.get("hostname") == 'pfttest'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/hostname", json={"hostname": original_value, "domain": 'home.arpa'})


def test_singleton_system_notifications_email_settings(client: httpx.Client):
    """Singleton roundtrip: /api/v2/system/notifications/email_settings"""
    # GET current value
    resp = client.get("/api/v2/system/notifications/email_settings")
    original = _ok(resp)
    assert isinstance(original, dict)
    original_value = original.get("ipaddress")

    # PATCH with test value
    patch_resp = client.patch(
        "/api/v2/system/notifications/email_settings",
        json={'ipaddress': '127.0.0.1', 'username': 'test', 'password': 'test'},
    )
    patched = _ok(patch_resp)
    assert patched.get("ipaddress") == '127.0.0.1'

    # GET to verify persistence
    verify_resp = client.get("/api/v2/system/notifications/email_settings")
    verify = _ok(verify_resp)
    assert verify.get("ipaddress") == '127.0.0.1'

    # Restore original value
    if original_value is not None:
        client.patch("/api/v2/system/notifications/email_settings", json={"ipaddress": original_value, "username": 'test', "password": 'test'})


# SKIP /api/v2/system/restapi/version: PATCH triggers API version change (destructive)

# SKIP /api/v2/system/timezone: nginx 404 on REST API v2.4.3 (needs v2.6+ / pfSense 2.8+)

def test_action_auth_jwt(client: httpx.Client):
    """Action: POST /api/v2/auth/jwt"""
    # Auth endpoints require BasicAuth, not API key
    ba_client = httpx.Client(
        base_url=BASE_URL,
        verify=False,
        auth=(AUTH_USER, AUTH_PASS),
        timeout=30,
    )
    resp = ba_client.post("/api/v2/auth/jwt", json={})
    data = _ok(resp)
    assert data is not None


def test_action_auth_key(client: httpx.Client):
    """Action: POST /api/v2/auth/key"""
    # Auth endpoints require BasicAuth, not API key
    ba_client = httpx.Client(
        base_url=BASE_URL,
        verify=False,
        auth=(AUTH_USER, AUTH_PASS),
        timeout=30,
    )
    resp = ba_client.post("/api/v2/auth/key", json={'descr': 'Test API key from tests', 'length_bytes': 16})
    data = _ok(resp)
    assert data is not None


def test_action_diagnostics_command_prompt(client: httpx.Client):
    """Action: POST /api/v2/diagnostics/command_prompt"""
    resp = client.post("/api/v2/diagnostics/command_prompt", json={'command': 'echo pfsense-mcp-test'})
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/diagnostics/ping: version-gated to REST API v2.7.0+, not available on CE 2.7.2

def test_action_graphql(client: httpx.Client):
    """Action: POST /api/v2/graphql"""
    resp = client.post("/api/v2/graphql", json={'query': '{ __schema { queryType { name } } }'})
    assert resp.status_code == 200, f"{resp.status_code}: {resp.text[:500]}"
    data = resp.json()
    assert data is not None


# SKIP /api/v2/services/acme/account_key/register: needs real ACME server for registration

# SKIP /api/v2/services/acme/certificate/issue: requires real ACME server

# SKIP /api/v2/services/acme/certificate/renew: requires real ACME server

# SKIP /api/v2/services/wake_on_lan/send: requires real MAC address on LAN

def test_action_status_service(client: httpx.Client):
    """Action: POST /api/v2/status/service"""
    resp = client.post("/api/v2/status/service", json={'id': 0, 'action': 'restart'})
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/system/certificate/generate: depends on CA generate (broken in v2.4.3)

# SKIP /api/v2/system/certificate/pkcs12/export: depends on generated cert (broken in v2.4.3)

# SKIP /api/v2/system/certificate/renew: depends on cert generate (broken in v2.4.3)

def test_action_system_certificate_signing_request(client: httpx.Client):
    """Action: POST /api/v2/system/certificate/signing_request"""
    resp = client.post("/api/v2/system/certificate/signing_request", json={'descr': 'Test CSR', 'keytype': 'RSA', 'keylen': 2048, 'digest_alg': 'sha256', 'dn_commonname': 'test-csr.example.com'})
    data = _ok(resp)
    assert data is not None
    data = resp.json().get('data', {})
    if data.get('id') is not None:
        client.delete("/api/v2/system/certificate", params={"id": data["id"]})


# SKIP /api/v2/system/certificate/signing_request/sign: depends on CA generate (broken in v2.4.3)

# SKIP /api/v2/system/certificate_authority/generate: server 500: failed for unknown reason (REST API v2.4.3 bug)

# SKIP /api/v2/system/certificate_authority/renew: depends on CA generate (broken in v2.4.3)

# SKIP /api/v2/system/restapi/settings/sync: HA sync endpoint times out without peer

# SKIP /api/v2/vpn/openvpn/client_export: requires functioning OpenVPN server
