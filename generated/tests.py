"""
Auto-generated integration tests for pfSense REST API v2.

Generated by: python -m generator
Tests every endpoint against a live pfSense VM.

DO NOT EDIT THIS FILE DIRECTLY.
Fix the generator instead, then re-run.
"""

from __future__ import annotations

import os
import time

import httpx
import pytest

BASE_URL = os.environ.get("PFSENSE_TEST_URL", "https://127.0.0.1:18443")
API_KEY = os.environ.get("PFSENSE_TEST_API_KEY", "")
AUTH_USER = os.environ.get("PFSENSE_TEST_USER", "admin")
AUTH_PASS = os.environ.get("PFSENSE_TEST_PASS", "pfsense")


@pytest.fixture(scope="session")
def client() -> httpx.Client:
    """Authenticated httpx client for the test VM."""
    if API_KEY:
        c = httpx.Client(
            base_url=BASE_URL,
            headers={"X-API-Key": API_KEY},
            verify=False,
            timeout=30,
        )
    else:
        c = httpx.Client(
            base_url=BASE_URL,
            auth=(AUTH_USER, AUTH_PASS),
            verify=False,
            timeout=30,
        )
    yield c
    c.close()


def _ok(resp: httpx.Response) -> dict:
    """Assert response is 200 and return data."""
    assert resp.status_code == 200, f"{resp.request.method} {resp.request.url} -> {resp.status_code}: {resp.text[:500]}"
    body = resp.json()
    assert body.get("code") == 200, f"API error: {body}"
    return body.get("data", body)
# Total generated tests: 128

def test_crud_firewall_alias(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/alias"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/alias",
        json={
        "name": "pft_firewall_a",
        "type": 'host',
        "address": ["10.99.99.1"],
        "descr": "Test created by generator",
        "detail": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/alias",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/aliases",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/alias",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/alias",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_one_to_one_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/one_to_one/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/one_to_one/mapping",
        json={
        "destination": "any",
        "external": "10.99.99.1",
        "interface": "wan",
        "source": "any",
        "descr": "Test created by generator",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nobinat": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/one_to_one/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/one_to_one/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/one_to_one/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_outbound_mapping(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/outbound/mapping"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/outbound/mapping",
        json={
        "destination": "any",
        "interface": "wan",
        "source": "any",
        "target": "127.0.0.1",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "nat_port": "443",
        "nonat": False,
        "nosync": False,
        "poolopts": 'round-robin',
        "protocol": "tcp",
        "source_hash_key": "test_firewall_nat_outbound_mapping",
        "source_port": "443",
        "static_nat_port": False,
        "target_subnet": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/outbound/mapping",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/outbound/mappings",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/outbound/mapping",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/outbound/mapping",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_nat_port_forward(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/nat/port_forward"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/nat/port_forward",
        json={
        "destination": "any",
        "interface": "wan",
        "local_port": "8080",
        "protocol": "tcp",
        "source": "any",
        "target": "127.0.0.1",
        "associated_rule_id": "",
        "descr": "Test created by generator",
        "destination_port": "80",
        "disabled": False,
        "ipprotocol": "inet",
        "natreflection": 'enable',
        "nordr": False,
        "nosync": False,
        "source_port": "443",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/nat/port_forward",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/nat/port_forwards",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/nat/port_forward",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/nat/port_forward",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_rule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/rule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/rule",
        json={
        "destination": "any",
        "interface": ["wan"],
        "ipprotocol": "inet",
        "source": "any",
        "type": 'pass',
        "descr": "Test created by generator",
        "destination_port": "80",
        "direction": 'any',
        "disabled": False,
        "floating": False,
        "icmptype": [],
        "log": False,
        "protocol": "tcp",
        "quick": False,
        "source_port": "443",
        "statetype": 'keep state',
        "tag": "test_firewall_rule",
        "tcp_flags_any": False,
        "tcp_flags_out_of": [],
        "tcp_flags_set": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/rule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/rules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/rule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/rule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_schedule(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/schedule"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/schedule",
        json={
        "name": "pft_firewall_s",
        "timerange": [{"month": "1,2,3", "day": "1,2,3", "hour": "0:00-23:59", "position": []}],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/schedule",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/schedules",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/schedule",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/schedule",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/firewall/schedule/time_range: requires parent_id (needs parent resource first)

def test_crud_firewall_traffic_shaper(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper",
        json={
        "bandwidth": 100,
        "bandwidthtype": "Mb",
        "interface": "wan",
        "scheduler": "HFSC",
        "enabled": False,
        "qlimit": 50,
        "queue": [],
        "tbrconfig": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shapers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_firewall_traffic_shaper_limiter(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/traffic_shaper/limiter"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/traffic_shaper/limiter",
        json={
        "aqm": "droptail",
        "name": "pft_firewall_t",
        "sched": "wf2q+",
        "bandwidth": [{"bw": 100, "bwscale": "Mb", "schedule": "none"}],
        "buckets": 16,
        "delay": 1,
        "description": "test_firewall_traffic_shaper_limiter",
        "ecn": False,
        "enabled": False,
        "mask": 'none',
        "maskbits": 1,
        "maskbitsv6": 1,
        "param_codel_interval": 1,
        "param_codel_target": 1,
        "param_fq_codel_flows": 1,
        "param_fq_codel_interval": 1,
        "param_fq_codel_limit": 1,
        "param_fq_codel_quantum": 1,
        "param_fq_codel_target": 1,
        "param_fq_pie_alpha": 1,
        "param_fq_pie_beta": 1,
        "param_fq_pie_flows": 1,
        "param_fq_pie_limit": 1,
        "param_fq_pie_max_burst": 1,
        "param_fq_pie_max_ecnth": 1,
        "param_fq_pie_quantum": 1,
        "param_fq_pie_target": 1,
        "param_fq_pie_tupdate": 1,
        "param_gred_max_p": 1,
        "param_gred_max_th": 1,
        "param_gred_min_th": 1,
        "param_gred_w_q": 1,
        "param_pie_alpha": 1,
        "param_pie_beta": 1,
        "param_pie_max_burst": 1,
        "param_pie_max_ecnth": 1,
        "param_pie_target": 1,
        "param_pie_tupdate": 1,
        "param_red_max_p": 1,
        "param_red_max_th": 1,
        "param_red_min_th": 1,
        "param_red_w_q": 1,
        "pie_capdrop": False,
        "pie_onoff": False,
        "pie_pderand": False,
        "pie_qdelay": False,
        "plr": 1.0,
        "qlimit": 50,
        "queue": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiter",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/traffic_shaper/limiters",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/traffic_shaper/limiter",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/traffic_shaper/limiter",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/firewall/traffic_shaper/limiter/bandwidth: requires parent_id (needs parent resource first)

# SKIP /api/v2/firewall/traffic_shaper/limiter/queue: requires parent_id (needs parent resource first)

# SKIP /api/v2/firewall/traffic_shaper/queue: requires parent_id (needs parent resource first)

def test_crud_firewall_virtual_ip(client: httpx.Client):
    """CRUD lifecycle: /api/v2/firewall/virtual_ip"""
    # CREATE
    create_resp = client.post(
        "/api/v2/firewall/virtual_ip",
        json={
        "carp_peer": "10.99.99.6",
        "interface": "wan",
        "mode": 'ipalias',
        "password": "Testpass123!Abc",
        "subnet": "10.99.99.100",
        "subnet_bits": 32,
        "vhid": 1,
        "advbase": 1,
        "advskew": 1,
        "carp_mode": 'mcast',
        "descr": "Test created by generator",
        "noexpand": False,
        "type": 'single',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/firewall/virtual_ip",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/firewall/virtual_ips",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/firewall/virtual_ip",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/firewall/virtual_ip",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/interface: requires available physical interface

def test_crud_interface_bridge(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/bridge"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/bridge",
        json={
        "members": ["wan"],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/bridge",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/bridges",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/bridge",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/bridge",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/interface/gre: requires specific tunnel config

def test_crud_interface_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/interface/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/interface/group",
        json={
        "ifname": "pf_test_interface_group",
        "descr": "Test created by generator",
        "members": ["wan"],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/interface/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/interface/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/interface/group",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/interface/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/interface/lagg: requires multiple physical interfaces

# SKIP /api/v2/interface/vlan: requires valid parent interface

def test_crud_routing_gateway(client: httpx.Client):
    """CRUD lifecycle: /api/v2/routing/gateway"""
    # CREATE
    create_resp = client.post(
        "/api/v2/routing/gateway",
        json={
        "gateway": "10.0.2.1",
        "interface": "wan",
        "ipprotocol": "inet",
        "name": "pft_routing_ga",
        "action_disable": False,
        "alert_interval": 1000,
        "data_payload": 1,
        "descr": "Test created by generator",
        "disabled": False,
        "dpinger_dont_add_static_route": False,
        "force_down": False,
        "gw_down_kill_states": '',
        "interval": 500,
        "latencyhigh": 500,
        "latencylow": 200,
        "loss_interval": 2000,
        "losshigh": 20,
        "losslow": 10,
        "monitor": "10.99.99.50",
        "monitor_disable": False,
        "nonlocalgateway": False,
        "time_period": 60000,
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/routing/gateway",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/routing/gatewaies",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/routing/gateway",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/routing/gateway",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/routing/gateway/group: requires existing gateways with valid tiers

# SKIP /api/v2/routing/gateway/group/priority: requires parent_id (needs parent resource first)

# SKIP /api/v2/routing/static_route: requires existing gateway object

# SKIP /api/v2/services/acme/account_key: requires valid X509 private key

# SKIP /api/v2/services/acme/certificate: requires existing ACME account key

# SKIP /api/v2/services/acme/certificate/action: requires parent_id (needs parent resource first)

# SKIP /api/v2/services/acme/certificate/domain: requires parent_id (needs parent resource first)

def test_crud_services_bind_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/access_list",
        json={
        "entries": [{"value": "10.0.0.0/8", "description": "test entry"}],
        "name": "pft_services_b",
        "description": "test_services_bind_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/bind/access_list/entry: requires parent_id (needs parent resource first)

def test_crud_services_bind_sync_remote_host(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/sync/remote_host"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/sync/remote_host",
        json={
        "ipaddress": "10.99.99.99",
        "password": "Testpass123!Abc",
        "syncport": "443",
        "syncprotocol": 'http',
        "username": "pfsense_test_user",
        "syncdestinenable": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/sync/remote_host",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/sync/remote_hosts",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/sync/remote_host",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_view(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/view"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/view",
        json={
        "name": "pft_services_b",
        "allow_recursion": [],
        "bind_custom_options": "test_services_bind_view",
        "descr": "Test created by generator",
        "match_clients": [],
        "recursion": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/view",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/views",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/view",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/view",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_bind_zone(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/bind/zone"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/bind/zone",
        json={
        "baseip": "10.99.99.0",
        "forwarders": [],
        "mail": "test_services_bind_zone",
        "name": "pft_services_b",
        "nameserver": "10.99.99.99",
        "serial": 1,
        "allowquery": [],
        "allowtransfer": [],
        "allowupdate": [],
        "backupkeys": False,
        "custom": "test_services_bind_zone",
        "customzonerecords": "test_services_bind_zone",
        "description": "test_services_bind_zone",
        "disabled": False,
        "dnssec": False,
        "enable_updatepolicy": False,
        "expire": "test_services_bind_zone",
        "minimum": "test_services_bind_zone",
        "records": [],
        "refresh": "test_services_bind_zone",
        "regdhcpstatic": False,
        "retry": "test_services_bind_zone",
        "reversev4": False,
        "reversev6": False,
        "rpz": False,
        "slaveip": "test_services_bind_zone",
        "ttl": 1,
        "type": 'master',
        "updatepolicy": "test_services_bind_zone",
        "view": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/bind/zone",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/bind/zones",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/bind/zone",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/bind/zone",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/bind/zone/record: requires parent_id (needs parent resource first)

def test_crud_services_cron_job(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/cron/job"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/cron/job",
        json={
        "command": "echo test",
        "hour": "0",
        "mday": "*",
        "minute": "0",
        "month": "*",
        "wday": "*",
        "who": "root",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/cron/job",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/cron/jobs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/cron/job",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dhcp_server: per-interface singleton, POST not supported

# SKIP /api/v2/services/dhcp_server/address_pool: requires parent_id (needs parent resource first)

# SKIP /api/v2/services/dhcp_server/custom_option: requires parent_id (needs parent resource first)

# SKIP /api/v2/services/dhcp_server/static_mapping: requires parent_id (needs parent resource first)

def test_crud_services_dns_forwarder_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_forwarder/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_forwarder/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": "10.99.99.2",
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_forwarder/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_forwarder/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_forwarder/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_forwarder/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dns_forwarder/host_override/alias: requires parent_id (needs parent resource first)

def test_crud_services_dns_resolver_access_list(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/access_list"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/access_list",
        json={
        "action": 'allow',
        "name": "pft_services_d",
        "networks": [],
        "description": "test_services_dns_resolver_access_list",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/access_list",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/access_lists",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/access_list",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/access_list",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dns_resolver/access_list/network: requires parent_id (needs parent resource first)

def test_crud_services_dns_resolver_domain_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/domain_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/domain_override",
        json={
        "domain": "example.com",
        "ip": "10.99.99.2",
        "descr": "Test created by generator",
        "forward_tls_upstream": False,
        "tls_hostname": "test_services_dns_resolver_domain_override",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/domain_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/domain_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/domain_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/domain_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_dns_resolver_host_override(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/dns_resolver/host_override"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/dns_resolver/host_override",
        json={
        "domain": "example.com",
        "host": "10.99.99.70",
        "ip": ["10.99.99.2"],
        "aliases": [],
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/dns_resolver/host_override",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/dns_resolver/host_overrides",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/dns_resolver/host_override",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/dns_resolver/host_override",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/dns_resolver/host_override/alias: requires parent_id (needs parent resource first)

# SKIP /api/v2/services/freeradius/client: freeradius routes not registered

# SKIP /api/v2/services/freeradius/interface: freeradius routes not registered

# SKIP /api/v2/services/freeradius/user: freeradius routes not registered

def test_crud_services_haproxy_backend(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/backend"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/backend",
        json={
        "agent_port": "443",
        "name": "pft_services_h",
        "persist_cookie_name": "test_services_haproxy_backend",
        "acls": [],
        "actions": [],
        "advanced": "test_services_haproxy_backend",
        "advanced_backend": "test_services_haproxy_backend",
        "agent_checks": False,
        "agent_inter": 1,
        "balance": '',
        "balance_uridepth": 1,
        "balance_urilen": 1,
        "balance_uriwhole": False,
        "check_type": 'none',
        "checkinter": 1,
        "connection_timeout": 1,
        "cookie_attribute_secure": False,
        "email_level": '',
        "email_to": "test@example.com",
        "errorfiles": [],
        "haproxy_cookie_domains": [],
        "haproxy_cookie_dynamic_cookie_key": "test_services_haproxy_backend",
        "haproxy_cookie_maxidle": 1,
        "haproxy_cookie_maxlife": 1,
        "httpcheck_method": 'OPTIONS',
        "log_health_checks": False,
        "monitor_domain": "test_services_haproxy_backend",
        "monitor_httpversion": "test_services_haproxy_backend",
        "monitor_uri": "test_services_haproxy_backend",
        "monitor_username": "test_services_haproxy_backend",
        "persist_cookie_cachable": False,
        "persist_cookie_enabled": False,
        "persist_cookie_httponly": False,
        "persist_cookie_mode": 'passive',
        "persist_cookie_postonly": False,
        "persist_cookie_secure": False,
        "persist_stick_cookiename": "test_services_haproxy_backend",
        "persist_stick_expire": "test_services_haproxy_backend",
        "persist_stick_length": 1,
        "persist_stick_tablesize": "test_services_haproxy_backend",
        "persist_sticky_type": 'none',
        "retries": 1,
        "server_timeout": 1,
        "servers": [],
        "stats_admin": "test_services_haproxy_backend",
        "stats_desc": "test_services_haproxy_backend",
        "stats_enabled": False,
        "stats_node": "test_services_haproxy_backend",
        "stats_password": "test_services_haproxy_backend",
        "stats_realm": "test_services_haproxy_backend",
        "stats_refresh": 1,
        "stats_scope": [],
        "stats_uri": "test_services_haproxy_backend",
        "stats_username": "test_services_haproxy_backend",
        "strict_transport_security": 1,
        "transparent_clientip": False,
        "transparent_interface": "test_services_haproxy_backend",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/backend",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/backends",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/services/haproxy/backend",
            json={"id": obj_id, "advanced": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("advanced") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/backend",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/haproxy/backend/acl: requires existing backend parent

# SKIP /api/v2/services/haproxy/backend/action: requires existing backend parent

# SKIP /api/v2/services/haproxy/backend/error_file: requires existing backend parent

# SKIP /api/v2/services/haproxy/backend/server: requires existing backend parent

def test_crud_services_haproxy_file(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/haproxy/file"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/haproxy/file",
        json={
        "content": "test_services_haproxy_file",
        "name": "pft_haproxy",
        "type": 'luascript',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/haproxy/file",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/haproxy/files",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/haproxy/file",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/services/haproxy/frontend: requires existing backend

# SKIP /api/v2/services/haproxy/frontend/acl: requires existing frontend parent

# SKIP /api/v2/services/haproxy/frontend/action: requires existing frontend parent

# SKIP /api/v2/services/haproxy/frontend/address: requires existing frontend parent

# SKIP /api/v2/services/haproxy/frontend/certificate: requires existing frontend parent

# SKIP /api/v2/services/haproxy/frontend/error_file: requires existing frontend parent

# SKIP /api/v2/services/haproxy/settings/dns_resolver: server error: requires parent model

# SKIP /api/v2/services/haproxy/settings/email_mailer: server error: requires parent model

def test_crud_services_ntp_time_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/ntp/time_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/ntp/time_server",
        json={
        "timeserver": "10.99.99.99",
        "noselect": False,
        "prefer": False,
        "type": 'server',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/ntp/time_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/ntp/time_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/ntp/time_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_services_service_watchdog(client: httpx.Client):
    """CRUD lifecycle: /api/v2/services/service_watchdog"""
    # CREATE
    create_resp = client.post(
        "/api/v2/services/service_watchdog",
        json={
        "name": "sshd",
        "notify": False,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/services/service_watchdog",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/services/service_watchdogs",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/services/service_watchdog",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/system/certificate: requires valid PEM certificate data

# SKIP /api/v2/system/certificate_authority: requires valid PEM CA data

# SKIP /api/v2/system/crl: requires caref (needs existing CA/cert)

# SKIP /api/v2/system/crl/revoked_certificate: requires certref (needs existing CA/cert)

def test_crud_system_restapi_access_list_entry(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/restapi/access_list/entry"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/restapi/access_list/entry",
        json={
        "network": "10.99.99.0/24",
        "descr": "Test created by generator",
        "type": 'allow',
        "users": [],
        "weight": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/restapi/access_list/entry",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/restapi/access_list/entries",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/restapi/access_list/entry",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/restapi/access_list/entry",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_system_tunable(client: httpx.Client):
    """CRUD lifecycle: /api/v2/system/tunable"""
    # CREATE
    create_resp = client.post(
        "/api/v2/system/tunable",
        json={
        "tunable": "test_system_tunable",
        "value": "1",
        "descr": "Test created by generator",
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/system/tunable",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/system/tunables",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/system/tunable",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/system/tunable",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user",
        json={
        "name": "pft_user",
        "password": "Testpass123!Abc",
        "authorizedkeys": "test_user",
        "cert": [],
        "descr": "Test created by generator",
        "disabled": False,
        "expires": "12/31/2030",
        "ipsecpsk": "test_user",
        "priv": [],
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/users",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_auth_server(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/auth_server"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/auth_server",
        json={
        "host": "10.99.99.70",
        "ldap_bindpw": "test_user_auth_server",
        "ldap_port": "389",
        "ldap_scope": "one",
        "ldap_urltype": "Standard TCP",
        "name": "pft_user_auth_",
        "radius_nasip_attribute": "lan",
        "radius_secret": "test_user_auth_server",
        "type": "ldap",
        "ldap_allow_unauthenticated": False,
        "ldap_attr_group": "cn",
        "ldap_attr_groupobj": "posixGroup",
        "ldap_attr_member": "member",
        "ldap_attr_user": "uid",
        "ldap_authcn": "ou=people,dc=example,dc=com",
        "ldap_basedn": "dc=example,dc=com",
        "ldap_binddn": "test_user_auth_server",
        "ldap_caref": "test_user_auth_server",
        "ldap_extended_enabled": False,
        "ldap_extended_query": "test_user_auth_server",
        "ldap_nostrip_at": False,
        "ldap_pam_groupdn": "test_user_auth_server",
        "ldap_protver": 3,
        "ldap_rfc2307": False,
        "ldap_rfc2307_userdn": False,
        "ldap_timeout": 25,
        "ldap_utf8": False,
        "radius_acct_port": "1813",
        "radius_auth_port": "1812",
        "radius_protocol": 'MSCHAPv2',
        "radius_timeout": 5,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/auth_server",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/auth_servers",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/auth_server",
            json={"id": obj_id, "ldap_attr_group": "updated_test_value"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("ldap_attr_group") == "updated_test_value"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/auth_server",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


def test_crud_user_group(client: httpx.Client):
    """CRUD lifecycle: /api/v2/user/group"""
    # CREATE
    create_resp = client.post(
        "/api/v2/user/group",
        json={
        "name": "pft_user_group",
        "description": "test_user_group",
        "member": [],
        "priv": [],
        "scope": 'local',
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/user/group",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/user/groups",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/user/group",
            json={"id": obj_id, "description": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("description") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/user/group",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/vpn/ipsec/phase1: requires caref (needs existing CA/cert)

# SKIP /api/v2/vpn/ipsec/phase1/encryption: requires parent_id (needs parent resource first)

# SKIP /api/v2/vpn/ipsec/phase2: requires existing phase1

# SKIP /api/v2/vpn/ipsec/phase2/encryption: requires parent_id (needs parent resource first)

# SKIP /api/v2/vpn/openvpn/client: requires caref (needs existing CA/cert)

# SKIP /api/v2/vpn/openvpn/client_export/config: requires OpenVPN server configured

# SKIP /api/v2/vpn/openvpn/cso: requires existing OpenVPN server

# SKIP /api/v2/vpn/openvpn/server: requires caref (needs existing CA/cert)

# SKIP /api/v2/vpn/wireguard/peer: requires existing WireGuard tunnel

# SKIP /api/v2/vpn/wireguard/peer/allowed_ip: requires parent_id (needs parent resource first)

def test_crud_vpn_wireguard_tunnel(client: httpx.Client):
    """CRUD lifecycle: /api/v2/vpn/wireguard/tunnel"""
    # CREATE
    create_resp = client.post(
        "/api/v2/vpn/wireguard/tunnel",
        json={
        "privatekey": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=",
        "addresses": [],
        "descr": "Test created by generator",
        "enabled": False,
        "listenport": "51820",
        "mtu": 1,
    },
    )
    data = _ok(create_resp)
    obj_id = data.get("id")
    assert obj_id is not None, f"No id in create response: {data}"

    try:
        # GET (singular)
        get_resp = client.get(
            "/api/v2/vpn/wireguard/tunnel",
            params={"id": obj_id},
        )
        get_data = _ok(get_resp)
        assert get_data.get("id") == obj_id

        # LIST (plural)
        list_resp = client.get(
            "/api/v2/vpn/wireguard/tunnels",
            params={"limit": 0},
        )
        if list_resp.status_code == 200:
            list_data = list_resp.json()
            if list_data.get("code") == 200:
                assert isinstance(list_data.get("data"), list)

        # UPDATE
        update_resp = client.patch(
            "/api/v2/vpn/wireguard/tunnel",
            json={"id": obj_id, "descr": "Updated by test"},
        )
        update_data = _ok(update_resp)
        assert update_data.get("descr") == "Updated by test"

    finally:
        # DELETE (cleanup, with retry for 503)
        for _attempt in range(3):
            del_resp = client.delete(
                "/api/v2/vpn/wireguard/tunnel",
                params={"id": obj_id},
            )
            if del_resp.status_code != 503:
                break
            time.sleep(5)
        # 200 = deleted, 404 = already gone (acceptable)
        assert del_resp.status_code in (200, 404), f"Delete failed: {del_resp.text[:500]}"


# SKIP /api/v2/vpn/wireguard/tunnel/address: requires parent_id (needs parent resource first)

def test_settings_firewall_advanced_settings(client: httpx.Client):
    """Settings read: /api/v2/firewall/advanced_settings"""
    # GET current settings
    resp = client.get("/api/v2/firewall/advanced_settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_acme_settings(client: httpx.Client):
    """Settings read: /api/v2/services/acme/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/acme/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_bind_sync_settings(client: httpx.Client):
    """Settings read: /api/v2/services/bind/sync/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/bind/sync/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_dns_resolver_settings(client: httpx.Client):
    """Settings read: /api/v2/services/dns_resolver/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/dns_resolver/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_haproxy_settings(client: httpx.Client):
    """Settings read: /api/v2/services/haproxy/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/haproxy/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_services_ntp_settings(client: httpx.Client):
    """Settings read: /api/v2/services/ntp/settings"""
    # GET current settings
    resp = client.get("/api/v2/services/ntp/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_status_logs_settings(client: httpx.Client):
    """Settings read: /api/v2/status/logs/settings"""
    # GET current settings
    resp = client.get("/api/v2/status/logs/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_restapi_settings(client: httpx.Client):
    """Settings read: /api/v2/system/restapi/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/restapi/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_system_webgui_settings(client: httpx.Client):
    """Settings read: /api/v2/system/webgui/settings"""
    # GET current settings
    resp = client.get("/api/v2/system/webgui/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_settings_vpn_wireguard_settings(client: httpx.Client):
    """Settings read: /api/v2/vpn/wireguard/settings"""
    # GET current settings
    resp = client.get("/api/v2/vpn/wireguard/settings")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_read_auth_keys(client: httpx.Client):
    """Read-only: /api/v2/auth/keys"""
    resp = client.get("/api/v2/auth/keys")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table"""
    resp = client.get("/api/v2/diagnostics/arp_table")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_arp_table_entry(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/arp_table/entry"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/arp_table/entry", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revision(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revision"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/config_history/revision", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_diagnostics_config_history_revisions(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/config_history/revisions"""
    resp = client.get("/api/v2/diagnostics/config_history/revisions")
    data = _ok(resp)
    assert data is not None


def test_read_diagnostics_table(client: httpx.Client):
    """Read-only: /api/v2/diagnostics/table"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/diagnostics/table", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


# SKIP /api/v2/diagnostics/tables: phantom plural route (spec-only, not registered on server)

def test_read_firewall_aliases(client: httpx.Client):
    """Read-only: /api/v2/firewall/aliases"""
    resp = client.get("/api/v2/firewall/aliases")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_one_to_one_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/one_to_one/mappings"""
    resp = client.get("/api/v2/firewall/nat/one_to_one/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_outbound_mappings(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/outbound/mappings"""
    resp = client.get("/api/v2/firewall/nat/outbound/mappings")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_nat_port_forwards(client: httpx.Client):
    """Read-only: /api/v2/firewall/nat/port_forwards"""
    resp = client.get("/api/v2/firewall/nat/port_forwards")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_rules(client: httpx.Client):
    """Read-only: /api/v2/firewall/rules"""
    resp = client.get("/api/v2/firewall/rules")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/firewall/schedule/time_ranges: phantom plural route (spec-only, not registered on server)

def test_read_firewall_schedules(client: httpx.Client):
    """Read-only: /api/v2/firewall/schedules"""
    resp = client.get("/api/v2/firewall/schedules")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_state(client: httpx.Client):
    """Read-only: /api/v2/firewall/state"""
    # Singular GET requires id -- skip if no objects exist
    resp = client.get("/api/v2/firewall/state", params={"id": 0})
    # May return 404 if no objects -- that's ok
    assert resp.status_code in (200, 400, 404), f"Unexpected: {resp.status_code}"


def test_read_firewall_states(client: httpx.Client):
    """Read-only: /api/v2/firewall/states"""
    resp = client.get("/api/v2/firewall/states")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/firewall/traffic_shaper/limiter/bandwidths: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/firewall/traffic_shaper/limiter/queues: phantom plural route (spec-only, not registered on server)

def test_read_firewall_traffic_shaper_limiters(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shaper/limiters"""
    resp = client.get("/api/v2/firewall/traffic_shaper/limiters", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/firewall/traffic_shaper/queues: phantom plural route (spec-only, not registered on server)

def test_read_firewall_traffic_shapers(client: httpx.Client):
    """Read-only: /api/v2/firewall/traffic_shapers"""
    resp = client.get("/api/v2/firewall/traffic_shapers")
    data = _ok(resp)
    assert data is not None


def test_read_firewall_virtual_ips(client: httpx.Client):
    """Read-only: /api/v2/firewall/virtual_ips"""
    resp = client.get("/api/v2/firewall/virtual_ips")
    data = _ok(resp)
    assert data is not None


def test_read_interface_available_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interface/available_interfaces"""
    resp = client.get("/api/v2/interface/available_interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_bridges(client: httpx.Client):
    """Read-only: /api/v2/interface/bridges"""
    resp = client.get("/api/v2/interface/bridges", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_interface_gres(client: httpx.Client):
    """Read-only: /api/v2/interface/gres"""
    resp = client.get("/api/v2/interface/gres")
    data = _ok(resp)
    assert data is not None


def test_read_interface_groups(client: httpx.Client):
    """Read-only: /api/v2/interface/groups"""
    resp = client.get("/api/v2/interface/groups")
    data = _ok(resp)
    assert data is not None


def test_read_interface_laggs(client: httpx.Client):
    """Read-only: /api/v2/interface/laggs"""
    resp = client.get("/api/v2/interface/laggs")
    data = _ok(resp)
    assert data is not None


def test_read_interface_vlans(client: httpx.Client):
    """Read-only: /api/v2/interface/vlans"""
    resp = client.get("/api/v2/interface/vlans")
    data = _ok(resp)
    assert data is not None


def test_read_interfaces(client: httpx.Client):
    """Read-only: /api/v2/interfaces"""
    resp = client.get("/api/v2/interfaces")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/routing/gateway/group/priorities: phantom plural route (spec-only, not registered on server)

def test_read_routing_gateway_groups(client: httpx.Client):
    """Read-only: /api/v2/routing/gateway/groups"""
    resp = client.get("/api/v2/routing/gateway/groups")
    data = _ok(resp)
    assert data is not None


def test_read_routing_gateways(client: httpx.Client):
    """Read-only: /api/v2/routing/gateways"""
    resp = client.get("/api/v2/routing/gateways")
    data = _ok(resp)
    assert data is not None


def test_read_routing_static_routes(client: httpx.Client):
    """Read-only: /api/v2/routing/static_routes"""
    resp = client.get("/api/v2/routing/static_routes")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_account_key_registrations(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_key/registrations"""
    resp = client.get("/api/v2/services/acme/account_key/registrations", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_account_keys(client: httpx.Client):
    """Read-only: /api/v2/services/acme/account_keys"""
    resp = client.get("/api/v2/services/acme/account_keys")
    data = _ok(resp)
    assert data is not None


def test_read_services_acme_certificate_issuances(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/issuances"""
    resp = client.get("/api/v2/services/acme/certificate/issuances", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificate_renewals(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificate/renewals"""
    resp = client.get("/api/v2/services/acme/certificate/renewals", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_services_acme_certificates(client: httpx.Client):
    """Read-only: /api/v2/services/acme/certificates"""
    resp = client.get("/api/v2/services/acme/certificates")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/bind/access_list/entries: phantom plural route (spec-only, not registered on server)

def test_read_services_bind_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/bind/access_lists"""
    resp = client.get("/api/v2/services/bind/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_sync_remote_hosts(client: httpx.Client):
    """Read-only: /api/v2/services/bind/sync/remote_hosts"""
    resp = client.get("/api/v2/services/bind/sync/remote_hosts")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_views(client: httpx.Client):
    """Read-only: /api/v2/services/bind/views"""
    resp = client.get("/api/v2/services/bind/views")
    data = _ok(resp)
    assert data is not None


def test_read_services_bind_zones(client: httpx.Client):
    """Read-only: /api/v2/services/bind/zones"""
    resp = client.get("/api/v2/services/bind/zones")
    data = _ok(resp)
    assert data is not None


def test_read_services_cron_jobs(client: httpx.Client):
    """Read-only: /api/v2/services/cron/jobs"""
    resp = client.get("/api/v2/services/cron/jobs")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dhcp_server/address_pools: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/dhcp_server/custom_options: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/dhcp_server/static_mappings: phantom plural route (spec-only, not registered on server)

def test_read_services_dhcp_servers(client: httpx.Client):
    """Read-only: /api/v2/services/dhcp_servers"""
    resp = client.get("/api/v2/services/dhcp_servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/services/dns_forwarder/host_override/aliases: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_forwarder_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_forwarder/host_overrides"""
    resp = client.get("/api/v2/services/dns_forwarder/host_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dns_resolver/access_list/networks: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_resolver_access_lists(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/access_lists"""
    resp = client.get("/api/v2/services/dns_resolver/access_lists")
    data = _ok(resp)
    assert data is not None


def test_read_services_dns_resolver_domain_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/domain_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/domain_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/dns_resolver/host_override/aliases: phantom plural route (spec-only, not registered on server)

def test_read_services_dns_resolver_host_overrides(client: httpx.Client):
    """Read-only: /api/v2/services/dns_resolver/host_overrides"""
    resp = client.get("/api/v2/services/dns_resolver/host_overrides")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/freeradius/clients: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/freeradius/interfaces: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/freeradius/users: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/acls: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/actions: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/errorfiles: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/backend/servers: phantom plural route (spec-only, not registered on server)

def test_read_services_haproxy_backends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/backends"""
    resp = client.get("/api/v2/services/haproxy/backends")
    data = _ok(resp)
    assert data is not None


def test_read_services_haproxy_files(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/files"""
    resp = client.get("/api/v2/services/haproxy/files")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/haproxy/frontend/acls: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/actions: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/addresses: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/certificates: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/frontend/error_files: phantom plural route (spec-only, not registered on server)

def test_read_services_haproxy_frontends(client: httpx.Client):
    """Read-only: /api/v2/services/haproxy/frontends"""
    resp = client.get("/api/v2/services/haproxy/frontends")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/services/haproxy/settings/dns_resolvers: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/services/haproxy/settings/email_mailers: phantom plural route (spec-only, not registered on server)

def test_read_services_ntp_time_servers(client: httpx.Client):
    """Read-only: /api/v2/services/ntp/time_servers"""
    resp = client.get("/api/v2/services/ntp/time_servers")
    data = _ok(resp)
    assert data is not None


def test_read_services_service_watchdogs(client: httpx.Client):
    """Read-only: /api/v2/services/service_watchdogs"""
    resp = client.get("/api/v2/services/service_watchdogs")
    data = _ok(resp)
    assert data is not None


def test_read_status_dhcp_server_leases(client: httpx.Client):
    """Read-only: /api/v2/status/dhcp_server/leases"""
    resp = client.get("/api/v2/status/dhcp_server/leases")
    data = _ok(resp)
    assert data is not None


def test_read_status_gateways(client: httpx.Client):
    """Read-only: /api/v2/status/gateways"""
    resp = client.get("/api/v2/status/gateways", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_interfaces(client: httpx.Client):
    """Read-only: /api/v2/status/interfaces"""
    resp = client.get("/api/v2/status/interfaces", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/ipsec/child_sa: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/ipsec/child_sas: phantom plural route (spec-only, not registered on server)

def test_read_status_ipsec_sas(client: httpx.Client):
    """Read-only: /api/v2/status/ipsec/sas"""
    resp = client.get("/api/v2/status/ipsec/sas", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/logs/auth: phantom plural route (spec-only, not registered on server)

def test_read_status_logs_dhcp(client: httpx.Client):
    """Read-only: /api/v2/status/logs/dhcp"""
    resp = client.get("/api/v2/status/logs/dhcp", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_logs_firewall(client: httpx.Client):
    """Read-only: /api/v2/status/logs/firewall"""
    resp = client.get("/api/v2/status/logs/firewall", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/logs/openvpn: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/logs/packages/restapi: phantom plural route (spec-only, not registered on server)

def test_read_status_logs_system(client: httpx.Client):
    """Read-only: /api/v2/status/logs/system"""
    resp = client.get("/api/v2/status/logs/system", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/clients"""
    resp = client.get("/api/v2/status/openvpn/clients", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


# SKIP /api/v2/status/openvpn/server/connection: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/connections: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/route: phantom plural route (spec-only, not registered on server)

# SKIP /api/v2/status/openvpn/server/routes: phantom plural route (spec-only, not registered on server)

def test_read_status_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/status/openvpn/servers"""
    resp = client.get("/api/v2/status/openvpn/servers", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_services(client: httpx.Client):
    """Read-only: /api/v2/status/services"""
    resp = client.get("/api/v2/status/services", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_status_system(client: httpx.Client):
    """Read-only: /api/v2/status/system"""
    resp = client.get("/api/v2/status/system")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificate_authorities(client: httpx.Client):
    """Read-only: /api/v2/system/certificate_authorities"""
    resp = client.get("/api/v2/system/certificate_authorities")
    data = _ok(resp)
    assert data is not None


def test_read_system_certificates(client: httpx.Client):
    """Read-only: /api/v2/system/certificates"""
    resp = client.get("/api/v2/system/certificates")
    data = _ok(resp)
    assert data is not None


def test_read_system_crls(client: httpx.Client):
    """Read-only: /api/v2/system/crls"""
    resp = client.get("/api/v2/system/crls")
    data = _ok(resp)
    assert data is not None


def test_read_system_package_available(client: httpx.Client):
    """Read-only: /api/v2/system/package/available"""
    resp = client.get("/api/v2/system/package/available", params={"limit": 5})
    data = _ok(resp)
    assert isinstance(data, list)


def test_read_system_packages(client: httpx.Client):
    """Read-only: /api/v2/system/packages"""
    resp = client.get("/api/v2/system/packages")
    data = _ok(resp)
    assert data is not None


def test_read_system_restapi_access_list(client: httpx.Client):
    """Read-only: /api/v2/system/restapi/access_list"""
    resp = client.get("/api/v2/system/restapi/access_list")
    data = _ok(resp)
    assert data is not None


def test_read_system_tunables(client: httpx.Client):
    """Read-only: /api/v2/system/tunables"""
    resp = client.get("/api/v2/system/tunables")
    data = _ok(resp)
    assert data is not None


def test_read_system_version(client: httpx.Client):
    """Read-only: /api/v2/system/version"""
    resp = client.get("/api/v2/system/version")
    data = _ok(resp)
    assert data is not None


def test_read_user_auth_servers(client: httpx.Client):
    """Read-only: /api/v2/user/auth_servers"""
    resp = client.get("/api/v2/user/auth_servers")
    data = _ok(resp)
    assert data is not None


def test_read_user_groups(client: httpx.Client):
    """Read-only: /api/v2/user/groups"""
    resp = client.get("/api/v2/user/groups")
    data = _ok(resp)
    assert data is not None


def test_read_users(client: httpx.Client):
    """Read-only: /api/v2/users"""
    resp = client.get("/api/v2/users")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/ipsec/phase1/encryptions: phantom plural route (spec-only, not registered on server)

def test_read_vpn_ipsec_phase1s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase1s"""
    resp = client.get("/api/v2/vpn/ipsec/phase1s")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/ipsec/phase2/encryptions: phantom plural route (spec-only, not registered on server)

def test_read_vpn_ipsec_phase2s(client: httpx.Client):
    """Read-only: /api/v2/vpn/ipsec/phase2s"""
    resp = client.get("/api/v2/vpn/ipsec/phase2s")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/openvpn/client_export/configs: phantom plural route (spec-only, not registered on server)

def test_read_vpn_openvpn_clients(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/clients"""
    resp = client.get("/api/v2/vpn/openvpn/clients")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_csos(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/csos"""
    resp = client.get("/api/v2/vpn/openvpn/csos")
    data = _ok(resp)
    assert data is not None


def test_read_vpn_openvpn_servers(client: httpx.Client):
    """Read-only: /api/v2/vpn/openvpn/servers"""
    resp = client.get("/api/v2/vpn/openvpn/servers")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/wireguard/peer/allowed_ips: phantom plural route (spec-only, not registered on server)

def test_read_vpn_wireguard_peers(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/peers"""
    resp = client.get("/api/v2/vpn/wireguard/peers")
    data = _ok(resp)
    assert data is not None


# SKIP /api/v2/vpn/wireguard/tunnel/addresses: phantom plural route (spec-only, not registered on server)

def test_read_vpn_wireguard_tunnels(client: httpx.Client):
    """Read-only: /api/v2/vpn/wireguard/tunnels"""
    resp = client.get("/api/v2/vpn/wireguard/tunnels")
    data = _ok(resp)
    assert data is not None


def test_apply_firewall_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/apply"""
    resp = client.get("/api/v2/firewall/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_firewall_virtual_ip_apply(client: httpx.Client):
    """Apply status: /api/v2/firewall/virtual_ip/apply"""
    resp = client.get("/api/v2/firewall/virtual_ip/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_interface_apply(client: httpx.Client):
    """Apply status: /api/v2/interface/apply"""
    resp = client.get("/api/v2/interface/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_routing_apply(client: httpx.Client):
    """Apply status: /api/v2/routing/apply"""
    resp = client.get("/api/v2/routing/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dhcp_server_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dhcp_server/apply"""
    resp = client.get("/api/v2/services/dhcp_server/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_forwarder_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_forwarder/apply"""
    resp = client.get("/api/v2/services/dns_forwarder/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_dns_resolver_apply(client: httpx.Client):
    """Apply status: /api/v2/services/dns_resolver/apply"""
    resp = client.get("/api/v2/services/dns_resolver/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_services_haproxy_apply(client: httpx.Client):
    """Apply status: /api/v2/services/haproxy/apply"""
    resp = client.get("/api/v2/services/haproxy/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_ipsec_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/ipsec/apply"""
    resp = client.get("/api/v2/vpn/ipsec/apply")
    data = _ok(resp)
    assert isinstance(data, dict)


def test_apply_vpn_wireguard_apply(client: httpx.Client):
    """Apply status: /api/v2/vpn/wireguard/apply"""
    resp = client.get("/api/v2/vpn/wireguard/apply")
    data = _ok(resp)
    assert isinstance(data, dict)

