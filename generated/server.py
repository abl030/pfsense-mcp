"""
Auto-generated pfSense MCP server.

Generated by: python -m generator
Source: openapi-spec.json (pfSense REST API v2)
Tools: 677

DO NOT EDIT THIS FILE DIRECTLY.
Fix the generator or templates instead, then re-run.
"""

from __future__ import annotations

import os
from typing import Any

import httpx
from fastmcp import FastMCP

mcp = FastMCP("pfSense")


class PfSenseClient:
    """HTTP client for pfSense REST API v2."""

    def __init__(self) -> None:
        self.host = os.environ.get("PFSENSE_HOST", "https://192.168.1.1")
        self.api_key = os.environ.get("PFSENSE_API_KEY", "")
        self.verify_ssl = os.environ.get("PFSENSE_VERIFY_SSL", "false").lower() in (
            "true",
            "1",
            "yes",
        )
        self._client: httpx.AsyncClient | None = None

    async def _get_client(self) -> httpx.AsyncClient:
        if self._client is None or self._client.is_closed:
            self._client = httpx.AsyncClient(
                base_url=self.host.rstrip("/"),
                headers={"X-API-Key": self.api_key},
                verify=self.verify_ssl,
                timeout=30.0,
            )
        return self._client

    async def request(
        self,
        method: str,
        path: str,
        params: dict[str, Any] | None = None,
        json_body: dict[str, Any] | list | None = None,
    ) -> dict[str, Any]:
        """Make an API request and return the response."""
        client = await self._get_client()

        # Filter out None values from params
        if params:
            params = {k: v for k, v in params.items() if v is not None}

        try:
            resp = await client.request(
                method=method.upper(),
                url=path,
                params=params or None,
                json=json_body,
            )
            try:
                data = resp.json()
            except Exception:
                data = {"code": resp.status_code, "status": "error", "data": resp.text}

            # Unwrap successful responses
            if isinstance(data, dict) and data.get("code") == 200:
                return data.get("data", data)

            return data
        except httpx.ConnectError as e:
            return {"error": f"Connection failed: {e}. Check PFSENSE_HOST."}
        except httpx.ReadTimeout:
            return {"error": "Request timed out. The pfSense host may be slow or unreachable."}
        except Exception as e:
            return {"error": f"Request failed: {type(e).__name__}: {e}"}


_client = PfSenseClient()



@mcp.tool()
async def pfsense_post_auth_jwt(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/auth/jwt

    WARNING: This endpoint requires HTTP BasicAuth (username:password).
    It does NOT accept API key or JWT auth. Will return 401 via MCP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/auth/jwt. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/auth/jwt",
    )


@mcp.tool()
async def pfsense_create_auth_key(
    confirm: bool = False,
    descr: str | None = None,
    hash: str | None = None,
    hash_algo: str | None = 'sha256',
    key: str | None = None,
    length_bytes: int | None = 24,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/auth/key

    WARNING: This endpoint requires HTTP BasicAuth (username:password).
    It does NOT accept API key or JWT auth. Will return 401 via MCP.

    descr: Sets a description for this API key. This is used to identify the key's purpose and cannot be changed once created.
    hash: The hash of the generated API key
    hash_algo: The hash algorithm used for this API key. It is recommended to increase the strength of the algorithm for keys assigned to privileged users. Valid values: ['sha256', 'sha384', 'sha512']
    key: The real API key. This value is not stored internally and cannot be recovered if lost.
    length_bytes: The length of the API key (in bytes). Greater key lengths provide greater security, but also increase the number of characters used in the key string. Valid values: [16, 24, 32, 64]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/auth/key. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if descr is not None:
        body["descr"] = descr
    if hash is not None:
        body["hash"] = hash
    if hash_algo is not None:
        body["hash_algo"] = hash_algo
    if key is not None:
        body["key"] = key
    if length_bytes is not None:
        body["length_bytes"] = length_bytes
    return await _client.request(
        "POST",
        "/api/v2/auth/key",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_auth_key(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/auth/key

    WARNING: This endpoint requires HTTP BasicAuth (username:password).
    It does NOT accept API key or JWT auth. Will return 401 via MCP.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/auth/key. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/auth/key",
        params=params,
    )


@mcp.tool()
async def pfsense_list_auth_keys(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/auth/keys

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/auth/keys",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_auth_keys(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/auth/keys

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/auth/keys. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/auth/keys",
        params=params,
    )


@mcp.tool()
async def pfsense_list_diagnostics_arp_table(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/arp_table

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/arp_table",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_diagnostics_arp_table(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/diagnostics/arp_table

    WARNING: DANGEROUS: Clears the entire ARP table.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/diagnostics/arp_table. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Clears the entire ARP table."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/diagnostics/arp_table",
        params=params,
    )


@mcp.tool()
async def pfsense_get_diagnostics_arp_table_entry(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/arp_table/entry

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/arp_table/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_diagnostics_arp_table_entry(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/diagnostics/arp_table/entry

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/diagnostics/arp_table/entry. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/diagnostics/arp_table/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_post_diagnostics_command_prompt(
    command: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/diagnostics/command_prompt

    WARNING: DANGEROUS: Executes arbitrary shell commands.

    command: The command to be executed.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/diagnostics/command_prompt. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Executes arbitrary shell commands."
        )
    body: dict[str, Any] = {}
    if command is not None:
        body["command"] = command
    return await _client.request(
        "POST",
        "/api/v2/diagnostics/command_prompt",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_diagnostics_config_history_revision(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/config_history/revision

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/config_history/revision",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_diagnostics_config_history_revision(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/diagnostics/config_history/revision

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/diagnostics/config_history/revision. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/diagnostics/config_history/revision",
        params=params,
    )


@mcp.tool()
async def pfsense_list_diagnostics_config_history_revisions(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/config_history/revisions

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/config_history/revisions",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_diagnostics_config_history_revisions(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/diagnostics/config_history/revisions

    WARNING: DANGEROUS: Deletes all config history.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/diagnostics/config_history/revisions. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Deletes all config history."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/diagnostics/config_history/revisions",
        params=params,
    )


@mcp.tool()
async def pfsense_post_diagnostics_halt_system(
    confirm: bool = False,
    dry_run: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/diagnostics/halt_system

    WARNING: DANGEROUS: Halts the pfSense system.

    dry_run: Run through the call but don't actually initiate a shutdown.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/diagnostics/halt_system. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Halts the pfSense system."
        )
    body: dict[str, Any] = {}
    if dry_run is not None:
        body["dry_run"] = dry_run
    return await _client.request(
        "POST",
        "/api/v2/diagnostics/halt_system",
        json_body=body,
    )


@mcp.tool()
async def pfsense_post_diagnostics_ping(
    host: str,
    confirm: bool = False,
    count: int | None = 3,
    source_address: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/diagnostics/ping

    host: The IP address or hostname to ping.
    count: The number of ping requests to send.
    source_address: The source IP address to use for ping requests.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/diagnostics/ping. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if host is not None:
        body["host"] = host
    if count is not None:
        body["count"] = count
    if source_address is not None:
        body["source_address"] = source_address
    return await _client.request(
        "POST",
        "/api/v2/diagnostics/ping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_post_diagnostics_reboot(
    confirm: bool = False,
    dry_run: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/diagnostics/reboot

    WARNING: DANGEROUS: Reboots the pfSense system.

    dry_run: Run through the call but don't actually initiate a reboot.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/diagnostics/reboot. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Reboots the pfSense system."
        )
    body: dict[str, Any] = {}
    if dry_run is not None:
        body["dry_run"] = dry_run
    return await _client.request(
        "POST",
        "/api/v2/diagnostics/reboot",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_diagnostics_table(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/table

    id: The ID of the object to target. Common pfSense PF table names: virusprot, bogons, snort2c, LAN_NETWORK, WAN_NETWORK.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/table",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_diagnostics_table(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/diagnostics/table

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/diagnostics/table. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/diagnostics/table",
        params=params,
    )


@mcp.tool()
async def pfsense_list_diagnostics_tables(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/diagnostics/tables

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/diagnostics/tables",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_advanced_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/advanced_settings
    """
    return await _client.request(
        "GET",
        "/api/v2/firewall/advanced_settings",
    )


@mcp.tool()
async def pfsense_update_firewall_advanced_settings(
    confirm: bool = False,
    aliasesresolveinterval: int | None = None,
    checkaliasesurlcert: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/advanced_settings

    Note: Call pfsense_firewall_apply after this to apply changes.

    aliasesresolveinterval: The interval (in seconds) at which to resolve hostnames in aliases.
    checkaliasesurlcert: Check the certificate of URLs used in aliases.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/advanced_settings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if aliasesresolveinterval is not None:
        body["aliasesresolveinterval"] = aliasesresolveinterval
    if checkaliasesurlcert is not None:
        body["checkaliasesurlcert"] = checkaliasesurlcert
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/advanced_settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_firewall_alias(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/alias

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_alias(
    name: str,
    type_: str,
    confirm: bool = False,
    address: list[str] | None = None,
    descr: str | None = None,
    detail: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/alias

    Note: Call pfsense_firewall_apply after this to apply changes.

    name: Sets the name for the alias. This name must be unique from all other aliases.
    type_: Sets the type of alias this object will be. This directly impacts what values can be specified in the `address` field. Valid values: ['host', 'network', 'port']
    address: Sets the host, network or port entries for the alias. When `type` is set to `host`, each entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You may also specify an existing alias's `name` as an entry to created nested aliases.
    descr: Sets a description to help specify the purpose or contents of the alias.
    detail: Sets descriptions for each alias `address`. Values must match the order of the `address` value it relates to. For example, the first value specified here is the description for the first value specified in the `address` field. This value cannot contain
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    if address is not None:
        body["address"] = address
    if descr is not None:
        body["descr"] = descr
    if detail is not None:
        body["detail"] = detail
    return await _client.request(
        "POST",
        "/api/v2/firewall/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_alias(
    id: str | int,
    confirm: bool = False,
    address: list[str] | None = None,
    descr: str | None = None,
    detail: list[str] | None = None,
    name: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/alias

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    address: Sets the host, network or port entries for the alias. When `type` is set to `host`, each entry must be a valid IP address or FQDN. When `type` is set to `network`, each entry must be a valid network CIDR or FQDN. When `type` is set to `port`, each entry must be a valid port or port range. You may also specify an existing alias's `name` as an entry to created nested aliases.
    descr: Sets a description to help specify the purpose or contents of the alias.
    detail: Sets descriptions for each alias `address`. Values must match the order of the `address` value it relates to. For example, the first value specified here is the description for the first value specified in the `address` field. This value cannot contain
    name: Sets the name for the alias. This name must be unique from all other aliases.
    type_: Sets the type of alias this object will be. This directly impacts what values can be specified in the `address` field. Valid values: ['host', 'network', 'port']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if address is not None:
        body["address"] = address
    if descr is not None:
        body["descr"] = descr
    if detail is not None:
        body["detail"] = detail
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_alias(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/alias

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_aliases(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/aliases

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_aliases(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/aliases

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/aliases. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/aliases",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_aliases(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/aliases

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/aliases. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/firewall/apply",
    )


@mcp.tool()
async def pfsense_firewall_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/firewall/apply",
    )


@mcp.tool()
async def pfsense_get_firewall_nat_one_to_one_mapping(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/one_to_one/mapping

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/one_to_one/mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_nat_one_to_one_mapping(
    destination: str,
    external: str,
    interface: str,
    source: str,
    confirm: bool = False,
    descr: str | None = None,
    disabled: bool | None = None,
    ipprotocol: str | None = 'inet',
    natreflection: str | None = None,
    nobinat: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/nat/one_to_one/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    destination: The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    external: The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    interface: The interface this 1:1 NAT mapping applies to.
    source: The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    descr: A description for this 1:1 NAT mapping
    disabled: Disables this 1:1 NAT mapping.
    ipprotocol: The IP version this mapping applies to. Valid values: ['inet', 'inet6']
    natreflection: Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default. Valid values: ['enable', 'disable']
    nobinat: Exclude traffic matching this mapping from a later, more general, mapping.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/nat/one_to_one/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if destination is not None:
        body["destination"] = destination
    if external is not None:
        body["external"] = external
    if interface is not None:
        body["interface"] = interface
    if source is not None:
        body["source"] = source
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if natreflection is not None:
        body["natreflection"] = natreflection
    if nobinat is not None:
        body["nobinat"] = nobinat
    return await _client.request(
        "POST",
        "/api/v2/firewall/nat/one_to_one/mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_nat_one_to_one_mapping(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    destination: str | None = None,
    disabled: bool | None = None,
    external: str | None = None,
    interface: str | None = None,
    ipprotocol: str | None = None,
    natreflection: str | None = None,
    nobinat: bool | None = None,
    source: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/nat/one_to_one/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description for this 1:1 NAT mapping
    destination: The destination IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    disabled: Disables this 1:1 NAT mapping.
    external: The external IP address or interface for the 1:1 mapping. Valid value options are: an IP address. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    interface: The interface this 1:1 NAT mapping applies to.
    ipprotocol: The IP version this mapping applies to. Valid values: ['inet', 'inet6']
    natreflection: Enables or disables NAT reflection for traffic matching this mapping. Set to `null` to use the system default. Valid values: ['enable', 'disable']
    nobinat: Exclude traffic matching this mapping from a later, more general, mapping.
    source: The source IP address or subnet that traffic must match to apply this mapping. Valid value options are: an existing interface, an IP address, a subnet CIDR, `any`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/nat/one_to_one/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if destination is not None:
        body["destination"] = destination
    if disabled is not None:
        body["disabled"] = disabled
    if external is not None:
        body["external"] = external
    if interface is not None:
        body["interface"] = interface
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if natreflection is not None:
        body["natreflection"] = natreflection
    if nobinat is not None:
        body["nobinat"] = nobinat
    if source is not None:
        body["source"] = source
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/nat/one_to_one/mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_one_to_one_mapping(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/one_to_one/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/one_to_one/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/one_to_one/mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_nat_one_to_one_mappings(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/one_to_one/mappings

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/one_to_one/mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_nat_one_to_one_mappings(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/nat/one_to_one/mappings

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/nat/one_to_one/mappings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/nat/one_to_one/mappings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_one_to_one_mappings(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/one_to_one/mappings

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/one_to_one/mappings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/one_to_one/mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_nat_outbound_mapping(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/outbound/mapping

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/outbound/mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_nat_outbound_mapping(
    destination: str,
    interface: str,
    source: str,
    confirm: bool = False,
    descr: str | None = None,
    destination_port: str | None = None,
    disabled: bool | None = None,
    nat_port: str | None = None,
    nonat: bool | None = None,
    nosync: bool | None = None,
    poolopts: str | None = None,
    protocol: str | None = None,
    source_hash_key: str | None = None,
    source_port: str | None = None,
    static_nat_port: bool | None = None,
    target: str | None = None,
    target_subnet: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/nat/outbound/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    destination: The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    interface: The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.
    source: The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    descr: A description for the outbound NAT mapping.
    destination_port: The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias
    disabled: Disable this outbound NAT rule.
    nat_port: The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`This field is only available when the following conditions are met:- `static_nat_port` must be equal to `false`- `nonat` must be equal to `false`
    nonat: Do not NAT traffic matching this rule.
    nosync: Do not sync this rule to HA peers.
    poolopts: The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.This field is only available when the following conditions are met:- `nonat` must be equal to `false` Valid values: ['round-robin', 'round-robin sticky-address', 'random', 'random sticky-address', 'source-hash', 'bitmask']
    protocol: The protocol this rule should match. Use `null` for any protocol. Valid values: ['tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf']
    source_hash_key: The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generatedThis field is only available when the following conditions are met:- `poolopts` must be equal to `'source-hash'`- `nonat` must be equal to `false`
    source_port: The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias
    static_nat_port: Do not rewrite source port for traffic matching this rule.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    target: The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    target_subnet: The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/nat/outbound/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if destination is not None:
        body["destination"] = destination
    if interface is not None:
        body["interface"] = interface
    if source is not None:
        body["source"] = source
    if descr is not None:
        body["descr"] = descr
    if destination_port is not None:
        body["destination_port"] = destination_port
    if disabled is not None:
        body["disabled"] = disabled
    if nat_port is not None:
        body["nat_port"] = nat_port
    if nonat is not None:
        body["nonat"] = nonat
    if nosync is not None:
        body["nosync"] = nosync
    if poolopts is not None:
        body["poolopts"] = poolopts
    if protocol is not None:
        body["protocol"] = protocol
    if source_hash_key is not None:
        body["source_hash_key"] = source_hash_key
    if source_port is not None:
        body["source_port"] = source_port
    if static_nat_port is not None:
        body["static_nat_port"] = static_nat_port
    if target is not None:
        body["target"] = target
    if target_subnet is not None:
        body["target_subnet"] = target_subnet
    return await _client.request(
        "POST",
        "/api/v2/firewall/nat/outbound/mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_nat_outbound_mapping(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    destination: str | None = None,
    destination_port: str | None = None,
    disabled: bool | None = None,
    interface: str | None = None,
    nat_port: str | None = None,
    nonat: bool | None = None,
    nosync: bool | None = None,
    poolopts: str | None = None,
    protocol: str | None = None,
    source: str | None = None,
    source_hash_key: str | None = None,
    source_port: str | None = None,
    static_nat_port: bool | None = None,
    target: str | None = None,
    target_subnet: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/nat/outbound/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description for the outbound NAT mapping.
    destination: The destination network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    destination_port: The destination port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias
    disabled: Disable this outbound NAT rule.
    interface: The interface on which traffic is matched as it exits the firewall. In most cases this is a WAN-type or another externally-connected interface.
    nat_port: The external source port or port range used for rewriting the original source port on connections matching the rule. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`This field is only available when the following conditions are met:- `static_nat_port` must be equal to `false`- `nonat` must be equal to `false`
    nonat: Do not NAT traffic matching this rule.
    nosync: Do not sync this rule to HA peers.
    poolopts: The pool option used to load balance external IP mapping when `target` is set to a subnet or alias of many addresses. Set to `null` to revert to the system default.This field is only available when the following conditions are met:- `nonat` must be equal to `false` Valid values: ['round-robin', 'round-robin sticky-address', 'random', 'random sticky-address', 'source-hash', 'bitmask']
    protocol: The protocol this rule should match. Use `null` for any protocol. Valid values: ['tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf']
    source: The source network this rule should match. Valid value options are: an existing interface, a subnet CIDR, an existing alias, `any`, `(self)`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    source_hash_key: The key that is fed to the hashing algorithm in hex format. This must be a 16 byte (32 character) hex string prefixed with `0x`. If a value is not provided, one will automatically be generatedThis field is only available when the following conditions are met:- `poolopts` must be equal to `'source-hash'`- `nonat` must be equal to `false`
    source_port: The source port this rule should match. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall alias
    static_nat_port: Do not rewrite source port for traffic matching this rule.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    target: The target network traffic matching this rule should be translated to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    target_subnet: The subnet bits for the assigned `target`. This field is only applicable if `target` is set to an IP address. This has no affect for alias or interface `targets`.This field is only available when the following conditions are met:- `nonat` must be equal to `false`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/nat/outbound/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if destination is not None:
        body["destination"] = destination
    if destination_port is not None:
        body["destination_port"] = destination_port
    if disabled is not None:
        body["disabled"] = disabled
    if interface is not None:
        body["interface"] = interface
    if nat_port is not None:
        body["nat_port"] = nat_port
    if nonat is not None:
        body["nonat"] = nonat
    if nosync is not None:
        body["nosync"] = nosync
    if poolopts is not None:
        body["poolopts"] = poolopts
    if protocol is not None:
        body["protocol"] = protocol
    if source is not None:
        body["source"] = source
    if source_hash_key is not None:
        body["source_hash_key"] = source_hash_key
    if source_port is not None:
        body["source_port"] = source_port
    if static_nat_port is not None:
        body["static_nat_port"] = static_nat_port
    if target is not None:
        body["target"] = target
    if target_subnet is not None:
        body["target_subnet"] = target_subnet
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/nat/outbound/mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_outbound_mapping(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/outbound/mapping

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/outbound/mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/outbound/mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_nat_outbound_mappings(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/outbound/mappings

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/outbound/mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_nat_outbound_mappings(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/nat/outbound/mappings

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/nat/outbound/mappings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/nat/outbound/mappings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_outbound_mappings(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/outbound/mappings

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/outbound/mappings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/outbound/mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_nat_outbound_mode(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/outbound/mode
    """
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/outbound/mode",
    )


@mcp.tool()
async def pfsense_update_firewall_nat_outbound_mode(
    mode: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/nat/outbound/mode

    Note: Call pfsense_firewall_apply after this to apply changes.

    mode: The outbound NAT mode to assign this system. Set to `automatic` to have this system automatically generate NAT rules this firewall, `hybrid` to automatically generate NAT rules AND allow manual outbound NAT mappings to be assigned, `manual` to prevent the system from automatically generating NAT rules and only allow manual outbound NAT mappings, or `disabled` to disable outbound NAT on this system entirely. Valid values: ['automatic', 'hybrid', 'advanced', 'disabled']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/nat/outbound/mode. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if mode is not None:
        body["mode"] = mode
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/nat/outbound/mode",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_firewall_nat_port_forward(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/port_forward

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/port_forward",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_nat_port_forward(
    destination: str,
    interface: str,
    protocol: str,
    source: str,
    target: str,
    confirm: bool = False,
    associated_rule_id: str | None = None,
    descr: str | None = None,
    destination_port: str | None = None,
    disabled: bool | None = None,
    ipprotocol: str | None = 'inet',
    local_port: str | None = None,
    natreflection: str | None = None,
    nordr: bool | None = None,
    nosync: bool | None = None,
    source_port: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/nat/port_forward

    Note: Call pfsense_firewall_apply after this to apply changes.

    destination: The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    interface: The interface this port forward rule applies to.
    protocol: The IP/transport protocol this port forward rule should match. Valid values: ['any', 'tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf']
    source: The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    target: The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    associated_rule_id: The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule. Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.
    descr: A description for this port forward rule.
    destination_port: The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    disabled: Disables this port forward rule.
    ipprotocol: The IP protocol this port forward rule should match. Valid values: ['inet', 'inet6', 'inet46']
    local_port: The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    natreflection: The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default. Valid values: ['enable', 'disable', 'purenat']
    nordr: Disables redirection for traffic matching this rule.
    nosync: Prevents this port forward rule from being synced to non-primary CARP members.
    source_port: The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/nat/port_forward. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if destination is not None:
        body["destination"] = destination
    if interface is not None:
        body["interface"] = interface
    if protocol is not None:
        body["protocol"] = protocol
    if source is not None:
        body["source"] = source
    if target is not None:
        body["target"] = target
    if associated_rule_id is not None:
        body["associated_rule_id"] = associated_rule_id
    if descr is not None:
        body["descr"] = descr
    if destination_port is not None:
        body["destination_port"] = destination_port
    if disabled is not None:
        body["disabled"] = disabled
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if local_port is not None:
        body["local_port"] = local_port
    if natreflection is not None:
        body["natreflection"] = natreflection
    if nordr is not None:
        body["nordr"] = nordr
    if nosync is not None:
        body["nosync"] = nosync
    if source_port is not None:
        body["source_port"] = source_port
    return await _client.request(
        "POST",
        "/api/v2/firewall/nat/port_forward",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_nat_port_forward(
    id: str | int,
    confirm: bool = False,
    associated_rule_id: str | None = None,
    descr: str | None = None,
    destination: str | None = None,
    destination_port: str | None = None,
    disabled: bool | None = None,
    interface: str | None = None,
    ipprotocol: str | None = None,
    local_port: str | None = None,
    natreflection: str | None = None,
    nordr: bool | None = None,
    nosync: bool | None = None,
    protocol: str | None = None,
    source: str | None = None,
    source_port: str | None = None,
    target: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/nat/port_forward

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    associated_rule_id: The associated firewall rule mode. Use an empty string to require a separate firewall rule to be created to pass traffic matching this port forward rule. Use `new` to create a new associated firewall rule to pass traffic matching this port forward rule. Use `pass` to automatically pass traffic matching this port forward rule without the need for a firewall rule. Otherwise, you can specify the `associated_rule_id` of an existing firewall rule to associate with this port forward rule.
    descr: A description for this port forward rule.
    destination: The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    destination_port: The destination port this port forward rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    disabled: Disables this port forward rule.
    interface: The interface this port forward rule applies to.
    ipprotocol: The IP protocol this port forward rule should match. Valid values: ['inet', 'inet6', 'inet46']
    local_port: The port on the internal host to forward matching traffic to. In most cases, this must match the `destination_port` value. In the event that the `desintation_port` is a range, this value should be the first value in that range. Valid options are: a TCP/UDP port number, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    natreflection: The NAT reflection mode to use for traffic matching this port forward rule. Set to `null` to use the system default. Valid values: ['enable', 'disable', 'purenat']
    nordr: Disables redirection for traffic matching this rule.
    nosync: Prevents this port forward rule from being synced to non-primary CARP members.
    protocol: The IP/transport protocol this port forward rule should match. Valid values: ['any', 'tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf']
    source: The source address this port forward rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    source_port: The source port this port forward rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    target: The IP address or alias of the internal host to forward matching traffic to. Valid value options are: an IP address, an existing alias. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/nat/port_forward. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if associated_rule_id is not None:
        body["associated_rule_id"] = associated_rule_id
    if descr is not None:
        body["descr"] = descr
    if destination is not None:
        body["destination"] = destination
    if destination_port is not None:
        body["destination_port"] = destination_port
    if disabled is not None:
        body["disabled"] = disabled
    if interface is not None:
        body["interface"] = interface
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if local_port is not None:
        body["local_port"] = local_port
    if natreflection is not None:
        body["natreflection"] = natreflection
    if nordr is not None:
        body["nordr"] = nordr
    if nosync is not None:
        body["nosync"] = nosync
    if protocol is not None:
        body["protocol"] = protocol
    if source is not None:
        body["source"] = source
    if source_port is not None:
        body["source_port"] = source_port
    if target is not None:
        body["target"] = target
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/nat/port_forward",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_port_forward(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/port_forward

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/port_forward. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/port_forward",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_nat_port_forwards(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/nat/port_forwards

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/nat/port_forwards",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_nat_port_forwards(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/nat/port_forwards

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/nat/port_forwards. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/nat/port_forwards",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_nat_port_forwards(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/nat/port_forwards

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/nat/port_forwards. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/nat/port_forwards",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_rule(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/rule

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/rule",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_rule(
    destination: str,
    interface: list[str],
    ipprotocol: str,
    source: str,
    type_: str,
    confirm: bool = False,
    ackqueue: str | None = None,
    defaultqueue: str | None = None,
    descr: str | None = None,
    destination_port: str | None = None,
    direction: str | None = None,
    disabled: bool | None = None,
    dnpipe: str | None = None,
    floating: bool | None = None,
    gateway: str | None = None,
    icmptype: list[str] | None = None,
    log: bool | None = None,
    pdnpipe: str | None = None,
    protocol: str | None = None,
    quick: bool | None = None,
    sched: str | None = None,
    source_port: str | None = None,
    statetype: str | None = 'keep state',
    tag: str | None = None,
    tcp_flags_any: bool | None = None,
    tcp_flags_out_of: list[str] | None = None,
    tcp_flags_set: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/rule

    Note: Call pfsense_firewall_apply after this to apply changes.

    destination: The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    interface: The interface where packets must originate to match this rule.
    ipprotocol: The IP version(s) this rule applies to. Valid values: ['inet', 'inet6', 'inet46']
    source: The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    type_: The action to take against traffic that matches this rule. Valid values: ['pass', 'block', 'reject']
    ackqueue: The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.
    defaultqueue: The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.
    descr: A description detailing the purpose or justification of this firewall rule.
    destination_port: The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    direction: The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.This field is only available when the following conditions are met:- `floating` must be equal to `true` Valid values: ['any', 'in', 'out']
    disabled: Enable or disable this firewall rule.
    dnpipe: The name of the traffic shaper limiter pipe or queue to use for incoming traffic.
    floating: Mark this rule as a floating firewall rule.
    gateway: The gateway traffic matching this rule will be routed to. Set to `null` to use default.
    icmptype: Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.This field is only available when the following conditions are met:- `protocol` must be equal to `'icmp'`
    log: Enable or disable logging of traffic that matches this rule.
    pdnpipe: The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.
    protocol: The IP/transport protocol this rule should match. Valid values: ['tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf', 'carp', 'pfsync']
    quick: Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.This field is only available when the following conditions are met:- `floating` must be equal to `true`
    sched: The name of an existing firewall schedule to assign to this firewall rule.
    source_port: The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    statetype: The state mechanism to use for this firewall rule. Valid values: ['keep state', 'sloppy state', 'synproxy state', 'none']
    tag: A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called
    tcp_flags_any: Allow any TCP flags.
    tcp_flags_out_of: The TCP flags that can be set for this rule to match.This field is only available when the following conditions are met:- `tcp_flags_any` must be equal to `false`
    tcp_flags_set: The TCP flags that must be set for this rule to match.This field is only available when the following conditions are met:- `tcp_flags_any` must be equal to `false`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/rule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if destination is not None:
        body["destination"] = destination
    if interface is not None:
        body["interface"] = interface
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if source is not None:
        body["source"] = source
    if type_ is not None:
        body["type"] = type_
    if ackqueue is not None:
        body["ackqueue"] = ackqueue
    if defaultqueue is not None:
        body["defaultqueue"] = defaultqueue
    if descr is not None:
        body["descr"] = descr
    if destination_port is not None:
        body["destination_port"] = destination_port
    if direction is not None:
        body["direction"] = direction
    if disabled is not None:
        body["disabled"] = disabled
    if dnpipe is not None:
        body["dnpipe"] = dnpipe
    if floating is not None:
        body["floating"] = floating
    if gateway is not None:
        body["gateway"] = gateway
    if icmptype is not None:
        body["icmptype"] = icmptype
    if log is not None:
        body["log"] = log
    if pdnpipe is not None:
        body["pdnpipe"] = pdnpipe
    if protocol is not None:
        body["protocol"] = protocol
    if quick is not None:
        body["quick"] = quick
    if sched is not None:
        body["sched"] = sched
    if source_port is not None:
        body["source_port"] = source_port
    if statetype is not None:
        body["statetype"] = statetype
    if tag is not None:
        body["tag"] = tag
    if tcp_flags_any is not None:
        body["tcp_flags_any"] = tcp_flags_any
    if tcp_flags_out_of is not None:
        body["tcp_flags_out_of"] = tcp_flags_out_of
    if tcp_flags_set is not None:
        body["tcp_flags_set"] = tcp_flags_set
    return await _client.request(
        "POST",
        "/api/v2/firewall/rule",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_rule(
    id: str | int,
    confirm: bool = False,
    ackqueue: str | None = None,
    defaultqueue: str | None = None,
    descr: str | None = None,
    destination: str | None = None,
    destination_port: str | None = None,
    direction: str | None = None,
    disabled: bool | None = None,
    dnpipe: str | None = None,
    floating: bool | None = None,
    gateway: str | None = None,
    icmptype: list[str] | None = None,
    interface: list[str] | None = None,
    ipprotocol: str | None = None,
    log: bool | None = None,
    pdnpipe: str | None = None,
    protocol: str | None = None,
    quick: bool | None = None,
    sched: str | None = None,
    source: str | None = None,
    source_port: str | None = None,
    statetype: str | None = None,
    tag: str | None = None,
    tcp_flags_any: bool | None = None,
    tcp_flags_out_of: list[str] | None = None,
    tcp_flags_set: list[str] | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/rule

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    ackqueue: The name of the traffic shaper queue to assume as the ACK queue for ACK traffic matching this rule.
    defaultqueue: The name of the traffic shaper queue to assume as the default queue for traffic matching this rule.
    descr: A description detailing the purpose or justification of this firewall rule.
    destination: The destination address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    destination_port: The destination port this rule applies to. Set to `null` to allow any destination port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    direction: The direction of traffic this firewall rule applies to. This field only applies to floating firewall rules.This field is only available when the following conditions are met:- `floating` must be equal to `true` Valid values: ['any', 'in', 'out']
    disabled: Enable or disable this firewall rule.
    dnpipe: The name of the traffic shaper limiter pipe or queue to use for incoming traffic.
    floating: Mark this rule as a floating firewall rule.
    gateway: The gateway traffic matching this rule will be routed to. Set to `null` to use default.
    icmptype: Th ICMP subtypes this rule applies to. This field is only applicable when `ipprotocol` is `inet` and `protocol` is `icmp`.This field is only available when the following conditions are met:- `protocol` must be equal to `'icmp'`
    interface: The interface where packets must originate to match this rule.
    ipprotocol: The IP version(s) this rule applies to. Valid values: ['inet', 'inet6', 'inet46']
    log: Enable or disable logging of traffic that matches this rule.
    pdnpipe: The name of the traffic shaper limiter pipe or queue to use for outgoing traffic.
    protocol: The IP/transport protocol this rule should match. Valid values: ['tcp', 'udp', 'tcp/udp', 'icmp', 'esp', 'ah', 'gre', 'ipv6', 'igmp', 'pim', 'ospf', 'carp', 'pfsync']
    quick: Apply this action to traffic that matches this rule immediately. This field only applies to floating firewall rules.This field is only available when the following conditions are met:- `floating` must be equal to `true`
    sched: The name of an existing firewall schedule to assign to this firewall rule.
    source: The source address this rule applies to. Valid value options are: an existing interface, an IP address, a subnet CIDR, an existing alias, `any`, `(self)`, `l2tp`, `pppoe`. The context of this address can be inverted by prefixing the value with `!`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.
    source_port: The source port this rule applies to. Set to `null` to allow any source port. Valid options are: a TCP/UDP port number, a TCP/UDP port range separated by `:`, an existing port type firewall aliasThis field is only available when the following conditions are met:- `protocol` must be one of [ tcp, udp, tcp/udp ]
    statetype: The state mechanism to use for this firewall rule. Valid values: ['keep state', 'sloppy state', 'synproxy state', 'none']
    tag: A packet matching this rule can be marked and this mark used to match on other NAT/filter rules. It is called
    tcp_flags_any: Allow any TCP flags.
    tcp_flags_out_of: The TCP flags that can be set for this rule to match.This field is only available when the following conditions are met:- `tcp_flags_any` must be equal to `false`
    tcp_flags_set: The TCP flags that must be set for this rule to match.This field is only available when the following conditions are met:- `tcp_flags_any` must be equal to `false`
    type_: The action to take against traffic that matches this rule. Valid values: ['pass', 'block', 'reject']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/rule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if ackqueue is not None:
        body["ackqueue"] = ackqueue
    if defaultqueue is not None:
        body["defaultqueue"] = defaultqueue
    if descr is not None:
        body["descr"] = descr
    if destination is not None:
        body["destination"] = destination
    if destination_port is not None:
        body["destination_port"] = destination_port
    if direction is not None:
        body["direction"] = direction
    if disabled is not None:
        body["disabled"] = disabled
    if dnpipe is not None:
        body["dnpipe"] = dnpipe
    if floating is not None:
        body["floating"] = floating
    if gateway is not None:
        body["gateway"] = gateway
    if icmptype is not None:
        body["icmptype"] = icmptype
    if interface is not None:
        body["interface"] = interface
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if log is not None:
        body["log"] = log
    if pdnpipe is not None:
        body["pdnpipe"] = pdnpipe
    if protocol is not None:
        body["protocol"] = protocol
    if quick is not None:
        body["quick"] = quick
    if sched is not None:
        body["sched"] = sched
    if source is not None:
        body["source"] = source
    if source_port is not None:
        body["source_port"] = source_port
    if statetype is not None:
        body["statetype"] = statetype
    if tag is not None:
        body["tag"] = tag
    if tcp_flags_any is not None:
        body["tcp_flags_any"] = tcp_flags_any
    if tcp_flags_out_of is not None:
        body["tcp_flags_out_of"] = tcp_flags_out_of
    if tcp_flags_set is not None:
        body["tcp_flags_set"] = tcp_flags_set
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/rule",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_rule(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/rule

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/rule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/rule",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_rules(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/rules

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/rules",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_rules(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/rules

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/rules. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/rules",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_rules(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/rules

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/rules. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/rules",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_schedule(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/schedule

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/schedule",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_schedule(
    name: str,
    timerange: list[dict[str, Any]],
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/schedule

    Note: Call pfsense_firewall_apply after this to apply changes.

    name: The unique name to assign this schedule.
    timerange: The date/times this firewall schedule will be active.
    descr: A description of this schedules purpose.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/schedule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if timerange is not None:
        body["timerange"] = timerange
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/firewall/schedule",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_schedule(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    name: str | None = None,
    timerange: list[dict[str, Any]] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/schedule

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description of this schedules purpose.
    name: The unique name to assign this schedule.
    timerange: The date/times this firewall schedule will be active.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/schedule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if name is not None:
        body["name"] = name
    if timerange is not None:
        body["timerange"] = timerange
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/schedule",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_schedule(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/schedule

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/schedule. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/schedule",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_schedule_time_range(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/schedule/time_range

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/firewall/schedule/time_range",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_schedule_time_range(
    hour: str,
    parent_id: str | int,
    confirm: bool = False,
    day: list[int] | None = None,
    month: list[int] | None = None,
    position: list[int] | None = None,
    rangedescr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/schedule/time_range

    Note: Call pfsense_firewall_apply after this to apply changes.

    hour: The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).
    parent_id: The ID of the parent this object is nested under.
    day: The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.This field is only available when the following conditions are met:- `position` must be equal to `NULL`
    month: The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.This field is only available when the following conditions are met:- `position` must be equal to `NULL`
    position: The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.
    rangedescr: A description detailing this firewall schedule time range's purpose.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/schedule/time_range. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if hour is not None:
        body["hour"] = hour
    if parent_id is not None:
        body["parent_id"] = parent_id
    if day is not None:
        body["day"] = day
    if month is not None:
        body["month"] = month
    if position is not None:
        body["position"] = position
    if rangedescr is not None:
        body["rangedescr"] = rangedescr
    return await _client.request(
        "POST",
        "/api/v2/firewall/schedule/time_range",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_schedule_time_range(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    day: list[int] | None = None,
    hour: str | None = None,
    month: list[int] | None = None,
    position: list[int] | None = None,
    rangedescr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/schedule/time_range

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    day: The day for each specified `month` value. Each value specified must correspond with a `month` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.This field is only available when the following conditions are met:- `position` must be equal to `NULL`
    hour: The start time and end time for this time range in 24-hour format (i.e. HH:MM-HH:MM).
    month: The month for each specified `day` value. Each value specified must correspond with a `day` field value and must match the order exactly. For example, a `month` value of `[3, 6]` and a `day` value of `[2, 17]` would evaluate to March 2nd and June 17th respectively.This field is only available when the following conditions are met:- `position` must be equal to `NULL`
    position: The day of the week this schedule should be active for. Use `1` for every Monday, `2` for every Tuesday, `3` for every Wednesday, `4` for every Thursday, `5` for every Friday, `6` for every Saturday, or `7` for every Sunday. If this field has a value specified, the `month` and `day` fields will be unavailable.
    rangedescr: A description detailing this firewall schedule time range's purpose.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/schedule/time_range. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if day is not None:
        body["day"] = day
    if hour is not None:
        body["hour"] = hour
    if month is not None:
        body["month"] = month
    if position is not None:
        body["position"] = position
    if rangedescr is not None:
        body["rangedescr"] = rangedescr
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/schedule/time_range",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_schedule_time_range(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/schedule/time_range

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/schedule/time_range. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/schedule/time_range",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_schedule_time_ranges(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/schedule/time_ranges

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/schedule/time_ranges",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_schedule_time_ranges(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/schedule/time_ranges

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/schedule/time_ranges. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/schedule/time_ranges",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_schedules(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/schedules

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/schedules",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_schedules(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/schedules

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/schedules. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/schedules",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_schedules(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/schedules

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/schedules. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/schedules",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_state(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/state

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/state",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_state(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/state

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/state. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/state",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_states(
    limit: int | None = 100,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/states

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/states",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_states(
    confirm: bool = False,
    limit: int | None = 100,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/states

    WARNING: DANGEROUS: Clears all firewall states.

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/states. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Clears all firewall states."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/states",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_states_size(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/states/size
    """
    return await _client.request(
        "GET",
        "/api/v2/firewall/states/size",
    )


@mcp.tool()
async def pfsense_update_firewall_states_size(
    confirm: bool = False,
    maximumstates: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/states/size

    Note: Call pfsense_firewall_apply after this to apply changes.

    maximumstates: The maximum number of firewall state entries allowed by this firewall.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/states/size. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if maximumstates is not None:
        body["maximumstates"] = maximumstates
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/states/size",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_firewall_traffic_shaper(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_traffic_shaper(
    bandwidth: int,
    bandwidthtype: str,
    interface: str,
    scheduler: str,
    confirm: bool = False,
    enabled: bool | None = True,
    qlimit: int | None = None,
    queue: list[dict[str, Any]] | None = None,
    tbrconfig: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/traffic_shaper

    Note: Call pfsense_firewall_apply after this to apply changes.

    bandwidth: The total bandwidth amount allowed by this traffic shaper.
    bandwidthtype: The scale type of the `bandwidth` field's value. Valid values: ['%', 'b', 'Kb', 'Mb', 'Gb']
    interface: The interface this traffic shaper will be applied to.
    scheduler: The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper. Valid values: ['HFSC', 'CBQ', 'FAIRQ', 'CODELQ', 'PRIQ']
    enabled: Enables or disables this traffic shaper.
    qlimit: The number of packets that can be held in a queue waiting to be transmitted by the shaper.This field is only available when the following conditions are met:- `scheduler` must not be one of [ CODELQ ]
    queue: The child queues assigned to this traffic shaper.
    tbrconfig: The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/traffic_shaper. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if bandwidthtype is not None:
        body["bandwidthtype"] = bandwidthtype
    if interface is not None:
        body["interface"] = interface
    if scheduler is not None:
        body["scheduler"] = scheduler
    if enabled is not None:
        body["enabled"] = enabled
    if qlimit is not None:
        body["qlimit"] = qlimit
    if queue is not None:
        body["queue"] = queue
    if tbrconfig is not None:
        body["tbrconfig"] = tbrconfig
    return await _client.request(
        "POST",
        "/api/v2/firewall/traffic_shaper",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_traffic_shaper(
    id: str | int,
    confirm: bool = False,
    bandwidth: int | None = None,
    bandwidthtype: str | None = None,
    enabled: bool | None = None,
    interface: str | None = None,
    qlimit: int | None = None,
    queue: list[dict[str, Any]] | None = None,
    scheduler: str | None = None,
    tbrconfig: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/traffic_shaper

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    bandwidth: The total bandwidth amount allowed by this traffic shaper.
    bandwidthtype: The scale type of the `bandwidth` field's value. Valid values: ['%', 'b', 'Kb', 'Mb', 'Gb']
    enabled: Enables or disables this traffic shaper.
    interface: The interface this traffic shaper will be applied to.
    qlimit: The number of packets that can be held in a queue waiting to be transmitted by the shaper.This field is only available when the following conditions are met:- `scheduler` must not be one of [ CODELQ ]
    queue: The child queues assigned to this traffic shaper.
    scheduler: The scheduler type to use for this traffic shaper. Changing this value will automatically update any child queues assigned to this traffic shaper. Valid values: ['HFSC', 'CBQ', 'FAIRQ', 'CODELQ', 'PRIQ']
    tbrconfig: The size, in bytes, of the token bucket regulator. If `null`, heuristics based on the interface bandwidth are used to determine the size.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/traffic_shaper. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if bandwidthtype is not None:
        body["bandwidthtype"] = bandwidthtype
    if enabled is not None:
        body["enabled"] = enabled
    if interface is not None:
        body["interface"] = interface
    if qlimit is not None:
        body["qlimit"] = qlimit
    if queue is not None:
        body["queue"] = queue
    if scheduler is not None:
        body["scheduler"] = scheduler
    if tbrconfig is not None:
        body["tbrconfig"] = tbrconfig
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/traffic_shaper",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_traffic_shaper_limiter_bandwidth(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiter/bandwidth

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_traffic_shaper_limiter_bandwidth(
    bw: int,
    bwscale: str,
    parent_id: str | int,
    confirm: bool = False,
    bwsched: str | None = 'none',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/traffic_shaper/limiter/bandwidth

    Note: Call pfsense_firewall_apply after this to apply changes.

    bw: The amount of bandwidth this profile allows.
    bwscale: The scale factor of the `bw` fields value. Valid values: ['b', 'Kb', 'Mb']
    parent_id: The ID of the parent this object is nested under.
    bwsched: The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/traffic_shaper/limiter/bandwidth. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if bw is not None:
        body["bw"] = bw
    if bwscale is not None:
        body["bwscale"] = bwscale
    if parent_id is not None:
        body["parent_id"] = parent_id
    if bwsched is not None:
        body["bwsched"] = bwsched
    return await _client.request(
        "POST",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_traffic_shaper_limiter_bandwidth(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    bw: int | None = None,
    bwscale: str | None = None,
    bwsched: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/traffic_shaper/limiter/bandwidth

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    bw: The amount of bandwidth this profile allows.
    bwscale: The scale factor of the `bw` fields value. Valid values: ['b', 'Kb', 'Mb']
    bwsched: The schedule to assign this bandwidth profile. When this firewall schedule is active, this bandwidth profile will be used.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/traffic_shaper/limiter/bandwidth. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if bw is not None:
        body["bw"] = bw
    if bwscale is not None:
        body["bwscale"] = bwscale
    if bwsched is not None:
        body["bwsched"] = bwsched
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_limiter_bandwidth(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/limiter/bandwidth

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/limiter/bandwidth. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidth",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_traffic_shaper_limiter_bandwidths(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiter/bandwidths

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidths",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_limiter_bandwidths(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/limiter/bandwidths

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/limiter/bandwidths. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/limiter/bandwidths",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_traffic_shaper_limiter(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiter

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiter",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_traffic_shaper_limiter(
    aqm: str,
    name: str,
    sched: str,
    confirm: bool = False,
    bandwidth: list[dict[str, Any]] | None = None,
    buckets: int | None = None,
    delay: int | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    mask: str | None = 'none',
    maskbits: int | None = None,
    maskbitsv6: int | None = None,
    param_codel_interval: int | None = None,
    param_codel_target: int | None = None,
    param_fq_codel_flows: int | None = None,
    param_fq_codel_interval: int | None = None,
    param_fq_codel_limit: int | None = None,
    param_fq_codel_quantum: int | None = None,
    param_fq_codel_target: int | None = None,
    param_fq_pie_alpha: int | None = None,
    param_fq_pie_beta: int | None = None,
    param_fq_pie_flows: int | None = None,
    param_fq_pie_limit: int | None = None,
    param_fq_pie_max_burst: int | None = None,
    param_fq_pie_max_ecnth: int | None = None,
    param_fq_pie_quantum: int | None = None,
    param_fq_pie_target: int | None = None,
    param_fq_pie_tupdate: int | None = None,
    param_gred_max_p: int | None = None,
    param_gred_max_th: int | None = None,
    param_gred_min_th: int | None = None,
    param_gred_w_q: int | None = None,
    param_pie_alpha: int | None = None,
    param_pie_beta: int | None = None,
    param_pie_max_burst: int | None = None,
    param_pie_max_ecnth: int | None = None,
    param_pie_target: int | None = None,
    param_pie_tupdate: int | None = None,
    param_red_max_p: int | None = None,
    param_red_max_th: int | None = None,
    param_red_min_th: int | None = None,
    param_red_w_q: int | None = None,
    pie_capdrop: bool | None = None,
    pie_onoff: bool | None = None,
    pie_pderand: bool | None = None,
    pie_qdelay: bool | None = None,
    plr: float | None = None,
    qlimit: int | None = None,
    queue: list[dict[str, Any]] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/traffic_shaper/limiter

    Note: Call pfsense_firewall_apply after this to apply changes.

    aqm: The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion. Valid values: ['droptail', 'codel', 'pie', 'red', 'gred']
    name: The unique name for this limiter.
    sched: The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue. Valid values: ['wf2q+', 'fifo', 'qfq', 'rr', 'prio', 'fq_codel', 'fq_pie']
    bandwidth: The bandwidth profiles for this limiter.
    buckets: The limiter's bucket size (slots).
    delay: The amount of delay (in milliseconds) added to traffic passing through this limiter.
    description: The verbose description for this limiter.
    ecn: Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.This field is only available when the following conditions are met:- `aqm` must be one of [ codel, pie, red, gred ]- `sched` must be one of [ fq_codel, fq_pie ]
    enabled: Enables or disables this limiter and its child queues.
    mask: If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet. Valid values: ['none', 'srcaddress', 'dstaddress']
    maskbits: The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    maskbitsv6: The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    param_codel_interval: The value for the CoDel interval parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_codel_target: The value for the CoDel target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_fq_codel_flows: The value for the FQ CoDel flows parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_interval: The value for the FQ CoDel interval parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_limit: The value for the FQ CoDel limit parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_quantum: The value for the FQ CoDel quantum parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_target: The value for the FQ CoDel target parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_pie_alpha: The value for the FQ PIE alpha parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_beta: The value for the FQ PIE beta parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_flows: The value for the FQ PIE flows parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_limit: The value for the FQ PIE limit parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_max_burst: The value for the FQ PIE max_burst parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_max_ecnth: The value for the FQ PIE ecnth parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_quantum: The value for the FQ PIE quantum parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_target: The value for the FQ PIE target parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_tupdate: The value for the FQ PIE tupdate parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_gred_max_p: The value for the GRED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_max_th: The value for the GRED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_min_th: The value for the GRED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_w_q: The value for the GRED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_pie_alpha: The value for the PIE alpha parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_beta: The value for the PIE beta parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_burst: The value for the PIE max_burst parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_ecnth: The value for the PIE ecnth parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_target: The value for the PIE target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_tupdate: The value for the PIE tupdate parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_red_max_p: The value for the RED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_max_th: The value for the RED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_min_th: The value for the RED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_w_q: The value for the RED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    pie_capdrop: Enable or disable cap drop adjustment.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_onoff: Enable or disable turning PIE on and off depending on queue load.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_pderand: Enable or disable drop probability de-randomisation.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_qdelay: Set queue delay type to timestamps (true) or departure rate estimation (false).This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    plr: The amount of packet loss (in percentage) added to traffic passing through the limiter.
    qlimit: The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.
    queue: The child queues for this limiter.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/traffic_shaper/limiter. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if aqm is not None:
        body["aqm"] = aqm
    if name is not None:
        body["name"] = name
    if sched is not None:
        body["sched"] = sched
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if buckets is not None:
        body["buckets"] = buckets
    if delay is not None:
        body["delay"] = delay
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if mask is not None:
        body["mask"] = mask
    if maskbits is not None:
        body["maskbits"] = maskbits
    if maskbitsv6 is not None:
        body["maskbitsv6"] = maskbitsv6
    if param_codel_interval is not None:
        body["param_codel_interval"] = param_codel_interval
    if param_codel_target is not None:
        body["param_codel_target"] = param_codel_target
    if param_fq_codel_flows is not None:
        body["param_fq_codel_flows"] = param_fq_codel_flows
    if param_fq_codel_interval is not None:
        body["param_fq_codel_interval"] = param_fq_codel_interval
    if param_fq_codel_limit is not None:
        body["param_fq_codel_limit"] = param_fq_codel_limit
    if param_fq_codel_quantum is not None:
        body["param_fq_codel_quantum"] = param_fq_codel_quantum
    if param_fq_codel_target is not None:
        body["param_fq_codel_target"] = param_fq_codel_target
    if param_fq_pie_alpha is not None:
        body["param_fq_pie_alpha"] = param_fq_pie_alpha
    if param_fq_pie_beta is not None:
        body["param_fq_pie_beta"] = param_fq_pie_beta
    if param_fq_pie_flows is not None:
        body["param_fq_pie_flows"] = param_fq_pie_flows
    if param_fq_pie_limit is not None:
        body["param_fq_pie_limit"] = param_fq_pie_limit
    if param_fq_pie_max_burst is not None:
        body["param_fq_pie_max_burst"] = param_fq_pie_max_burst
    if param_fq_pie_max_ecnth is not None:
        body["param_fq_pie_max_ecnth"] = param_fq_pie_max_ecnth
    if param_fq_pie_quantum is not None:
        body["param_fq_pie_quantum"] = param_fq_pie_quantum
    if param_fq_pie_target is not None:
        body["param_fq_pie_target"] = param_fq_pie_target
    if param_fq_pie_tupdate is not None:
        body["param_fq_pie_tupdate"] = param_fq_pie_tupdate
    if param_gred_max_p is not None:
        body["param_gred_max_p"] = param_gred_max_p
    if param_gred_max_th is not None:
        body["param_gred_max_th"] = param_gred_max_th
    if param_gred_min_th is not None:
        body["param_gred_min_th"] = param_gred_min_th
    if param_gred_w_q is not None:
        body["param_gred_w_q"] = param_gred_w_q
    if param_pie_alpha is not None:
        body["param_pie_alpha"] = param_pie_alpha
    if param_pie_beta is not None:
        body["param_pie_beta"] = param_pie_beta
    if param_pie_max_burst is not None:
        body["param_pie_max_burst"] = param_pie_max_burst
    if param_pie_max_ecnth is not None:
        body["param_pie_max_ecnth"] = param_pie_max_ecnth
    if param_pie_target is not None:
        body["param_pie_target"] = param_pie_target
    if param_pie_tupdate is not None:
        body["param_pie_tupdate"] = param_pie_tupdate
    if param_red_max_p is not None:
        body["param_red_max_p"] = param_red_max_p
    if param_red_max_th is not None:
        body["param_red_max_th"] = param_red_max_th
    if param_red_min_th is not None:
        body["param_red_min_th"] = param_red_min_th
    if param_red_w_q is not None:
        body["param_red_w_q"] = param_red_w_q
    if pie_capdrop is not None:
        body["pie_capdrop"] = pie_capdrop
    if pie_onoff is not None:
        body["pie_onoff"] = pie_onoff
    if pie_pderand is not None:
        body["pie_pderand"] = pie_pderand
    if pie_qdelay is not None:
        body["pie_qdelay"] = pie_qdelay
    if plr is not None:
        body["plr"] = plr
    if qlimit is not None:
        body["qlimit"] = qlimit
    if queue is not None:
        body["queue"] = queue
    return await _client.request(
        "POST",
        "/api/v2/firewall/traffic_shaper/limiter",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_traffic_shaper_limiter(
    id: str | int,
    confirm: bool = False,
    aqm: str | None = None,
    bandwidth: list[dict[str, Any]] | None = None,
    buckets: int | None = None,
    delay: int | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    mask: str | None = None,
    maskbits: int | None = None,
    maskbitsv6: int | None = None,
    name: str | None = None,
    param_codel_interval: int | None = None,
    param_codel_target: int | None = None,
    param_fq_codel_flows: int | None = None,
    param_fq_codel_interval: int | None = None,
    param_fq_codel_limit: int | None = None,
    param_fq_codel_quantum: int | None = None,
    param_fq_codel_target: int | None = None,
    param_fq_pie_alpha: int | None = None,
    param_fq_pie_beta: int | None = None,
    param_fq_pie_flows: int | None = None,
    param_fq_pie_limit: int | None = None,
    param_fq_pie_max_burst: int | None = None,
    param_fq_pie_max_ecnth: int | None = None,
    param_fq_pie_quantum: int | None = None,
    param_fq_pie_target: int | None = None,
    param_fq_pie_tupdate: int | None = None,
    param_gred_max_p: int | None = None,
    param_gred_max_th: int | None = None,
    param_gred_min_th: int | None = None,
    param_gred_w_q: int | None = None,
    param_pie_alpha: int | None = None,
    param_pie_beta: int | None = None,
    param_pie_max_burst: int | None = None,
    param_pie_max_ecnth: int | None = None,
    param_pie_target: int | None = None,
    param_pie_tupdate: int | None = None,
    param_red_max_p: int | None = None,
    param_red_max_th: int | None = None,
    param_red_min_th: int | None = None,
    param_red_w_q: int | None = None,
    pie_capdrop: bool | None = None,
    pie_onoff: bool | None = None,
    pie_pderand: bool | None = None,
    pie_qdelay: bool | None = None,
    plr: float | None = None,
    qlimit: int | None = None,
    queue: list[dict[str, Any]] | None = None,
    sched: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/traffic_shaper/limiter

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    aqm: The Active Queue Management (AQM) algorithm to use for this limiter. AQM is the intelligent drop of network packets inside the limiter, when it becomes full or gets close to becoming full, with the goal of reducing network congestion. Valid values: ['droptail', 'codel', 'pie', 'red', 'gred']
    bandwidth: The bandwidth profiles for this limiter.
    buckets: The limiter's bucket size (slots).
    delay: The amount of delay (in milliseconds) added to traffic passing through this limiter.
    description: The verbose description for this limiter.
    ecn: Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.This field is only available when the following conditions are met:- `aqm` must be one of [ codel, pie, red, gred ]- `sched` must be one of [ fq_codel, fq_pie ]
    enabled: Enables or disables this limiter and its child queues.
    mask: If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet. Valid values: ['none', 'srcaddress', 'dstaddress']
    maskbits: The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    maskbitsv6: The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    name: The unique name for this limiter.
    param_codel_interval: The value for the CoDel interval parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_codel_target: The value for the CoDel target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_fq_codel_flows: The value for the FQ CoDel flows parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_interval: The value for the FQ CoDel interval parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_limit: The value for the FQ CoDel limit parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_quantum: The value for the FQ CoDel quantum parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_codel_target: The value for the FQ CoDel target parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_codel'`
    param_fq_pie_alpha: The value for the FQ PIE alpha parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_beta: The value for the FQ PIE beta parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_flows: The value for the FQ PIE flows parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_limit: The value for the FQ PIE limit parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_max_burst: The value for the FQ PIE max_burst parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_max_ecnth: The value for the FQ PIE ecnth parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_quantum: The value for the FQ PIE quantum parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_target: The value for the FQ PIE target parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_fq_pie_tupdate: The value for the FQ PIE tupdate parameter.This field is only available when the following conditions are met:- `sched` must be equal to `'fq_pie'`
    param_gred_max_p: The value for the GRED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_max_th: The value for the GRED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_min_th: The value for the GRED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_w_q: The value for the GRED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_pie_alpha: The value for the PIE alpha parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_beta: The value for the PIE beta parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_burst: The value for the PIE max_burst parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_ecnth: The value for the PIE ecnth parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_target: The value for the PIE target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_tupdate: The value for the PIE tupdate parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_red_max_p: The value for the RED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_max_th: The value for the RED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_min_th: The value for the RED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_w_q: The value for the RED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    pie_capdrop: Enable or disable cap drop adjustment.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_onoff: Enable or disable turning PIE on and off depending on queue load.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_pderand: Enable or disable drop probability de-randomisation.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_qdelay: Set queue delay type to timestamps (true) or departure rate estimation (false).This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    plr: The amount of packet loss (in percentage) added to traffic passing through the limiter.
    qlimit: The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.
    queue: The child queues for this limiter.
    sched: The scheduler to use for this limiter. The scheduler manages the sequence of network packets in the limiter's queue. Valid values: ['wf2q+', 'fifo', 'qfq', 'rr', 'prio', 'fq_codel', 'fq_pie']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/traffic_shaper/limiter. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if aqm is not None:
        body["aqm"] = aqm
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if buckets is not None:
        body["buckets"] = buckets
    if delay is not None:
        body["delay"] = delay
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if mask is not None:
        body["mask"] = mask
    if maskbits is not None:
        body["maskbits"] = maskbits
    if maskbitsv6 is not None:
        body["maskbitsv6"] = maskbitsv6
    if name is not None:
        body["name"] = name
    if param_codel_interval is not None:
        body["param_codel_interval"] = param_codel_interval
    if param_codel_target is not None:
        body["param_codel_target"] = param_codel_target
    if param_fq_codel_flows is not None:
        body["param_fq_codel_flows"] = param_fq_codel_flows
    if param_fq_codel_interval is not None:
        body["param_fq_codel_interval"] = param_fq_codel_interval
    if param_fq_codel_limit is not None:
        body["param_fq_codel_limit"] = param_fq_codel_limit
    if param_fq_codel_quantum is not None:
        body["param_fq_codel_quantum"] = param_fq_codel_quantum
    if param_fq_codel_target is not None:
        body["param_fq_codel_target"] = param_fq_codel_target
    if param_fq_pie_alpha is not None:
        body["param_fq_pie_alpha"] = param_fq_pie_alpha
    if param_fq_pie_beta is not None:
        body["param_fq_pie_beta"] = param_fq_pie_beta
    if param_fq_pie_flows is not None:
        body["param_fq_pie_flows"] = param_fq_pie_flows
    if param_fq_pie_limit is not None:
        body["param_fq_pie_limit"] = param_fq_pie_limit
    if param_fq_pie_max_burst is not None:
        body["param_fq_pie_max_burst"] = param_fq_pie_max_burst
    if param_fq_pie_max_ecnth is not None:
        body["param_fq_pie_max_ecnth"] = param_fq_pie_max_ecnth
    if param_fq_pie_quantum is not None:
        body["param_fq_pie_quantum"] = param_fq_pie_quantum
    if param_fq_pie_target is not None:
        body["param_fq_pie_target"] = param_fq_pie_target
    if param_fq_pie_tupdate is not None:
        body["param_fq_pie_tupdate"] = param_fq_pie_tupdate
    if param_gred_max_p is not None:
        body["param_gred_max_p"] = param_gred_max_p
    if param_gred_max_th is not None:
        body["param_gred_max_th"] = param_gred_max_th
    if param_gred_min_th is not None:
        body["param_gred_min_th"] = param_gred_min_th
    if param_gred_w_q is not None:
        body["param_gred_w_q"] = param_gred_w_q
    if param_pie_alpha is not None:
        body["param_pie_alpha"] = param_pie_alpha
    if param_pie_beta is not None:
        body["param_pie_beta"] = param_pie_beta
    if param_pie_max_burst is not None:
        body["param_pie_max_burst"] = param_pie_max_burst
    if param_pie_max_ecnth is not None:
        body["param_pie_max_ecnth"] = param_pie_max_ecnth
    if param_pie_target is not None:
        body["param_pie_target"] = param_pie_target
    if param_pie_tupdate is not None:
        body["param_pie_tupdate"] = param_pie_tupdate
    if param_red_max_p is not None:
        body["param_red_max_p"] = param_red_max_p
    if param_red_max_th is not None:
        body["param_red_max_th"] = param_red_max_th
    if param_red_min_th is not None:
        body["param_red_min_th"] = param_red_min_th
    if param_red_w_q is not None:
        body["param_red_w_q"] = param_red_w_q
    if pie_capdrop is not None:
        body["pie_capdrop"] = pie_capdrop
    if pie_onoff is not None:
        body["pie_onoff"] = pie_onoff
    if pie_pderand is not None:
        body["pie_pderand"] = pie_pderand
    if pie_qdelay is not None:
        body["pie_qdelay"] = pie_qdelay
    if plr is not None:
        body["plr"] = plr
    if qlimit is not None:
        body["qlimit"] = qlimit
    if queue is not None:
        body["queue"] = queue
    if sched is not None:
        body["sched"] = sched
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/traffic_shaper/limiter",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_limiter(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/limiter

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/limiter. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/limiter",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_traffic_shaper_limiter_queue(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiter/queue

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiter/queue",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_traffic_shaper_limiter_queue(
    aqm: str,
    name: str,
    parent_id: str | int,
    confirm: bool = False,
    buckets: int | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    mask: str | None = 'none',
    maskbits: int | None = None,
    maskbitsv6: int | None = None,
    param_codel_interval: int | None = None,
    param_codel_target: int | None = None,
    param_gred_max_p: int | None = None,
    param_gred_max_th: int | None = None,
    param_gred_min_th: int | None = None,
    param_gred_w_q: int | None = None,
    param_pie_alpha: int | None = None,
    param_pie_beta: int | None = None,
    param_pie_max_burst: int | None = None,
    param_pie_max_ecnth: int | None = None,
    param_pie_target: int | None = None,
    param_pie_tupdate: int | None = None,
    param_red_max_p: int | None = None,
    param_red_max_th: int | None = None,
    param_red_min_th: int | None = None,
    param_red_w_q: int | None = None,
    pie_capdrop: bool | None = None,
    pie_onoff: bool | None = None,
    pie_pderand: bool | None = None,
    pie_qdelay: bool | None = None,
    plr: float | None = None,
    qlimit: int | None = None,
    weight: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/traffic_shaper/limiter/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    aqm: The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion. Valid values: ['droptail', 'codel', 'pie', 'red', 'gred']
    name: The unique name for this limiter queue.
    parent_id: The ID of the parent this object is nested under.
    buckets: The limiter queue's bucket size (slots).
    description: The verbose description for this limiter queue.
    ecn: Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.This field is only available when the following conditions are met:- `aqm` must be one of [ codel, pie, red, gred ]- `sched` must be one of [ fq_codel, fq_pie ]
    enabled: Enables or disables this limiter queue.
    mask: If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet. Valid values: ['none', 'srcaddress', 'dstaddress']
    maskbits: The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    maskbitsv6: The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    param_codel_interval: The value for the CoDel interval parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_codel_target: The value for the CoDel target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_gred_max_p: The value for the GRED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_max_th: The value for the GRED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_min_th: The value for the GRED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_w_q: The value for the GRED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_pie_alpha: The value for the PIE alpha parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_beta: The value for the PIE beta parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_burst: The value for the PIE max_burst parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_ecnth: The value for the PIE ecnth parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_target: The value for the PIE target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_tupdate: The value for the PIE tupdate parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_red_max_p: The value for the RED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_max_th: The value for the RED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_min_th: The value for the RED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_w_q: The value for the RED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    pie_capdrop: Enable or disable cap drop adjustment.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_onoff: Enable or disable turning PIE on and off depending on queue load.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_pderand: Enable or disable drop probability de-randomisation.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_qdelay: Set queue delay type to timestamps (true) or departure rate estimation (false).This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    plr: The amount of packet loss (in percentage) added to traffic passing through this limiter queue.
    qlimit: The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.
    weight: The share of the parent limiter this queue gets.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/traffic_shaper/limiter/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if aqm is not None:
        body["aqm"] = aqm
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if buckets is not None:
        body["buckets"] = buckets
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if mask is not None:
        body["mask"] = mask
    if maskbits is not None:
        body["maskbits"] = maskbits
    if maskbitsv6 is not None:
        body["maskbitsv6"] = maskbitsv6
    if param_codel_interval is not None:
        body["param_codel_interval"] = param_codel_interval
    if param_codel_target is not None:
        body["param_codel_target"] = param_codel_target
    if param_gred_max_p is not None:
        body["param_gred_max_p"] = param_gred_max_p
    if param_gred_max_th is not None:
        body["param_gred_max_th"] = param_gred_max_th
    if param_gred_min_th is not None:
        body["param_gred_min_th"] = param_gred_min_th
    if param_gred_w_q is not None:
        body["param_gred_w_q"] = param_gred_w_q
    if param_pie_alpha is not None:
        body["param_pie_alpha"] = param_pie_alpha
    if param_pie_beta is not None:
        body["param_pie_beta"] = param_pie_beta
    if param_pie_max_burst is not None:
        body["param_pie_max_burst"] = param_pie_max_burst
    if param_pie_max_ecnth is not None:
        body["param_pie_max_ecnth"] = param_pie_max_ecnth
    if param_pie_target is not None:
        body["param_pie_target"] = param_pie_target
    if param_pie_tupdate is not None:
        body["param_pie_tupdate"] = param_pie_tupdate
    if param_red_max_p is not None:
        body["param_red_max_p"] = param_red_max_p
    if param_red_max_th is not None:
        body["param_red_max_th"] = param_red_max_th
    if param_red_min_th is not None:
        body["param_red_min_th"] = param_red_min_th
    if param_red_w_q is not None:
        body["param_red_w_q"] = param_red_w_q
    if pie_capdrop is not None:
        body["pie_capdrop"] = pie_capdrop
    if pie_onoff is not None:
        body["pie_onoff"] = pie_onoff
    if pie_pderand is not None:
        body["pie_pderand"] = pie_pderand
    if pie_qdelay is not None:
        body["pie_qdelay"] = pie_qdelay
    if plr is not None:
        body["plr"] = plr
    if qlimit is not None:
        body["qlimit"] = qlimit
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "POST",
        "/api/v2/firewall/traffic_shaper/limiter/queue",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_traffic_shaper_limiter_queue(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    aqm: str | None = None,
    buckets: int | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    mask: str | None = None,
    maskbits: int | None = None,
    maskbitsv6: int | None = None,
    name: str | None = None,
    param_codel_interval: int | None = None,
    param_codel_target: int | None = None,
    param_gred_max_p: int | None = None,
    param_gred_max_th: int | None = None,
    param_gred_min_th: int | None = None,
    param_gred_w_q: int | None = None,
    param_pie_alpha: int | None = None,
    param_pie_beta: int | None = None,
    param_pie_max_burst: int | None = None,
    param_pie_max_ecnth: int | None = None,
    param_pie_target: int | None = None,
    param_pie_tupdate: int | None = None,
    param_red_max_p: int | None = None,
    param_red_max_th: int | None = None,
    param_red_min_th: int | None = None,
    param_red_w_q: int | None = None,
    pie_capdrop: bool | None = None,
    pie_onoff: bool | None = None,
    pie_pderand: bool | None = None,
    pie_qdelay: bool | None = None,
    plr: float | None = None,
    qlimit: int | None = None,
    weight: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/traffic_shaper/limiter/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    aqm: The Active Queue Management (AQM) algorithm to use for this queue. AQM is the intelligent drop of network packets inside the queue, when it becomes full or gets close to becoming full, with the goal of reducing network congestion. Valid values: ['droptail', 'codel', 'pie', 'red', 'gred']
    buckets: The limiter queue's bucket size (slots).
    description: The verbose description for this limiter queue.
    ecn: Enable or disable ECN. ECN sets a reserved TCP flag when the queue is nearing or exceeding capacity. Not all AQMs or schedulers support this.This field is only available when the following conditions are met:- `aqm` must be one of [ codel, pie, red, gred ]- `sched` must be one of [ fq_codel, fq_pie ]
    enabled: Enables or disables this limiter queue.
    mask: If `source` or `destination` slots is chosen a dynamic pipe with the bandwidth, delay, packet loss and queue size given above will be created for each source/destination IP address encountered, respectively. This makes it possible to easily specify bandwidth limits per host or subnet. Valid values: ['none', 'srcaddress', 'dstaddress']
    maskbits: The IPv4 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    maskbitsv6: The IPv6 mask bits to use when determine the scope of the dynamic pipe for IPv4 traffic.This field is only available when the following conditions are met:- `mask` must be one of [ srcaddress, dstaddress ]
    name: The unique name for this limiter queue.
    param_codel_interval: The value for the CoDel interval parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_codel_target: The value for the CoDel target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'codel'`
    param_gred_max_p: The value for the GRED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_max_th: The value for the GRED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_min_th: The value for the GRED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_gred_w_q: The value for the GRED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'gred'`
    param_pie_alpha: The value for the PIE alpha parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_beta: The value for the PIE beta parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_burst: The value for the PIE max_burst parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_max_ecnth: The value for the PIE ecnth parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_target: The value for the PIE target parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_pie_tupdate: The value for the PIE tupdate parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    param_red_max_p: The value for the RED max_p parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_max_th: The value for the RED max_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_min_th: The value for the RED min_th parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    param_red_w_q: The value for the RED w_q parameter.This field is only available when the following conditions are met:- `aqm` must be equal to `'red'`
    pie_capdrop: Enable or disable cap drop adjustment.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_onoff: Enable or disable turning PIE on and off depending on queue load.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_pderand: Enable or disable drop probability de-randomisation.This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    pie_qdelay: Set queue delay type to timestamps (true) or departure rate estimation (false).This field is only available when the following conditions are met:- `aqm` must be equal to `'pie'`
    plr: The amount of packet loss (in percentage) added to traffic passing through this limiter queue.
    qlimit: The length of the limiter's queue which the scheduler and AQM are responsible for. Set to `null` to assume default.
    weight: The share of the parent limiter this queue gets.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/traffic_shaper/limiter/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if aqm is not None:
        body["aqm"] = aqm
    if buckets is not None:
        body["buckets"] = buckets
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if mask is not None:
        body["mask"] = mask
    if maskbits is not None:
        body["maskbits"] = maskbits
    if maskbitsv6 is not None:
        body["maskbitsv6"] = maskbitsv6
    if name is not None:
        body["name"] = name
    if param_codel_interval is not None:
        body["param_codel_interval"] = param_codel_interval
    if param_codel_target is not None:
        body["param_codel_target"] = param_codel_target
    if param_gred_max_p is not None:
        body["param_gred_max_p"] = param_gred_max_p
    if param_gred_max_th is not None:
        body["param_gred_max_th"] = param_gred_max_th
    if param_gred_min_th is not None:
        body["param_gred_min_th"] = param_gred_min_th
    if param_gred_w_q is not None:
        body["param_gred_w_q"] = param_gred_w_q
    if param_pie_alpha is not None:
        body["param_pie_alpha"] = param_pie_alpha
    if param_pie_beta is not None:
        body["param_pie_beta"] = param_pie_beta
    if param_pie_max_burst is not None:
        body["param_pie_max_burst"] = param_pie_max_burst
    if param_pie_max_ecnth is not None:
        body["param_pie_max_ecnth"] = param_pie_max_ecnth
    if param_pie_target is not None:
        body["param_pie_target"] = param_pie_target
    if param_pie_tupdate is not None:
        body["param_pie_tupdate"] = param_pie_tupdate
    if param_red_max_p is not None:
        body["param_red_max_p"] = param_red_max_p
    if param_red_max_th is not None:
        body["param_red_max_th"] = param_red_max_th
    if param_red_min_th is not None:
        body["param_red_min_th"] = param_red_min_th
    if param_red_w_q is not None:
        body["param_red_w_q"] = param_red_w_q
    if pie_capdrop is not None:
        body["pie_capdrop"] = pie_capdrop
    if pie_onoff is not None:
        body["pie_onoff"] = pie_onoff
    if pie_pderand is not None:
        body["pie_pderand"] = pie_pderand
    if pie_qdelay is not None:
        body["pie_qdelay"] = pie_qdelay
    if plr is not None:
        body["plr"] = plr
    if qlimit is not None:
        body["qlimit"] = qlimit
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/traffic_shaper/limiter/queue",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_limiter_queue(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/limiter/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/limiter/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/limiter/queue",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_traffic_shaper_limiter_queues(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiter/queues

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiter/queues",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_limiter_queues(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/limiter/queues

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/limiter/queues. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/limiter/queues",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_traffic_shaper_limiters(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/limiters

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/limiters",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_traffic_shaper_limiters(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/traffic_shaper/limiters

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/traffic_shaper/limiters. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/traffic_shaper/limiters",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_firewall_traffic_shaper_queue(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/queue

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/queue",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_traffic_shaper_queue(
    name: str,
    parent_id: str | int,
    qlimit: int,
    confirm: bool = False,
    bandwidth: int | None = None,
    bandwidthtype: str | None = None,
    borrow: bool | None = None,
    buckets: int | None = None,
    codel: bool | None = None,
    default: bool | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    hogs: int | None = None,
    linkshare: bool | None = None,
    linkshare_d: int | None = None,
    linkshare_m1: str | None = None,
    linkshare_m2: str | None = None,
    priority: int | None = None,
    realtime: bool | None = None,
    realtime_d: int | None = None,
    realtime_m1: str | None = None,
    realtime_m2: str | None = None,
    red: bool | None = None,
    rio: bool | None = None,
    upperlimit: bool | None = None,
    upperlimit_d: int | None = None,
    upperlimit_m1: str | None = None,
    upperlimit_m2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/traffic_shaper/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    name: The name to assign this traffic shaper queue.
    parent_id: The ID of the parent this object is nested under.
    qlimit: The number of packets that can be held in a queue waiting to be transmitted by the shaper.
    bandwidth: The total bandwidth amount allowed by this traffic shaper.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]
    bandwidthtype: The scale type of the `bandwidth` field's value.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ] Valid values: ['%', 'b', 'Kb', 'Mb', 'Gb']
    borrow: Allow this queue to borrow from other queues when available.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'CBQ'`
    buckets: This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'FAIRQ'`
    codel: Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.
    default: Mark this traffic shaper queue as the default queue.
    description: A description for this traffic shaper queue.
    ecn: Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.
    enabled: Enables or disables the traffic shaper queue.
    hogs: The bandwidth limit per host.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'FAIRQ'`
    linkshare: Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    linkshare_d: The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    linkshare_m1: The initial bandwidth limit for this traffic shaper queue when link sharing.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    linkshare_m2: The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    priority: The priority level for this traffic shaper queue.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]
    realtime: Allow setting the guaranteed bandwidth minimum allotted to the queue.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    realtime_d: The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    realtime_m1: The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    realtime_m2: The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    red: Use the 'Random Early Detection' scheduler option for this traffic shaper queue.
    rio: Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.
    upperlimit: Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    upperlimit_d: The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    upperlimit_m1: The burst-able bandwidth limit for this traffic shaper queue.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    upperlimit_m2: The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/traffic_shaper/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if qlimit is not None:
        body["qlimit"] = qlimit
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if bandwidthtype is not None:
        body["bandwidthtype"] = bandwidthtype
    if borrow is not None:
        body["borrow"] = borrow
    if buckets is not None:
        body["buckets"] = buckets
    if codel is not None:
        body["codel"] = codel
    if default is not None:
        body["default"] = default
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if hogs is not None:
        body["hogs"] = hogs
    if linkshare is not None:
        body["linkshare"] = linkshare
    if linkshare_d is not None:
        body["linkshare_d"] = linkshare_d
    if linkshare_m1 is not None:
        body["linkshare_m1"] = linkshare_m1
    if linkshare_m2 is not None:
        body["linkshare_m2"] = linkshare_m2
    if priority is not None:
        body["priority"] = priority
    if realtime is not None:
        body["realtime"] = realtime
    if realtime_d is not None:
        body["realtime_d"] = realtime_d
    if realtime_m1 is not None:
        body["realtime_m1"] = realtime_m1
    if realtime_m2 is not None:
        body["realtime_m2"] = realtime_m2
    if red is not None:
        body["red"] = red
    if rio is not None:
        body["rio"] = rio
    if upperlimit is not None:
        body["upperlimit"] = upperlimit
    if upperlimit_d is not None:
        body["upperlimit_d"] = upperlimit_d
    if upperlimit_m1 is not None:
        body["upperlimit_m1"] = upperlimit_m1
    if upperlimit_m2 is not None:
        body["upperlimit_m2"] = upperlimit_m2
    return await _client.request(
        "POST",
        "/api/v2/firewall/traffic_shaper/queue",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_traffic_shaper_queue(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    bandwidth: int | None = None,
    bandwidthtype: str | None = None,
    borrow: bool | None = None,
    buckets: int | None = None,
    codel: bool | None = None,
    default: bool | None = None,
    description: str | None = None,
    ecn: bool | None = None,
    enabled: bool | None = None,
    hogs: int | None = None,
    linkshare: bool | None = None,
    linkshare_d: int | None = None,
    linkshare_m1: str | None = None,
    linkshare_m2: str | None = None,
    name: str | None = None,
    priority: int | None = None,
    qlimit: int | None = None,
    realtime: bool | None = None,
    realtime_d: int | None = None,
    realtime_m1: str | None = None,
    realtime_m2: str | None = None,
    red: bool | None = None,
    rio: bool | None = None,
    upperlimit: bool | None = None,
    upperlimit_d: int | None = None,
    upperlimit_m1: str | None = None,
    upperlimit_m2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/traffic_shaper/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    bandwidth: The total bandwidth amount allowed by this traffic shaper.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ]
    bandwidthtype: The scale type of the `bandwidth` field's value.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, HFSC ] Valid values: ['%', 'b', 'Kb', 'Mb', 'Gb']
    borrow: Allow this queue to borrow from other queues when available.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'CBQ'`
    buckets: This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'FAIRQ'`
    codel: Use the 'Codel Active Queue' scheduler option for this traffic shaper queue.
    default: Mark this traffic shaper queue as the default queue.
    description: A description for this traffic shaper queue.
    ecn: Use the 'Explicit Congestion Notification' scheduler option for this traffic shaper queue.
    enabled: Enables or disables the traffic shaper queue.
    hogs: The bandwidth limit per host.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'FAIRQ'`
    linkshare: Allow sharing bandwidth from this queue for other queues as long as the real time values have been satisfied.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    linkshare_d: The duration (in milliseconds) that the initial bandwidth limit (`linkshare_m1`) is in effect.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    linkshare_m1: The initial bandwidth limit for this traffic shaper queue when link sharing.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    linkshare_m2: The maximum bandwidth this traffic shaper queue is allowed to use. Note: This behaves exactly the same as the `bandwidth` field. If this field is set, it will override whatever value is current assigned to the `bandwidth` field.This field is only available when the following conditions are met:- `linkshare` must be equal to `true`
    name: The name to assign this traffic shaper queue.
    priority: The priority level for this traffic shaper queue.This field is only available when the following conditions are met:- Parent field `scheduler` must be one of [ FAIRQ, CBQ, PRIQ ]
    qlimit: The number of packets that can be held in a queue waiting to be transmitted by the shaper.
    realtime: Allow setting the guaranteed bandwidth minimum allotted to the queue.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    realtime_d: The duration (in milliseconds) that the guaranteed bandwidth limit (`realtime_m1`) is in effect.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    realtime_m1: The guaranteed minimum bandwidth limit for this traffic shaper queue during real time.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    realtime_m2: The maximum bandwidth this traffic shaper queue is allowed to use. Note: This value should not exceed 30% of parent queue's maximum bandwidth.This field is only available when the following conditions are met:- `realtime` must be equal to `true`
    red: Use the 'Random Early Detection' scheduler option for this traffic shaper queue.
    rio: Use the 'Random Early Detection In and Out' scheduler option for this traffic shaper queue.
    upperlimit: Allow setting the maximum bandwidth allowed for the queue. Will force hard bandwidth limiting.This field is only available when the following conditions are met:- Parent field `scheduler` must be equal to `'HFSC'`
    upperlimit_d: The duration (in milliseconds) that the burst-able bandwidth limit (`upperlimit_m1` is in effect.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    upperlimit_m1: The burst-able bandwidth limit for this traffic shaper queue.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    upperlimit_m2: The normal bandwidth limit for this traffic shaper queue. If `upperlimit_m1` is not defined, this limit will always be in effect. If `upperlimit_m1` is defined, this limit will take effect after the `upperlimit_d` duration has expired.This field is only available when the following conditions are met:- `upperlimit` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/traffic_shaper/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if bandwidth is not None:
        body["bandwidth"] = bandwidth
    if bandwidthtype is not None:
        body["bandwidthtype"] = bandwidthtype
    if borrow is not None:
        body["borrow"] = borrow
    if buckets is not None:
        body["buckets"] = buckets
    if codel is not None:
        body["codel"] = codel
    if default is not None:
        body["default"] = default
    if description is not None:
        body["description"] = description
    if ecn is not None:
        body["ecn"] = ecn
    if enabled is not None:
        body["enabled"] = enabled
    if hogs is not None:
        body["hogs"] = hogs
    if linkshare is not None:
        body["linkshare"] = linkshare
    if linkshare_d is not None:
        body["linkshare_d"] = linkshare_d
    if linkshare_m1 is not None:
        body["linkshare_m1"] = linkshare_m1
    if linkshare_m2 is not None:
        body["linkshare_m2"] = linkshare_m2
    if name is not None:
        body["name"] = name
    if priority is not None:
        body["priority"] = priority
    if qlimit is not None:
        body["qlimit"] = qlimit
    if realtime is not None:
        body["realtime"] = realtime
    if realtime_d is not None:
        body["realtime_d"] = realtime_d
    if realtime_m1 is not None:
        body["realtime_m1"] = realtime_m1
    if realtime_m2 is not None:
        body["realtime_m2"] = realtime_m2
    if red is not None:
        body["red"] = red
    if rio is not None:
        body["rio"] = rio
    if upperlimit is not None:
        body["upperlimit"] = upperlimit
    if upperlimit_d is not None:
        body["upperlimit_d"] = upperlimit_d
    if upperlimit_m1 is not None:
        body["upperlimit_m1"] = upperlimit_m1
    if upperlimit_m2 is not None:
        body["upperlimit_m2"] = upperlimit_m2
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/traffic_shaper/queue",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_queue(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/queue

    Note: Call pfsense_firewall_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/queue. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/queue",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_traffic_shaper_queues(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shaper/queues

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shaper/queues",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shaper_queues(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shaper/queues

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shaper/queues. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shaper/queues",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_traffic_shapers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/traffic_shapers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/traffic_shapers",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_firewall_traffic_shapers(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/firewall/traffic_shapers

    Note: Call pfsense_firewall_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/firewall/traffic_shapers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/firewall/traffic_shapers",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_traffic_shapers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/traffic_shapers

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/traffic_shapers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/traffic_shapers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_firewall_virtual_ip_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/virtual_ip/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/firewall/virtual_ip/apply",
    )


@mcp.tool()
async def pfsense_firewall_virtual_ip_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/virtual_ip/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/virtual_ip/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/firewall/virtual_ip/apply",
    )


@mcp.tool()
async def pfsense_get_firewall_virtual_ip(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/virtual_ip

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/firewall/virtual_ip",
        params=params,
    )


@mcp.tool()
async def pfsense_create_firewall_virtual_ip(
    interface: str,
    mode: str,
    subnet: str,
    subnet_bits: int,
    confirm: bool = False,
    advbase: int | None = None,
    advskew: int | None = None,
    carp_mode: str | None = None,
    carp_peer: str | None = None,
    descr: str | None = None,
    noexpand: bool | None = None,
    password: str | None = None,
    type_: str | None = 'single',
    vhid: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/firewall/virtual_ip

    Note: Call pfsense_firewall_virtual_ip_apply after this to apply changes.

    interface: The interface this virtual IP will apply to.
    mode: The virtual IP mode to use for this virtual IP. Valid values: ['ipalias', 'proxyarp', 'carp', 'other']
    subnet: The address for this virtual IP.
    subnet_bits: The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask
    advbase: The base frequency that this machine will advertise.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    advskew: The frequency skew that this machine will advertise.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    carp_mode: The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'` Valid values: ['mcast', 'ucast']
    carp_peer: The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.This field is only available when the following conditions are met:- `carp_mode` must be equal to `'ucast'`
    descr: A description for administrative reference
    noexpand: Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)This field is only available when the following conditions are met:- `mode` must be one of [ proxyarp, other ]
    password: The VHID group password shared by all CARP members.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    type_: The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes. Valid values: ['single', 'network']
    vhid: The VHID group that the machines will share.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/firewall/virtual_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_virtual_ip_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if interface is not None:
        body["interface"] = interface
    if mode is not None:
        body["mode"] = mode
    if subnet is not None:
        body["subnet"] = subnet
    if subnet_bits is not None:
        body["subnet_bits"] = subnet_bits
    if advbase is not None:
        body["advbase"] = advbase
    if advskew is not None:
        body["advskew"] = advskew
    if carp_mode is not None:
        body["carp_mode"] = carp_mode
    if carp_peer is not None:
        body["carp_peer"] = carp_peer
    if descr is not None:
        body["descr"] = descr
    if noexpand is not None:
        body["noexpand"] = noexpand
    if password is not None:
        body["password"] = password
    if type_ is not None:
        body["type"] = type_
    if vhid is not None:
        body["vhid"] = vhid
    return await _client.request(
        "POST",
        "/api/v2/firewall/virtual_ip",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_firewall_virtual_ip(
    id: str | int,
    confirm: bool = False,
    advbase: int | None = None,
    advskew: int | None = None,
    carp_mode: str | None = None,
    carp_peer: str | None = None,
    descr: str | None = None,
    interface: str | None = None,
    mode: str | None = None,
    noexpand: bool | None = None,
    password: str | None = None,
    subnet: str | None = None,
    subnet_bits: int | None = None,
    type_: str | None = None,
    vhid: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/firewall/virtual_ip

    Note: Call pfsense_firewall_virtual_ip_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    advbase: The base frequency that this machine will advertise.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    advskew: The frequency skew that this machine will advertise.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    carp_mode: The CARP mode to use for this virtual IP. Please note this field is exclusive to pfSense Plus and has no effect on CE.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'` Valid values: ['mcast', 'ucast']
    carp_peer: The IP address of the CARP peer. Please note this field is exclusive to pfSense Plus and has no effect on CE.This field is only available when the following conditions are met:- `carp_mode` must be equal to `'ucast'`
    descr: A description for administrative reference
    interface: The interface this virtual IP will apply to.
    mode: The virtual IP mode to use for this virtual IP. Valid values: ['ipalias', 'proxyarp', 'carp', 'other']
    noexpand: Disable expansion of this entry into IPs on NAT lists (e.g. 192.168.1.0/24 expands to 256 entries.)This field is only available when the following conditions are met:- `mode` must be one of [ proxyarp, other ]
    password: The VHID group password shared by all CARP members.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    subnet: The address for this virtual IP.
    subnet_bits: The subnet bits for this virtual IP. For `proxyarp` and `other` virtual IPs, this value specifies a block of many IP address. For all other virtual IP modes, this specifies the subnet mask
    type_: The virtual IP scope type. The `network` option is only applicable to the `proxyarp` and `other` virtual IP modes. Valid values: ['single', 'network']
    vhid: The VHID group that the machines will share.This field is only available when the following conditions are met:- `mode` must be equal to `'carp'`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/firewall/virtual_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_virtual_ip_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if advbase is not None:
        body["advbase"] = advbase
    if advskew is not None:
        body["advskew"] = advskew
    if carp_mode is not None:
        body["carp_mode"] = carp_mode
    if carp_peer is not None:
        body["carp_peer"] = carp_peer
    if descr is not None:
        body["descr"] = descr
    if interface is not None:
        body["interface"] = interface
    if mode is not None:
        body["mode"] = mode
    if noexpand is not None:
        body["noexpand"] = noexpand
    if password is not None:
        body["password"] = password
    if subnet is not None:
        body["subnet"] = subnet
    if subnet_bits is not None:
        body["subnet_bits"] = subnet_bits
    if type_ is not None:
        body["type"] = type_
    if vhid is not None:
        body["vhid"] = vhid
    return await _client.request(
        "PATCH",
        "/api/v2/firewall/virtual_ip",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_firewall_virtual_ip(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/virtual_ip

    Note: Call pfsense_firewall_virtual_ip_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/virtual_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_virtual_ip_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/virtual_ip",
        params=params,
    )


@mcp.tool()
async def pfsense_list_firewall_virtual_i_ps(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/firewall/virtual_ips

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/firewall/virtual_ips",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_firewall_virtual_i_ps(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/firewall/virtual_ips

    Note: Call pfsense_firewall_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/firewall/virtual_ips. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_firewall_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/firewall/virtual_ips",
        params=params,
    )


@mcp.tool()
async def pfsense_create_graph_ql(
    confirm: bool = False,
    query: str | None = None,
    variables: dict[str, Any] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/graphql

    WARNING: DANGEROUS: Executes raw GraphQL queries.

    query: The GraphQL query/mutation to execute.
    variables: The variables to pass to the GraphQL query or mutation. In general, this will be an object containing the variables to pass to the query or mutation.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/graphql. "
            "Set confirm=True to execute."
            "\n\nWARNING: DANGEROUS: Executes raw GraphQL queries."
        )
    body: dict[str, Any] = {}
    if query is not None:
        body["query"] = query
    if variables is not None:
        body["variables"] = variables
    return await _client.request(
        "POST",
        "/api/v2/graphql",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_interface_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/interface/apply",
    )


@mcp.tool()
async def pfsense_interface_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/interface/apply",
    )


@mcp.tool()
async def pfsense_list_interface_available_interfaces(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/available_interfaces

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/available_interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_get_interface_bridge(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/bridge

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface/bridge",
        params=params,
    )


@mcp.tool()
async def pfsense_create_interface_bridge(
    members: list[str],
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/bridge

    Note: Call pfsense_interface_apply after this to apply changes.

    members: The member interfaces to include in this bridge.
    descr: A description for this interface bridge.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/bridge. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if members is not None:
        body["members"] = members
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/interface/bridge",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_interface_bridge(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    members: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface/bridge

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description for this interface bridge.
    members: The member interfaces to include in this bridge.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface/bridge. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if members is not None:
        body["members"] = members
    return await _client.request(
        "PATCH",
        "/api/v2/interface/bridge",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_bridge(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/bridge

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/bridge. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/interface/bridge",
        params=params,
    )


@mcp.tool()
async def pfsense_list_interface_bridges(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/bridges

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/bridges",
        params=params,
    )


@mcp.tool()
async def pfsense_get_interface_gre(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/gre

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface/gre",
        params=params,
    )


@mcp.tool()
async def pfsense_create_interface_gre(
    if_: str,
    remote_addr: str,
    confirm: bool = False,
    add_static_route: bool | None = None,
    descr: str | None = None,
    tunnel_local_addr: str | None = None,
    tunnel_local_addr6: str | None = None,
    tunnel_remote_addr: str | None = None,
    tunnel_remote_addr6: str | None = None,
    tunnel_remote_net: int | None = None,
    tunnel_remote_net6: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/gre

    Note: Call pfsense_interface_apply after this to apply changes.

    if_: The pfSense interface interface serving as the local address to be used for the GRE tunnel.
    remote_addr: The remote address to use for the GRE tunnel.
    add_static_route: Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.
    descr: A description for this GRE interface.
    tunnel_local_addr: The local IPv4 address to use for the GRE tunnel.
    tunnel_local_addr6: The local IPv6 address to use for the GRE tunnel.
    tunnel_remote_addr: The remote IPv4 address to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr` must not be equal to `NULL`
    tunnel_remote_addr6: The remote IPv6 address to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr6` must not be equal to `NULL`
    tunnel_remote_net: The remote IPv4 subnet bitmask to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr` must not be equal to `NULL`
    tunnel_remote_net6: The remote IPv6 subnet bitmask to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr6` must not be equal to `NULL`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/gre. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if if_ is not None:
        body["if"] = if_
    if remote_addr is not None:
        body["remote_addr"] = remote_addr
    if add_static_route is not None:
        body["add_static_route"] = add_static_route
    if descr is not None:
        body["descr"] = descr
    if tunnel_local_addr is not None:
        body["tunnel_local_addr"] = tunnel_local_addr
    if tunnel_local_addr6 is not None:
        body["tunnel_local_addr6"] = tunnel_local_addr6
    if tunnel_remote_addr is not None:
        body["tunnel_remote_addr"] = tunnel_remote_addr
    if tunnel_remote_addr6 is not None:
        body["tunnel_remote_addr6"] = tunnel_remote_addr6
    if tunnel_remote_net is not None:
        body["tunnel_remote_net"] = tunnel_remote_net
    if tunnel_remote_net6 is not None:
        body["tunnel_remote_net6"] = tunnel_remote_net6
    return await _client.request(
        "POST",
        "/api/v2/interface/gre",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_interface_gre(
    id: str | int,
    confirm: bool = False,
    add_static_route: bool | None = None,
    descr: str | None = None,
    if_: str | None = None,
    remote_addr: str | None = None,
    tunnel_local_addr: str | None = None,
    tunnel_local_addr6: str | None = None,
    tunnel_remote_addr: str | None = None,
    tunnel_remote_addr6: str | None = None,
    tunnel_remote_net: int | None = None,
    tunnel_remote_net6: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface/gre

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    add_static_route: Whether to add an explicit static route for the remote inner tunnel address/subnet via the local tunnel address.
    descr: A description for this GRE interface.
    if_: The pfSense interface interface serving as the local address to be used for the GRE tunnel.
    remote_addr: The remote address to use for the GRE tunnel.
    tunnel_local_addr: The local IPv4 address to use for the GRE tunnel.
    tunnel_local_addr6: The local IPv6 address to use for the GRE tunnel.
    tunnel_remote_addr: The remote IPv4 address to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr` must not be equal to `NULL`
    tunnel_remote_addr6: The remote IPv6 address to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr6` must not be equal to `NULL`
    tunnel_remote_net: The remote IPv4 subnet bitmask to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr` must not be equal to `NULL`
    tunnel_remote_net6: The remote IPv6 subnet bitmask to use for the GRE tunnel.This field is only available when the following conditions are met:- `tunnel_local_addr6` must not be equal to `NULL`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface/gre. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if add_static_route is not None:
        body["add_static_route"] = add_static_route
    if descr is not None:
        body["descr"] = descr
    if if_ is not None:
        body["if"] = if_
    if remote_addr is not None:
        body["remote_addr"] = remote_addr
    if tunnel_local_addr is not None:
        body["tunnel_local_addr"] = tunnel_local_addr
    if tunnel_local_addr6 is not None:
        body["tunnel_local_addr6"] = tunnel_local_addr6
    if tunnel_remote_addr is not None:
        body["tunnel_remote_addr"] = tunnel_remote_addr
    if tunnel_remote_addr6 is not None:
        body["tunnel_remote_addr6"] = tunnel_remote_addr6
    if tunnel_remote_net is not None:
        body["tunnel_remote_net"] = tunnel_remote_net
    if tunnel_remote_net6 is not None:
        body["tunnel_remote_net6"] = tunnel_remote_net6
    return await _client.request(
        "PATCH",
        "/api/v2/interface/gre",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_gre(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/gre

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/gre. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/interface/gre",
        params=params,
    )


@mcp.tool()
async def pfsense_list_interface_gr_es(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/gres

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/gres",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_interface_gr_es(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/gres

    Note: Call pfsense_interface_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/gres. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/interface/gres",
        params=params,
    )


@mcp.tool()
async def pfsense_get_interface_group(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/group

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface/group",
        params=params,
    )


@mcp.tool()
async def pfsense_create_interface_group(
    ifname: str,
    confirm: bool = False,
    descr: str | None = None,
    members: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/group

    Note: Call pfsense_interface_apply after this to apply changes.

    ifname: The name of this interface group.
    descr: The description for this interface group.
    members: The member interfaces to assign to this interface group.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if ifname is not None:
        body["ifname"] = ifname
    if descr is not None:
        body["descr"] = descr
    if members is not None:
        body["members"] = members
    return await _client.request(
        "POST",
        "/api/v2/interface/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_interface_group(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    ifname: str | None = None,
    members: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface/group

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: The description for this interface group.
    ifname: The name of this interface group.
    members: The member interfaces to assign to this interface group.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if ifname is not None:
        body["ifname"] = ifname
    if members is not None:
        body["members"] = members
    return await _client.request(
        "PATCH",
        "/api/v2/interface/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_group(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/group

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/interface/group",
        params=params,
    )


@mcp.tool()
async def pfsense_list_interface_groups(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/groups

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_interface_groups(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/interface/groups

    Note: Call pfsense_interface_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/interface/groups. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/interface/groups",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_groups(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/groups

    Note: Call pfsense_interface_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/groups. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/interface/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_get_interface_lagg(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/lagg

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface/lagg",
        params=params,
    )


@mcp.tool()
async def pfsense_create_interface_lagg(
    members: list[str],
    proto: str,
    confirm: bool = False,
    descr: str | None = None,
    failovermaster: str | None = None,
    lacptimeout: str | None = None,
    lagghash: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/lagg

    Note: Call pfsense_interface_apply after this to apply changes.

    members: A list of member interfaces to include in the LAGG.
    proto: The LAGG protocol to use. Valid values: ['lacp', 'failover', 'loadbalance', 'roundrobin', 'none']
    descr: A description to help document the purpose of this LAGG interface.
    failovermaster: The failover master interface to use.This field is only available when the following conditions are met:- `proto` must be equal to `'failover'`
    lacptimeout: The LACP timeout mode to use.This field is only available when the following conditions are met:- `proto` must be equal to `'lacp'` Valid values: ['slow', 'fast']
    lagghash: The LAGG hash algorithm to use.This field is only available when the following conditions are met:- `proto` must be one of [ lacp, loadbalance ] Valid values: ['l2', 'l3', 'l4', 'l2,l3', 'l2,l4', 'l3,l4', 'l2,l3,l4']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/lagg. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if members is not None:
        body["members"] = members
    if proto is not None:
        body["proto"] = proto
    if descr is not None:
        body["descr"] = descr
    if failovermaster is not None:
        body["failovermaster"] = failovermaster
    if lacptimeout is not None:
        body["lacptimeout"] = lacptimeout
    if lagghash is not None:
        body["lagghash"] = lagghash
    return await _client.request(
        "POST",
        "/api/v2/interface/lagg",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_interface_lagg(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    failovermaster: str | None = None,
    lacptimeout: str | None = None,
    lagghash: str | None = None,
    members: list[str] | None = None,
    proto: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface/lagg

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description to help document the purpose of this LAGG interface.
    failovermaster: The failover master interface to use.This field is only available when the following conditions are met:- `proto` must be equal to `'failover'`
    lacptimeout: The LACP timeout mode to use.This field is only available when the following conditions are met:- `proto` must be equal to `'lacp'` Valid values: ['slow', 'fast']
    lagghash: The LAGG hash algorithm to use.This field is only available when the following conditions are met:- `proto` must be one of [ lacp, loadbalance ] Valid values: ['l2', 'l3', 'l4', 'l2,l3', 'l2,l4', 'l3,l4', 'l2,l3,l4']
    members: A list of member interfaces to include in the LAGG.
    proto: The LAGG protocol to use. Valid values: ['lacp', 'failover', 'loadbalance', 'roundrobin', 'none']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface/lagg. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if failovermaster is not None:
        body["failovermaster"] = failovermaster
    if lacptimeout is not None:
        body["lacptimeout"] = lacptimeout
    if lagghash is not None:
        body["lagghash"] = lagghash
    if members is not None:
        body["members"] = members
    if proto is not None:
        body["proto"] = proto
    return await _client.request(
        "PATCH",
        "/api/v2/interface/lagg",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_lagg(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/lagg

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/lagg. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/interface/lagg",
        params=params,
    )


@mcp.tool()
async def pfsense_list_interface_lag_gs(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/laggs

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/laggs",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_interface_lag_gs(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/laggs

    Note: Call pfsense_interface_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/laggs. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/interface/laggs",
        params=params,
    )


@mcp.tool()
async def pfsense_get_interface_vlan(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/vlan

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface/vlan",
        params=params,
    )


@mcp.tool()
async def pfsense_create_interface_vlan(
    if_: str,
    tag: int,
    confirm: bool = False,
    descr: str | None = None,
    pcp: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface/vlan

    Note: Call pfsense_interface_apply after this to apply changes.

    if_: The real parent interface this VLAN will be applied to.
    tag: The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.
    descr: A description to help document the purpose of this VLAN.
    pcp: The 802.1p VLAN priority code point (PCP) to assign to this VLAN.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface/vlan. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if if_ is not None:
        body["if"] = if_
    if tag is not None:
        body["tag"] = tag
    if descr is not None:
        body["descr"] = descr
    if pcp is not None:
        body["pcp"] = pcp
    return await _client.request(
        "POST",
        "/api/v2/interface/vlan",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_interface_vlan(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    if_: str | None = None,
    pcp: int | None = None,
    tag: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface/vlan

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description to help document the purpose of this VLAN.
    if_: The real parent interface this VLAN will be applied to.
    pcp: The 802.1p VLAN priority code point (PCP) to assign to this VLAN.
    tag: The VLAN ID tag to use. This must be unique from all other VLANs on the parent interface.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface/vlan. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if if_ is not None:
        body["if"] = if_
    if pcp is not None:
        body["pcp"] = pcp
    if tag is not None:
        body["tag"] = tag
    return await _client.request(
        "PATCH",
        "/api/v2/interface/vlan",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_interface_vlan(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/vlan

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/vlan. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/interface/vlan",
        params=params,
    )


@mcp.tool()
async def pfsense_list_interface_vla_ns(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface/vlans

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interface/vlans",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_interface_vla_ns(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface/vlans

    Note: Call pfsense_interface_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface/vlans. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/interface/vlans",
        params=params,
    )


@mcp.tool()
async def pfsense_get_network_interface(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interface

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/interface",
        params=params,
    )


@mcp.tool()
async def pfsense_create_network_interface(
    descr: str,
    if_: str,
    typev4: str,
    confirm: bool = False,
    adv_dhcp_config_advanced: bool | None = None,
    adv_dhcp_config_file_override: bool | None = None,
    adv_dhcp_config_file_override_path: str | None = None,
    adv_dhcp_option_modifiers: str | None = None,
    adv_dhcp_pt_backoff_cutoff: int | None = None,
    adv_dhcp_pt_initial_interval: int | None = None,
    adv_dhcp_pt_reboot: int | None = None,
    adv_dhcp_pt_retry: int | None = None,
    adv_dhcp_pt_select_timeout: int | None = None,
    adv_dhcp_pt_timeout: int | None = None,
    adv_dhcp_pt_values: str | None = None,
    adv_dhcp_request_options: str | None = None,
    adv_dhcp_required_options: str | None = None,
    adv_dhcp_send_options: str | None = None,
    alias_address: str | None = None,
    alias_subnet: int | None = None,
    blockbogons: bool | None = None,
    blockpriv: bool | None = None,
    dhcphostname: str | None = None,
    dhcprejectfrom: list[str] | None = None,
    enable: bool | None = None,
    gateway: str | None = None,
    gateway_6rd: str | None = None,
    gatewayv6: str | None = None,
    ipaddr: str | None = None,
    ipaddrv6: str | None = None,
    ipv6usev4iface: bool | None = None,
    media: str | None = None,
    mediaopt: str | None = None,
    mss: int | None = None,
    mtu: int | None = None,
    prefix_6rd: str | None = None,
    prefix_6rd_v4plen: int | None = None,
    slaacusev4iface: bool | None = None,
    spoofmac: str | None = None,
    subnet: int | None = None,
    subnetv6: int | None = None,
    track6_interface: str | None = None,
    track6_prefix_id_hex: str | None = None,
    typev6: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/interface

    Note: Call pfsense_interface_apply after this to apply changes.

    descr: The descriptive name for this interface.
    if_: The real interface this configuration will be applied to.
    typev4: Selects the IPv4 address type to assign this interface. Valid values: ['static', 'dhcp', 'none']
    adv_dhcp_config_advanced: Enables or disables the advanced DHCP settings on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    adv_dhcp_config_file_override: Enables or disables overriding the entire DHCP configuration file for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    adv_dhcp_config_file_override_path: Sets the local file path of the custom DHCP configuration file.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_file_override` must be equal to `true`
    adv_dhcp_option_modifiers: Sets DHCP option modifiers applied to the obtained DHCP lease.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_backoff_cutoff: Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_initial_interval: Manually sets the initial interval timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_reboot: Manually sets the reboot timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_retry: Manually sets the retry timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_select_timeout: Manually sets the select timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_timeout: Manually sets the timeout timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_values: Selects the advanced DHCP timing preset.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true` Valid values: ['SavedCfg']
    adv_dhcp_request_options: Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_required_options: Sets DHCP options required by the client when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_send_options: Sets DHCP options to be sent when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    alias_address: Sets the value used as a fixed alias IPv4 address by the DHCP client.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    alias_subnet: Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    blockbogons: Enable or disable automatically blocking bogon networks on this interface.
    blockpriv: Enable or disable automatically blocking RFC 1918 private networks on this interface.
    dhcphostname: Sets the DHCP hostname this interface will advertise via DHCP.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    dhcprejectfrom: Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    enable: Enable or disable this interface.
    gateway: Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.This field is only available when the following conditions are met:- `typev4` must be equal to `'static'`
    gateway_6rd: Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    gatewayv6: Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    ipaddr: Sets the IPv4 address to assign to this interface.This field is only available when the following conditions are met:- `typev4` must be one of [ static, dhcp ]
    ipaddrv6: Sets the IPv6 address to assign to this interface.This field is only available when the following conditions are met:- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]
    ipv6usev4iface: Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    media: Sets the link speed for this interface. In most situations this can be left as the default.
    mediaopt: Sets the link duplex for this interface. In most situations this can be left as the default.
    mss: Sets the MSS for this interface. Assumes default MSS if value is `null`.
    mtu: Sets the MTU for this interface. Assumes default MTU if value is `null`.
    prefix_6rd: Sets the 6RD IPv6 prefix assigned by the ISP for this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    prefix_6rd_v4plen: Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    slaacusev4iface: Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).This field is only available when the following conditions are met:- `typev6` must be equal to `'slaac'`
    spoofmac: Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.
    subnet: Sets the subnet bit count to assign this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'static'`
    subnetv6: Sets the subnet bit count to assign this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    track6_interface: Sets the dynamic IPv6 WAN interface to track for configuration.This field is only available when the following conditions are met:- `typev6` must be equal to `'track6'`
    track6_prefix_id_hex: Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.This field is only available when the following conditions are met:- `typev6` must be equal to `'track6'`
    typev6: Selects the IPv6 address type to assign this interface. Valid values: ['staticv6', 'dhcp6', 'slaac', '6rd', 'track6', '6to4', 'none']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/interface. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if descr is not None:
        body["descr"] = descr
    if if_ is not None:
        body["if"] = if_
    if typev4 is not None:
        body["typev4"] = typev4
    if adv_dhcp_config_advanced is not None:
        body["adv_dhcp_config_advanced"] = adv_dhcp_config_advanced
    if adv_dhcp_config_file_override is not None:
        body["adv_dhcp_config_file_override"] = adv_dhcp_config_file_override
    if adv_dhcp_config_file_override_path is not None:
        body["adv_dhcp_config_file_override_path"] = adv_dhcp_config_file_override_path
    if adv_dhcp_option_modifiers is not None:
        body["adv_dhcp_option_modifiers"] = adv_dhcp_option_modifiers
    if adv_dhcp_pt_backoff_cutoff is not None:
        body["adv_dhcp_pt_backoff_cutoff"] = adv_dhcp_pt_backoff_cutoff
    if adv_dhcp_pt_initial_interval is not None:
        body["adv_dhcp_pt_initial_interval"] = adv_dhcp_pt_initial_interval
    if adv_dhcp_pt_reboot is not None:
        body["adv_dhcp_pt_reboot"] = adv_dhcp_pt_reboot
    if adv_dhcp_pt_retry is not None:
        body["adv_dhcp_pt_retry"] = adv_dhcp_pt_retry
    if adv_dhcp_pt_select_timeout is not None:
        body["adv_dhcp_pt_select_timeout"] = adv_dhcp_pt_select_timeout
    if adv_dhcp_pt_timeout is not None:
        body["adv_dhcp_pt_timeout"] = adv_dhcp_pt_timeout
    if adv_dhcp_pt_values is not None:
        body["adv_dhcp_pt_values"] = adv_dhcp_pt_values
    if adv_dhcp_request_options is not None:
        body["adv_dhcp_request_options"] = adv_dhcp_request_options
    if adv_dhcp_required_options is not None:
        body["adv_dhcp_required_options"] = adv_dhcp_required_options
    if adv_dhcp_send_options is not None:
        body["adv_dhcp_send_options"] = adv_dhcp_send_options
    if alias_address is not None:
        body["alias_address"] = alias_address
    if alias_subnet is not None:
        body["alias_subnet"] = alias_subnet
    if blockbogons is not None:
        body["blockbogons"] = blockbogons
    if blockpriv is not None:
        body["blockpriv"] = blockpriv
    if dhcphostname is not None:
        body["dhcphostname"] = dhcphostname
    if dhcprejectfrom is not None:
        body["dhcprejectfrom"] = dhcprejectfrom
    if enable is not None:
        body["enable"] = enable
    if gateway is not None:
        body["gateway"] = gateway
    if gateway_6rd is not None:
        body["gateway_6rd"] = gateway_6rd
    if gatewayv6 is not None:
        body["gatewayv6"] = gatewayv6
    if ipaddr is not None:
        body["ipaddr"] = ipaddr
    if ipaddrv6 is not None:
        body["ipaddrv6"] = ipaddrv6
    if ipv6usev4iface is not None:
        body["ipv6usev4iface"] = ipv6usev4iface
    if media is not None:
        body["media"] = media
    if mediaopt is not None:
        body["mediaopt"] = mediaopt
    if mss is not None:
        body["mss"] = mss
    if mtu is not None:
        body["mtu"] = mtu
    if prefix_6rd is not None:
        body["prefix_6rd"] = prefix_6rd
    if prefix_6rd_v4plen is not None:
        body["prefix_6rd_v4plen"] = prefix_6rd_v4plen
    if slaacusev4iface is not None:
        body["slaacusev4iface"] = slaacusev4iface
    if spoofmac is not None:
        body["spoofmac"] = spoofmac
    if subnet is not None:
        body["subnet"] = subnet
    if subnetv6 is not None:
        body["subnetv6"] = subnetv6
    if track6_interface is not None:
        body["track6_interface"] = track6_interface
    if track6_prefix_id_hex is not None:
        body["track6_prefix_id_hex"] = track6_prefix_id_hex
    if typev6 is not None:
        body["typev6"] = typev6
    return await _client.request(
        "POST",
        "/api/v2/interface",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_network_interface(
    id: str | int,
    confirm: bool = False,
    adv_dhcp_config_advanced: bool | None = None,
    adv_dhcp_config_file_override: bool | None = None,
    adv_dhcp_config_file_override_path: str | None = None,
    adv_dhcp_option_modifiers: str | None = None,
    adv_dhcp_pt_backoff_cutoff: int | None = None,
    adv_dhcp_pt_initial_interval: int | None = None,
    adv_dhcp_pt_reboot: int | None = None,
    adv_dhcp_pt_retry: int | None = None,
    adv_dhcp_pt_select_timeout: int | None = None,
    adv_dhcp_pt_timeout: int | None = None,
    adv_dhcp_pt_values: str | None = None,
    adv_dhcp_request_options: str | None = None,
    adv_dhcp_required_options: str | None = None,
    adv_dhcp_send_options: str | None = None,
    alias_address: str | None = None,
    alias_subnet: int | None = None,
    blockbogons: bool | None = None,
    blockpriv: bool | None = None,
    descr: str | None = None,
    dhcphostname: str | None = None,
    dhcprejectfrom: list[str] | None = None,
    enable: bool | None = None,
    gateway: str | None = None,
    gateway_6rd: str | None = None,
    gatewayv6: str | None = None,
    if_: str | None = None,
    ipaddr: str | None = None,
    ipaddrv6: str | None = None,
    ipv6usev4iface: bool | None = None,
    media: str | None = None,
    mediaopt: str | None = None,
    mss: int | None = None,
    mtu: int | None = None,
    prefix_6rd: str | None = None,
    prefix_6rd_v4plen: int | None = None,
    slaacusev4iface: bool | None = None,
    spoofmac: str | None = None,
    subnet: int | None = None,
    subnetv6: int | None = None,
    track6_interface: str | None = None,
    track6_prefix_id_hex: str | None = None,
    typev4: str | None = None,
    typev6: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/interface

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    adv_dhcp_config_advanced: Enables or disables the advanced DHCP settings on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    adv_dhcp_config_file_override: Enables or disables overriding the entire DHCP configuration file for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    adv_dhcp_config_file_override_path: Sets the local file path of the custom DHCP configuration file.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_file_override` must be equal to `true`
    adv_dhcp_option_modifiers: Sets DHCP option modifiers applied to the obtained DHCP lease.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_backoff_cutoff: Manually sets the backoff cutoff timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_initial_interval: Manually sets the initial interval timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_reboot: Manually sets the reboot timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_retry: Manually sets the retry timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_select_timeout: Manually sets the select timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_timeout: Manually sets the timeout timing value used when requested DHCP leases on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_pt_values: Selects the advanced DHCP timing preset.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true` Valid values: ['SavedCfg']
    adv_dhcp_request_options: Sets DHCP option 55 values to be sent when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_required_options: Sets DHCP options required by the client when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    adv_dhcp_send_options: Sets DHCP options to be sent when requesting a DHCP lease for this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`- `adv_dhcp_config_advanced` must be equal to `true`
    alias_address: Sets the value used as a fixed alias IPv4 address by the DHCP client.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    alias_subnet: Sets the value used as the fixed alias IPv4 address's subnet bit count by the DHCP client.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    blockbogons: Enable or disable automatically blocking bogon networks on this interface.
    blockpriv: Enable or disable automatically blocking RFC 1918 private networks on this interface.
    descr: The descriptive name for this interface.
    dhcphostname: Sets the DHCP hostname this interface will advertise via DHCP.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    dhcprejectfrom: Sets a list of IPv4 DHCP server addresses to reject DHCP offers for on this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'dhcp'`
    enable: Enable or disable this interface.
    gateway: Sets the upstream gateway this interface will use. This is only applicable for WAN-type interfaces.This field is only available when the following conditions are met:- `typev4` must be equal to `'static'`
    gateway_6rd: Sets the 6RD IPv4 gateway address assigned by the ISP for this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    gatewayv6: Sets the upstream IPv6 gateway this interface will use. This is only applicable for WAN-type interfaces.This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    if_: The real interface this configuration will be applied to.
    ipaddr: Sets the IPv4 address to assign to this interface.This field is only available when the following conditions are met:- `typev4` must be one of [ static, dhcp ]
    ipaddrv6: Sets the IPv6 address to assign to this interface.This field is only available when the following conditions are met:- `typev6` must be one of [ staticv6, dhcp6, slaac, 6rd, track6, 6to4 ]
    ipv6usev4iface: Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    media: Sets the link speed for this interface. In most situations this can be left as the default.
    mediaopt: Sets the link duplex for this interface. In most situations this can be left as the default.
    mss: Sets the MSS for this interface. Assumes default MSS if value is `null`.
    mtu: Sets the MTU for this interface. Assumes default MTU if value is `null`.
    prefix_6rd: Sets the 6RD IPv6 prefix assigned by the ISP for this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    prefix_6rd_v4plen: Sets the 6RD IPv4 prefix length. Normally specified by the ISP. A value of 0 means embed theentire IPv4 address in the 6RD prefix.This field is only available when the following conditions are met:- `typev6` must be equal to `'6rd'`
    slaacusev4iface: Enable or disable IPv6 using the IPv4 connectivity link (PPPoE).This field is only available when the following conditions are met:- `typev6` must be equal to `'slaac'`
    spoofmac: Assigns (spoofs) the MAC address for this interface instead of using the interface's real MAC.
    subnet: Sets the subnet bit count to assign this interface.This field is only available when the following conditions are met:- `typev4` must be equal to `'static'`
    subnetv6: Sets the subnet bit count to assign this interface.This field is only available when the following conditions are met:- `typev6` must be equal to `'staticv6'`
    track6_interface: Sets the dynamic IPv6 WAN interface to track for configuration.This field is only available when the following conditions are met:- `typev6` must be equal to `'track6'`
    track6_prefix_id_hex: Sets the hexadecimal IPv6 prefix ID. This determines the configurable network ID based on the dynamic IPv6 connection.This field is only available when the following conditions are met:- `typev6` must be equal to `'track6'`
    typev4: Selects the IPv4 address type to assign this interface. Valid values: ['static', 'dhcp', 'none']
    typev6: Selects the IPv6 address type to assign this interface. Valid values: ['staticv6', 'dhcp6', 'slaac', '6rd', 'track6', '6to4', 'none']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/interface. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if adv_dhcp_config_advanced is not None:
        body["adv_dhcp_config_advanced"] = adv_dhcp_config_advanced
    if adv_dhcp_config_file_override is not None:
        body["adv_dhcp_config_file_override"] = adv_dhcp_config_file_override
    if adv_dhcp_config_file_override_path is not None:
        body["adv_dhcp_config_file_override_path"] = adv_dhcp_config_file_override_path
    if adv_dhcp_option_modifiers is not None:
        body["adv_dhcp_option_modifiers"] = adv_dhcp_option_modifiers
    if adv_dhcp_pt_backoff_cutoff is not None:
        body["adv_dhcp_pt_backoff_cutoff"] = adv_dhcp_pt_backoff_cutoff
    if adv_dhcp_pt_initial_interval is not None:
        body["adv_dhcp_pt_initial_interval"] = adv_dhcp_pt_initial_interval
    if adv_dhcp_pt_reboot is not None:
        body["adv_dhcp_pt_reboot"] = adv_dhcp_pt_reboot
    if adv_dhcp_pt_retry is not None:
        body["adv_dhcp_pt_retry"] = adv_dhcp_pt_retry
    if adv_dhcp_pt_select_timeout is not None:
        body["adv_dhcp_pt_select_timeout"] = adv_dhcp_pt_select_timeout
    if adv_dhcp_pt_timeout is not None:
        body["adv_dhcp_pt_timeout"] = adv_dhcp_pt_timeout
    if adv_dhcp_pt_values is not None:
        body["adv_dhcp_pt_values"] = adv_dhcp_pt_values
    if adv_dhcp_request_options is not None:
        body["adv_dhcp_request_options"] = adv_dhcp_request_options
    if adv_dhcp_required_options is not None:
        body["adv_dhcp_required_options"] = adv_dhcp_required_options
    if adv_dhcp_send_options is not None:
        body["adv_dhcp_send_options"] = adv_dhcp_send_options
    if alias_address is not None:
        body["alias_address"] = alias_address
    if alias_subnet is not None:
        body["alias_subnet"] = alias_subnet
    if blockbogons is not None:
        body["blockbogons"] = blockbogons
    if blockpriv is not None:
        body["blockpriv"] = blockpriv
    if descr is not None:
        body["descr"] = descr
    if dhcphostname is not None:
        body["dhcphostname"] = dhcphostname
    if dhcprejectfrom is not None:
        body["dhcprejectfrom"] = dhcprejectfrom
    if enable is not None:
        body["enable"] = enable
    if gateway is not None:
        body["gateway"] = gateway
    if gateway_6rd is not None:
        body["gateway_6rd"] = gateway_6rd
    if gatewayv6 is not None:
        body["gatewayv6"] = gatewayv6
    if if_ is not None:
        body["if"] = if_
    if ipaddr is not None:
        body["ipaddr"] = ipaddr
    if ipaddrv6 is not None:
        body["ipaddrv6"] = ipaddrv6
    if ipv6usev4iface is not None:
        body["ipv6usev4iface"] = ipv6usev4iface
    if media is not None:
        body["media"] = media
    if mediaopt is not None:
        body["mediaopt"] = mediaopt
    if mss is not None:
        body["mss"] = mss
    if mtu is not None:
        body["mtu"] = mtu
    if prefix_6rd is not None:
        body["prefix_6rd"] = prefix_6rd
    if prefix_6rd_v4plen is not None:
        body["prefix_6rd_v4plen"] = prefix_6rd_v4plen
    if slaacusev4iface is not None:
        body["slaacusev4iface"] = slaacusev4iface
    if spoofmac is not None:
        body["spoofmac"] = spoofmac
    if subnet is not None:
        body["subnet"] = subnet
    if subnetv6 is not None:
        body["subnetv6"] = subnetv6
    if track6_interface is not None:
        body["track6_interface"] = track6_interface
    if track6_prefix_id_hex is not None:
        body["track6_prefix_id_hex"] = track6_prefix_id_hex
    if typev4 is not None:
        body["typev4"] = typev4
    if typev6 is not None:
        body["typev6"] = typev6
    return await _client.request(
        "PATCH",
        "/api/v2/interface",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_network_interface(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interface

    Note: Call pfsense_interface_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interface. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_interface_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/interface",
        params=params,
    )


@mcp.tool()
async def pfsense_list_network_interfaces(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/interfaces

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_network_interfaces(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/interfaces

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/interfaces. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_get_routing_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/routing/apply",
    )


@mcp.tool()
async def pfsense_routing_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/routing/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/routing/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/routing/apply",
    )


@mcp.tool()
async def pfsense_get_routing_gateway_default(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway/default
    """
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway/default",
    )


@mcp.tool()
async def pfsense_update_routing_gateway_default(
    confirm: bool = False,
    defaultgw4: str | None = None,
    defaultgw6: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/routing/gateway/default

    Note: Call pfsense_routing_apply after this to apply changes.

    defaultgw4: The gateway to assigns as the default IPv4 gateway for this system. Leave blank to automatically determine the default gateway, or set to `-` to assign no gateway.
    defaultgw6: The gateway to assigns as the default IPv6 gateway for this system. Leave blank to automatically determine the default gateway, or set to `-` to assign no gateway.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/routing/gateway/default. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if defaultgw4 is not None:
        body["defaultgw4"] = defaultgw4
    if defaultgw6 is not None:
        body["defaultgw6"] = defaultgw6
    return await _client.request(
        "PATCH",
        "/api/v2/routing/gateway/default",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_routing_gateway(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway",
        params=params,
    )


@mcp.tool()
async def pfsense_create_routing_gateway(
    gateway: str,
    interface: str,
    ipprotocol: str,
    name: str,
    confirm: bool = False,
    action_disable: bool | None = None,
    alert_interval: int | None = 1000,
    data_payload: int | None = 1,
    descr: str | None = None,
    disabled: bool | None = None,
    dpinger_dont_add_static_route: bool | None = None,
    force_down: bool | None = None,
    gw_down_kill_states: str | None = None,
    interval: int | None = 500,
    latencyhigh: int | None = 500,
    latencylow: int | None = 200,
    loss_interval: int | None = 2000,
    losshigh: int | None = 20,
    losslow: int | None = 10,
    monitor: str | None = None,
    monitor_disable: bool | None = None,
    nonlocalgateway: bool | None = True,
    time_period: int | None = 60000,
    weight: int | None = 1,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/routing/gateway

    Note: Call pfsense_routing_apply after this to apply changes.

    gateway: Sets the IP address of the remote gateway.
    interface: Sets the interface this gateway will apply to.
    ipprotocol: Sets the Internet Protocol version this gateway uses. Valid values: ['inet', 'inet6']
    name: Sets a name for the gateway.
    action_disable: Disable actions from taking place when gateway events occur. The gateway will always be considered up.
    alert_interval: Sets the time interval in milliseconds between checking for an alert conditions.
    data_payload: Sets the data payload to send in ICMP packets to gateway monitor IP.
    descr: Sets a descriptions for the gateway.
    disabled: Disable this gateway.
    dpinger_dont_add_static_route: Prevents gateway monitoring from adding a static route for this gateway's monitor IP.
    force_down: Always consider this gateway to be up.
    gw_down_kill_states: Controls the state killing behavior when this specific gateway goes down. Killing states for specific down gateways only affects states created by policy routing rules and reply-to. Has no effect if gateway monitoring or its action are disabled or if the gateway is forced down. May not have any effect on dynamic gateways during a link loss event. Valid values: ['', 'none', 'down']
    interval: Sets how often ICMP probes will be sent in milliseconds.
    latencyhigh: Sets the threshold to consider latency as high. This value must be greater than `latencylow`.
    latencylow: Sets the threshold to consider latency as low.
    loss_interval: Sets the time interval in milliseconds before packets are treated as lost.
    losshigh: Sets the threshold to consider packet loss as high. This value must be greater than `losslow`.
    losslow: Sets the threshold to consider packet loss as low.
    monitor: Sets a different IP address to use when monitoring this gateway. This is typically only necessary if the gateway IP does not accept ICMP probes.This field is only available when the following conditions are met:- `monitor_disable` must be equal to `false`
    monitor_disable: Disable gateway monitoring for this gateway.
    nonlocalgateway: Allows or disallows gateway IPs that are not a part of the parent interface's subnet(s).
    time_period: Sets the time period in milliseconds over which results are averaged.
    weight: Sets the weight for this gateway when used in a Gateway Group.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/routing/gateway. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if gateway is not None:
        body["gateway"] = gateway
    if interface is not None:
        body["interface"] = interface
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if name is not None:
        body["name"] = name
    if action_disable is not None:
        body["action_disable"] = action_disable
    if alert_interval is not None:
        body["alert_interval"] = alert_interval
    if data_payload is not None:
        body["data_payload"] = data_payload
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if dpinger_dont_add_static_route is not None:
        body["dpinger_dont_add_static_route"] = dpinger_dont_add_static_route
    if force_down is not None:
        body["force_down"] = force_down
    if gw_down_kill_states is not None:
        body["gw_down_kill_states"] = gw_down_kill_states
    if interval is not None:
        body["interval"] = interval
    if latencyhigh is not None:
        body["latencyhigh"] = latencyhigh
    if latencylow is not None:
        body["latencylow"] = latencylow
    if loss_interval is not None:
        body["loss_interval"] = loss_interval
    if losshigh is not None:
        body["losshigh"] = losshigh
    if losslow is not None:
        body["losslow"] = losslow
    if monitor is not None:
        body["monitor"] = monitor
    if monitor_disable is not None:
        body["monitor_disable"] = monitor_disable
    if nonlocalgateway is not None:
        body["nonlocalgateway"] = nonlocalgateway
    if time_period is not None:
        body["time_period"] = time_period
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "POST",
        "/api/v2/routing/gateway",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_routing_gateway(
    id: str | int,
    confirm: bool = False,
    action_disable: bool | None = None,
    alert_interval: int | None = None,
    data_payload: int | None = None,
    descr: str | None = None,
    disabled: bool | None = None,
    dpinger_dont_add_static_route: bool | None = None,
    force_down: bool | None = None,
    gateway: str | None = None,
    gw_down_kill_states: str | None = None,
    interface: str | None = None,
    interval: int | None = None,
    ipprotocol: str | None = None,
    latencyhigh: int | None = None,
    latencylow: int | None = None,
    loss_interval: int | None = None,
    losshigh: int | None = None,
    losslow: int | None = None,
    monitor: str | None = None,
    monitor_disable: bool | None = None,
    name: str | None = None,
    nonlocalgateway: bool | None = None,
    time_period: int | None = None,
    weight: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/routing/gateway

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    action_disable: Disable actions from taking place when gateway events occur. The gateway will always be considered up.
    alert_interval: Sets the time interval in milliseconds between checking for an alert conditions.
    data_payload: Sets the data payload to send in ICMP packets to gateway monitor IP.
    descr: Sets a descriptions for the gateway.
    disabled: Disable this gateway.
    dpinger_dont_add_static_route: Prevents gateway monitoring from adding a static route for this gateway's monitor IP.
    force_down: Always consider this gateway to be up.
    gateway: Sets the IP address of the remote gateway.
    gw_down_kill_states: Controls the state killing behavior when this specific gateway goes down. Killing states for specific down gateways only affects states created by policy routing rules and reply-to. Has no effect if gateway monitoring or its action are disabled or if the gateway is forced down. May not have any effect on dynamic gateways during a link loss event. Valid values: ['', 'none', 'down']
    interface: Sets the interface this gateway will apply to.
    interval: Sets how often ICMP probes will be sent in milliseconds.
    ipprotocol: Sets the Internet Protocol version this gateway uses. Valid values: ['inet', 'inet6']
    latencyhigh: Sets the threshold to consider latency as high. This value must be greater than `latencylow`.
    latencylow: Sets the threshold to consider latency as low.
    loss_interval: Sets the time interval in milliseconds before packets are treated as lost.
    losshigh: Sets the threshold to consider packet loss as high. This value must be greater than `losslow`.
    losslow: Sets the threshold to consider packet loss as low.
    monitor: Sets a different IP address to use when monitoring this gateway. This is typically only necessary if the gateway IP does not accept ICMP probes.This field is only available when the following conditions are met:- `monitor_disable` must be equal to `false`
    monitor_disable: Disable gateway monitoring for this gateway.
    name: Sets a name for the gateway.
    nonlocalgateway: Allows or disallows gateway IPs that are not a part of the parent interface's subnet(s).
    time_period: Sets the time period in milliseconds over which results are averaged.
    weight: Sets the weight for this gateway when used in a Gateway Group.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/routing/gateway. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if action_disable is not None:
        body["action_disable"] = action_disable
    if alert_interval is not None:
        body["alert_interval"] = alert_interval
    if data_payload is not None:
        body["data_payload"] = data_payload
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if dpinger_dont_add_static_route is not None:
        body["dpinger_dont_add_static_route"] = dpinger_dont_add_static_route
    if force_down is not None:
        body["force_down"] = force_down
    if gateway is not None:
        body["gateway"] = gateway
    if gw_down_kill_states is not None:
        body["gw_down_kill_states"] = gw_down_kill_states
    if interface is not None:
        body["interface"] = interface
    if interval is not None:
        body["interval"] = interval
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if latencyhigh is not None:
        body["latencyhigh"] = latencyhigh
    if latencylow is not None:
        body["latencylow"] = latencylow
    if loss_interval is not None:
        body["loss_interval"] = loss_interval
    if losshigh is not None:
        body["losshigh"] = losshigh
    if losslow is not None:
        body["losslow"] = losslow
    if monitor is not None:
        body["monitor"] = monitor
    if monitor_disable is not None:
        body["monitor_disable"] = monitor_disable
    if name is not None:
        body["name"] = name
    if nonlocalgateway is not None:
        body["nonlocalgateway"] = nonlocalgateway
    if time_period is not None:
        body["time_period"] = time_period
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "PATCH",
        "/api/v2/routing/gateway",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_routing_gateway(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateway

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateway. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateway",
        params=params,
    )


@mcp.tool()
async def pfsense_get_routing_gateway_group(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway/group

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway/group",
        params=params,
    )


@mcp.tool()
async def pfsense_create_routing_gateway_group(
    name: str,
    priorities: list[dict[str, Any]],
    confirm: bool = False,
    descr: str | None = None,
    trigger: str | None = 'down',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/routing/gateway/group

    Note: Call pfsense_routing_apply after this to apply changes.

    name: The name of the gateway group.
    priorities: The priorities of the gateways in this group.
    descr: A description of the gateway group.
    trigger: The trigger that will cause a gateway to be excluded from the group. Valid values: ['down', 'downloss', 'downlatency', 'downlosslatency']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/routing/gateway/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if priorities is not None:
        body["priorities"] = priorities
    if descr is not None:
        body["descr"] = descr
    if trigger is not None:
        body["trigger"] = trigger
    return await _client.request(
        "POST",
        "/api/v2/routing/gateway/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_routing_gateway_group(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    name: str | None = None,
    priorities: list[dict[str, Any]] | None = None,
    trigger: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/routing/gateway/group

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description of the gateway group.
    name: The name of the gateway group.
    priorities: The priorities of the gateways in this group.
    trigger: The trigger that will cause a gateway to be excluded from the group. Valid values: ['down', 'downloss', 'downlatency', 'downlosslatency']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/routing/gateway/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if name is not None:
        body["name"] = name
    if priorities is not None:
        body["priorities"] = priorities
    if trigger is not None:
        body["trigger"] = trigger
    return await _client.request(
        "PATCH",
        "/api/v2/routing/gateway/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_routing_gateway_group(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateway/group

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateway/group. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateway/group",
        params=params,
    )


@mcp.tool()
async def pfsense_list_routing_gateway_group_priorities(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway/group/priorities

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway/group/priorities",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_routing_gateway_group_priorities(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateway/group/priorities

    Note: Call pfsense_routing_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateway/group/priorities. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateway/group/priorities",
        params=params,
    )


@mcp.tool()
async def pfsense_get_routing_gateway_group_priority(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway/group/priority

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway/group/priority",
        params=params,
    )


@mcp.tool()
async def pfsense_create_routing_gateway_group_priority(
    gateway: str,
    parent_id: str | int,
    tier: int,
    confirm: bool = False,
    virtual_ip: str | None = 'address',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/routing/gateway/group/priority

    Note: Call pfsense_routing_apply after this to apply changes.

    gateway: The name of the gateway to prioritize in this gateway group.
    parent_id: The ID of the parent this object is nested under.
    tier: The priority of this gateway in the group. Lower numbered tiers are higher priority.
    virtual_ip: The virtual IP to use for this gateway group. Use `address` to use the interface's current IP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/routing/gateway/group/priority. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if gateway is not None:
        body["gateway"] = gateway
    if parent_id is not None:
        body["parent_id"] = parent_id
    if tier is not None:
        body["tier"] = tier
    if virtual_ip is not None:
        body["virtual_ip"] = virtual_ip
    return await _client.request(
        "POST",
        "/api/v2/routing/gateway/group/priority",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_routing_gateway_group_priority(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    gateway: str | None = None,
    tier: int | None = None,
    virtual_ip: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/routing/gateway/group/priority

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    gateway: The name of the gateway to prioritize in this gateway group.
    tier: The priority of this gateway in the group. Lower numbered tiers are higher priority.
    virtual_ip: The virtual IP to use for this gateway group. Use `address` to use the interface's current IP.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/routing/gateway/group/priority. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if gateway is not None:
        body["gateway"] = gateway
    if tier is not None:
        body["tier"] = tier
    if virtual_ip is not None:
        body["virtual_ip"] = virtual_ip
    return await _client.request(
        "PATCH",
        "/api/v2/routing/gateway/group/priority",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_routing_gateway_group_priority(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateway/group/priority

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateway/group/priority. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateway/group/priority",
        params=params,
    )


@mcp.tool()
async def pfsense_list_routing_gateway_groups(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateway/groups

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/routing/gateway/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_routing_gateway_groups(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateway/groups

    Note: Call pfsense_routing_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateway/groups. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateway/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_list_routing_gateways(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/gateways

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/routing/gateways",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_routing_gateways(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/gateways

    Note: Call pfsense_routing_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/gateways. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/routing/gateways",
        params=params,
    )


@mcp.tool()
async def pfsense_get_routing_static_route(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/static_route

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/routing/static_route",
        params=params,
    )


@mcp.tool()
async def pfsense_create_routing_static_route(
    gateway: str,
    network: str,
    confirm: bool = False,
    descr: str | None = None,
    disabled: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/routing/static_route

    Note: Call pfsense_routing_apply after this to apply changes.

    gateway: Sets which gateway this route applies to.
    network: Sets the destination network for this static route in CIDR notation.
    descr: Sets a description for administrative reference.
    disabled: Disable this static route.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/routing/static_route. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if gateway is not None:
        body["gateway"] = gateway
    if network is not None:
        body["network"] = network
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    return await _client.request(
        "POST",
        "/api/v2/routing/static_route",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_routing_static_route(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    disabled: bool | None = None,
    gateway: str | None = None,
    network: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/routing/static_route

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: Sets a description for administrative reference.
    disabled: Disable this static route.
    gateway: Sets which gateway this route applies to.
    network: Sets the destination network for this static route in CIDR notation.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/routing/static_route. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if gateway is not None:
        body["gateway"] = gateway
    if network is not None:
        body["network"] = network
    return await _client.request(
        "PATCH",
        "/api/v2/routing/static_route",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_routing_static_route(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/static_route

    Note: Call pfsense_routing_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/static_route. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/routing/static_route",
        params=params,
    )


@mcp.tool()
async def pfsense_list_routing_static_routes(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/routing/static_routes

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/routing/static_routes",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_routing_static_routes(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/routing/static_routes

    Note: Call pfsense_routing_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/routing/static_routes. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_routing_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/routing/static_routes",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_acme_account_key(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/account_key

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/acme/account_key",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_account_key(
    acmeserver: str,
    name: str,
    confirm: bool = False,
    accountkey: str | None = None,
    descr: str | None = None,
    email: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/account_key

    acmeserver: The ACME server this account key will belong to.
    name: The name of the ACME account key.
    accountkey: The RSA private key for the ACME account key.
    descr: A description of the ACME account key.
    email: The email address associated with the ACME account key.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/account_key. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if acmeserver is not None:
        body["acmeserver"] = acmeserver
    if name is not None:
        body["name"] = name
    if accountkey is not None:
        body["accountkey"] = accountkey
    if descr is not None:
        body["descr"] = descr
    if email is not None:
        body["email"] = email
    return await _client.request(
        "POST",
        "/api/v2/services/acme/account_key",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_acme_account_key(
    id: str | int,
    confirm: bool = False,
    accountkey: str | None = None,
    acmeserver: str | None = None,
    descr: str | None = None,
    email: str | None = None,
    name: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/acme/account_key

    id: The ID of the object or resource to interact with.
    accountkey: The RSA private key for the ACME account key.
    acmeserver: The ACME server this account key will belong to.
    descr: A description of the ACME account key.
    email: The email address associated with the ACME account key.
    name: The name of the ACME account key.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/acme/account_key. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if accountkey is not None:
        body["accountkey"] = accountkey
    if acmeserver is not None:
        body["acmeserver"] = acmeserver
    if descr is not None:
        body["descr"] = descr
    if email is not None:
        body["email"] = email
    if name is not None:
        body["name"] = name
    return await _client.request(
        "PATCH",
        "/api/v2/services/acme/account_key",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_account_key(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/account_key

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/account_key. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/account_key",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_account_key_register(
    name: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/account_key/register

    name: The name of the ACME account key to register.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/account_key/register. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    return await _client.request(
        "POST",
        "/api/v2/services/acme/account_key/register",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_services_acme_account_key_registrations(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/account_key/registrations

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/acme/account_key/registrations",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_acme_account_keys(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/account_keys

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/acme/account_keys",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_acme_account_keys(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/acme/account_keys

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/acme/account_keys. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/acme/account_keys",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_account_keys(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/account_keys

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/account_keys. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/account_keys",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_acme_certificate_action(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificate/action

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificate/action",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_certificate_action(
    command: str,
    method: str,
    parent_id: str | int,
    confirm: bool = False,
    status: str | None = 'active',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/certificate/action

    command: The command to execute on the ACME certificate.
    method: The action method that should be used to run the command. Valid values: ['shellcommand', 'php_command', 'servicerestart', 'xmlrpcservicerestart']
    parent_id: The ID of the parent this object is nested under.
    status: The activation status of the ACME certificate. Valid values: ['active', 'disabled']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/certificate/action. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if command is not None:
        body["command"] = command
    if method is not None:
        body["method"] = method
    if parent_id is not None:
        body["parent_id"] = parent_id
    if status is not None:
        body["status"] = status
    return await _client.request(
        "POST",
        "/api/v2/services/acme/certificate/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_acme_certificate_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    command: str | None = None,
    method: str | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/acme/certificate/action

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    command: The command to execute on the ACME certificate.
    method: The action method that should be used to run the command. Valid values: ['shellcommand', 'php_command', 'servicerestart', 'xmlrpcservicerestart']
    status: The activation status of the ACME certificate. Valid values: ['active', 'disabled']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/acme/certificate/action. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if command is not None:
        body["command"] = command
    if method is not None:
        body["method"] = method
    if status is not None:
        body["status"] = status
    return await _client.request(
        "PATCH",
        "/api/v2/services/acme/certificate/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_certificate_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/certificate/action

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/certificate/action. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/certificate/action",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_acme_certificate_domain(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificate/domain

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificate/domain",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_certificate_domain(
    method: str,
    name: str,
    parent_id: str | int,
    confirm: bool = False,
    ULTRA_PWD: str | None = None,
    acmedns_password: str | None = None,
    acmedns_subdomain: str | None = None,
    acmedns_update_url: str | None = None,
    acmedns_username: str | None = None,
    acmeproxy_endpoint: str | None = None,
    acmeproxy_password: str | None = None,
    acmeproxy_username: str | None = None,
    active24_token: str | None = None,
    ad_api_key: str | None = None,
    af_api_password: str | None = None,
    af_api_username: str | None = None,
    akamai_access_token: str | None = None,
    akamai_client_secret: str | None = None,
    akamai_client_token: str | None = None,
    akamai_host: str | None = None,
    ali_key: str | None = None,
    ali_secret: str | None = None,
    anx_token: str | None = None,
    anydnschallengealias: str | None = None,
    anydnschallengedomain: bool | None = None,
    arvan_token: str | None = None,
    aurora_key: str | None = None,
    aurora_secret: str | None = None,
    autodns_context: str | None = None,
    autodns_password: str | None = None,
    autodns_user: str | None = None,
    aws_access_key_id: str | None = None,
    aws_dns_slowrate: str | None = None,
    aws_secret_access_key: str | None = None,
    azion_email: str | None = None,
    azion_password: str | None = None,
    azuredns_appid: str | None = None,
    azuredns_clientsecret: str | None = None,
    azuredns_subscriptionid: str | None = None,
    azuredns_tenantid: str | None = None,
    bookmyname_password: str | None = None,
    bookmyname_username: str | None = None,
    bunny_api_key: str | None = None,
    cf_account_id: str | None = None,
    cf_email: str | None = None,
    cf_key: str | None = None,
    cf_token: str | None = None,
    cf_zone_id: str | None = None,
    clouddns_client_id: str | None = None,
    clouddns_email: str | None = None,
    clouddns_password: str | None = None,
    cloudns_auth_id: str | None = None,
    cloudns_auth_password: str | None = None,
    cloudns_sub_auth_id: str | None = None,
    cn_password: str | None = None,
    cn_user: str | None = None,
    conoha_identityserviceapi: str | None = None,
    conoha_password: str | None = None,
    conoha_tenantid: str | None = None,
    conoha_username: str | None = None,
    constellix_key: str | None = None,
    constellix_secret: str | None = None,
    cpanel_apitoken: str | None = None,
    cpanel_hostname: str | None = None,
    cpanel_username: str | None = None,
    curanet_authclientid: str | None = None,
    curanet_authsecret: str | None = None,
    cy_password: str | None = None,
    cy_username: str | None = None,
    da_api: str | None = None,
    da_api_insecure: str | None = None,
    dd_api_key: str | None = None,
    dd_api_user: str | None = None,
    ddnss_token: str | None = None,
    dedyn_name: str | None = None,
    dedyn_token: str | None = None,
    default_infomaniak_api_url: str | None = None,
    df_password: str | None = None,
    df_user: str | None = None,
    dh_api_key: str | None = None,
    dnsexit_api_key: str | None = None,
    dnsexit_auth_pass: str | None = None,
    dnsexit_auth_user: str | None = None,
    dnshome_subdomain: str | None = None,
    dnshome_subdomainpassword: str | None = None,
    dnsimple_oauth_token: str | None = None,
    dnsservices_password: str | None = None,
    dnsservices_username: str | None = None,
    do_api_key: str | None = None,
    do_letoken: str | None = None,
    do_pid: str | None = None,
    do_pw: str | None = None,
    domeneshop_secret: str | None = None,
    domeneshop_token: str | None = None,
    dp_id: str | None = None,
    dp_key: str | None = None,
    dpi_id: str | None = None,
    dpi_key: str | None = None,
    duckdns_token: str | None = None,
    dyn_customer: str | None = None,
    dyn_password: str | None = None,
    dyn_username: str | None = None,
    dynu_clientid: str | None = None,
    dynu_secret: str | None = None,
    easydns_key: str | None = None,
    easydns_token: str | None = None,
    euserv_password: str | None = None,
    euserv_username: str | None = None,
    exoscale_api_key: str | None = None,
    exoscale_secret_key: str | None = None,
    fornex_api_key: str | None = None,
    freedns_password: str | None = None,
    freedns_user: str | None = None,
    gandi_livedns_key: str | None = None,
    gcore_key: str | None = None,
    gd_key: str | None = None,
    gd_secret: str | None = None,
    geoscaling_password: str | None = None,
    geoscaling_username: str | None = None,
    googledomains_access_token: str | None = None,
    googledomains_zone: str | None = None,
    he_password: str | None = None,
    he_username: str | None = None,
    hetzner_token: str | None = None,
    hexonet_login: str | None = None,
    hexonet_password: str | None = None,
    hostingde_apikey: str | None = None,
    hostingde_endpoint: str | None = None,
    huaweicloud_domainname: str | None = None,
    huaweicloud_password: str | None = None,
    huaweicloud_username: str | None = None,
    infoblox_creds: str | None = None,
    infoblox_server: str | None = None,
    infoblox_view: str | None = None,
    infomaniak_api_token: str | None = None,
    infomaniak_ttl: str | None = None,
    internetbs_api_key: str | None = None,
    internetbs_api_password: str | None = None,
    inwx_password: str | None = None,
    inwx_shared_secret: str | None = None,
    inwx_username: str | None = None,
    ionos_prefix: str | None = None,
    ionos_secret: str | None = None,
    ipv64_token: str | None = None,
    ispc_api: str | None = None,
    ispc_api_insecure: str | None = None,
    ispc_password: str | None = None,
    ispc_user: str | None = None,
    jd_access_key_id: str | None = None,
    jd_access_key_secret: str | None = None,
    jd_region: str | None = None,
    joker_password: str | None = None,
    joker_username: str | None = None,
    kappernetdns_key: str | None = None,
    kappernetdns_secret: str | None = None,
    kas_authdata: str | None = None,
    kas_authtype: str | None = None,
    kas_login: str | None = None,
    kinghost_password: str | None = None,
    kinghost_username: str | None = None,
    knot_key: str | None = None,
    knot_server: str | None = None,
    la_id: str | None = None,
    la_key: str | None = None,
    limacity_apikey: str | None = None,
    linode_api_key: str | None = None,
    linode_v4_api_key: str | None = None,
    loopia_password: str | None = None,
    loopia_user: str | None = None,
    lsw_key: str | None = None,
    lua_email: str | None = None,
    lua_key: str | None = None,
    mb_ak: str | None = None,
    mb_as: str | None = None,
    me_key: str | None = None,
    me_secret: str | None = None,
    miab_password: str | None = None,
    miab_server: str | None = None,
    miab_username: str | None = None,
    misaka_key: str | None = None,
    mydnsjp_masterid: str | None = None,
    mydnsjp_password: str | None = None,
    namecheap_api_key: str | None = None,
    namecheap_username: str | None = None,
    namecom_token: str | None = None,
    namecom_username: str | None = None,
    namesilo_key: str | None = None,
    nanelo_token: str | None = None,
    nc_apikey: str | None = None,
    nc_apipw: str | None = None,
    nc_cid: str | None = None,
    nederhost_key: str | None = None,
    neodigit_api_token: str | None = None,
    netlify_access_token: str | None = None,
    nic_clientid: str | None = None,
    nic_clientsecret: str | None = None,
    nic_password: str | None = None,
    nic_username: str | None = None,
    nm_sha256: str | None = None,
    nm_user: str | None = None,
    ns1_key: str | None = None,
    nsupdate_key: str | None = None,
    nsupdate_keyalgo: str | None = None,
    nsupdate_keyname: str | None = None,
    nsupdate_server: str | None = None,
    nsupdate_zone: str | None = None,
    nw_api_endpoint: str | None = None,
    nw_api_token: str | None = None,
    oci_cli_key: str | None = None,
    oci_cli_region: str | None = None,
    oci_cli_tenancy: str | None = None,
    oci_cli_user: str | None = None,
    one984hosting_password: str | None = None,
    one984hosting_username: str | None = None,
    onecom_password: str | None = None,
    onecom_user: str | None = None,
    online_api_key: str | None = None,
    openprovider_passwordhash: str | None = None,
    openprovider_user: str | None = None,
    ovh_ak: str | None = None,
    ovh_as: str | None = None,
    ovh_ck: str | None = None,
    ovh_end_point: str | None = None,
    pdd_token: str | None = None,
    pdns_serverid: str | None = None,
    pdns_token: str | None = None,
    pdns_ttl: str | None = None,
    pdns_url: str | None = None,
    pleskxml_pass: str | None = None,
    pleskxml_uri: str | None = None,
    pleskxml_user: str | None = None,
    pointhq_email: str | None = None,
    pointhq_key: str | None = None,
    porkbun_api_key: str | None = None,
    porkbun_secret_api_key: str | None = None,
    rackcorp_apisecret: str | None = None,
    rackcorp_apiuuid: str | None = None,
    rackspace_apikey: str | None = None,
    rackspace_username: str | None = None,
    rage4_token: str | None = None,
    rage4_username: str | None = None,
    rcode0_api_token: str | None = None,
    rcode0_ttl: str | None = None,
    rcode0_url: str | None = None,
    regru_api_password: str | None = None,
    regru_api_username: str | None = None,
    scaleway_api_token: str | None = None,
    schlundtech_password: str | None = None,
    schlundtech_user: str | None = None,
    selfhostdns_map: str | None = None,
    selfhostdns_password: str | None = None,
    selfhostdns_username: str | None = None,
    servercow_api_password: str | None = None,
    servercow_api_username: str | None = None,
    simply_accountname: str | None = None,
    simply_api: str | None = None,
    simply_apikey: str | None = None,
    sl_key: str | None = None,
    standaloneipv6: bool | None = None,
    standaloneport: str | None = None,
    standalonetlsport: str | None = None,
    status: str | None = 'enable',
    tele3_key: str | None = None,
    tele3_secret: str | None = None,
    tencent_secretid: str | None = None,
    tencent_secretkey: str | None = None,
    udr_pass: str | None = None,
    udr_user: str | None = None,
    ultra_usr: str | None = None,
    uno_key: str | None = None,
    uno_user: str | None = None,
    variomedia_api_token: str | None = None,
    veesp_password: str | None = None,
    veesp_user: str | None = None,
    vercel_token: str | None = None,
    vscale_api_key: str | None = None,
    vultr_api_key: str | None = None,
    webrootfolder: str | None = None,
    webrootftpfolder: str | None = None,
    webrootftpftpserver: str | None = None,
    webrootftppassword: str | None = None,
    webrootftpusername: str | None = None,
    west_key: str | None = None,
    west_username: str | None = None,
    world4you_password: str | None = None,
    world4you_username: str | None = None,
    ws_apikey: str | None = None,
    ws_apisecret: str | None = None,
    yc_folder_id: str | None = None,
    yc_sa_id: str | None = None,
    yc_sa_key_file_pem_b64: str | None = None,
    yc_sa_key_id: str | None = None,
    yc_zone_id: str | None = None,
    zilore_key: str | None = None,
    zm_key: str | None = None,
    zone_key: str | None = None,
    zone_username: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/certificate/domain

    method: The method to use to validate this domain.
    name: The fully-qualified domain name of this domain (SAN).
    parent_id: The ID of the parent this object is nested under.
    ULTRA_PWD: UltraDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ultra'`
    acmedns_password: acme-dns.io PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_subdomain: acme-dns.io subdomainThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_update_url: (optional) Custom ACME DNS Base URLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_username: acme-dns.io UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmeproxy_endpoint: Acmeproxy Endpoint URL (https://ip:port)This field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    acmeproxy_password: Acmeproxy PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    acmeproxy_username: Acmeproxy UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    active24_token: Active24 TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_active24'`
    ad_api_key: Alwaysdata API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ad'`
    af_api_password: ArtFiles PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_artfiles'`
    af_api_username: ArtFiles UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_artfiles'`
    akamai_access_token: Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_client_secret: Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_client_token: Client TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_host: HostnameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    ali_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ali'`
    ali_secret: API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ali'`
    anx_token: API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_anx'`
    anydnschallengealias: (Optional) Adds the --challenge-alias flag to the acme.sh call.To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.More information can be found here.This field is only available when the following conditions are met:- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]
    anydnschallengedomain: (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.This field is only available when the following conditions are met:- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]
    arvan_token: Arvan API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_arvan'`
    aurora_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aurora'`
    aurora_secret: API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.This field is only available when the following conditions are met:- `method` must be equal to `'dns_aurora'`
    autodns_context: autoDNS ContextThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    autodns_password: autoDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    autodns_user: autoDNS UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    aws_access_key_id: AWS Access Key / API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    aws_dns_slowrate: Sleep interval after TXT record update, in seconds (default: 1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    aws_secret_access_key: AWS Secret Access / API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    azion_email: Account e-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azion'`
    azion_password: Account passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azion'`
    azuredns_appid: Azure App IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_clientsecret: Azure Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_subscriptionid: Azure Subscription ID. First, setup a service principal for access to the DNS Zone.This field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_tenantid: Azure Tenant IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    bookmyname_password: BookMyName PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bookmyname'`
    bookmyname_username: BookMyName UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bookmyname'`
    bunny_api_key: Bunny DNS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bunny'`
    cf_account_id: Cloudflare API Account IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_email: Cloudflare API Email AddressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_key: Cloudflare API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_token: Cloudflare API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_zone_id: Cloudflare API Zone IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    clouddns_client_id: CloudDNS client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    clouddns_email: CloudDNS e-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    clouddns_password: CloudDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    cloudns_auth_id: Authentication IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cloudns_auth_password: ClouDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cloudns_sub_auth_id: Sub authentication IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cn_password: Core Networks PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cn'`
    cn_user: Core Networks UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cn'`
    conoha_identityserviceapi: Conoha Identity Service APIThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_password: Conoha PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_tenantid: Conoha Tenant IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_username: Conoha UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    constellix_key: Constellix KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_constellix'`
    constellix_secret: Constellix SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_constellix'`
    cpanel_apitoken: cPanel API tokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    cpanel_hostname: URL to cPanel instanceThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    cpanel_username: cPanel usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    curanet_authclientid: Authentication Client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_curanet'`
    curanet_authsecret: Authentication SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_curanet'`
    cy_password: CY PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cyon'`
    cy_username: CY usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cyon'`
    da_api: DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)This field is only available when the following conditions are met:- `method` must be equal to `'dns_da'`
    da_api_insecure: DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always acceptThis field is only available when the following conditions are met:- `method` must be equal to `'dns_da'`
    dd_api_key: DurableDNS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_durabledns'`
    dd_api_user: DurableDNS API UserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_durabledns'`
    ddnss_token: API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)This field is only available when the following conditions are met:- `method` must be equal to `'dns_ddnss'`
    dedyn_name: deSEC.io UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_desec'`
    dedyn_token: deSEC.io API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_desec'`
    default_infomaniak_api_url: Infomaniak API URL (Default: https://api.infomaniak.com)This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    df_password: dyndnsfree.de PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_df'`
    df_user: dyndnsfree.de UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_df'`
    dh_api_key: Dreamhost API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dreamhost'`
    dnsexit_api_key: DNSExit API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnsexit_auth_pass: DNSExit PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnsexit_auth_user: DNSExit UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnshome_subdomain: SubdomainThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnshome'`
    dnshome_subdomainpassword: Subdomain PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnshome'`
    dnsimple_oauth_token: DNSimple oauth token, visit https://dnsimple.com/user to generate.This field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsimple'`
    dnsservices_password: dns.services PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsservices'`
    dnsservices_username: dns.services UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsservices'`
    do_api_key: DigitalOcean API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dgon'`
    do_letoken: DO.de API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_doapi'`
    do_pid: DO Customer IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_do'`
    do_pw: DO PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_do'`
    domeneshop_secret: Domeneshop API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_domeneshop'`
    domeneshop_token: Domeneshop API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_domeneshop'`
    dp_id: Dnspod API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dp'`
    dp_key: Dnspod API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dp'`
    dpi_id: Dnspod API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dpi'`
    dpi_key: Dnspod API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dpi'`
    duckdns_token: DuckDNS API Token (Look in DuckDNS account settings)This field is only available when the following conditions are met:- `method` must be equal to `'dns_duckdns'`
    dyn_customer: dyn.com customer IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dyn_password: dyn.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dyn_username: dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)This field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dynu_clientid: Dynu API Client ID created in the Dynu account settingsThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dynu'`
    dynu_secret: Dynu API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dynu'`
    easydns_key: easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.phpThis field is only available when the following conditions are met:- `method` must be equal to `'dns_easydns'`
    easydns_token: easyDNS API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_easydns'`
    euserv_password: Euserv.eu PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_euserv'`
    euserv_username: Euserv.eu UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_euserv'`
    exoscale_api_key: Exoscale API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_exoscale'`
    exoscale_secret_key: Exoscale Secret KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_exoscale'`
    fornex_api_key: Fornex API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_fornex'`
    freedns_password: FreeDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_freedns'`
    freedns_user: FreeDNS usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_freedns'`
    gandi_livedns_key: Gandi LiveDNS API Key, retrieved from https://account.gandi.netThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gandi_livedns'`
    gcore_key: Gcore API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gcore'`
    gd_key: GoDaddy API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gd'`
    gd_secret: GoDaddy API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gd'`
    geoscaling_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_geoscaling'`
    geoscaling_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_geoscaling'`
    googledomains_access_token: Google Domains API Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_googledomains'`
    googledomains_zone: Google Domains DNS ZoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_googledomains'`
    he_password: Hurricane Electric passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_he'`
    he_username: Hurricane Electric usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_he'`
    hetzner_token: Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.This field is only available when the following conditions are met:- `method` must be equal to `'dns_hetzner'`
    hexonet_login: Hexonet UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hexonet'`
    hexonet_password: Hexonet PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hexonet'`
    hostingde_apikey: Hosting.de API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hostingde'`
    hostingde_endpoint: Hosting.de API endpoint, e.g. https://secure.hosting.deThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hostingde'`
    huaweicloud_domainname: Domain NameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    huaweicloud_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    huaweicloud_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    infoblox_creds: Infoblox credentials in username:password formatThis field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infoblox_server: Infoblox server IP address or hostnameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infoblox_view: Infoblox DNS View name, or enter "default"This field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infomaniak_api_token: Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    infomaniak_ttl: Infomaniak DNS record TTL (Default: 300)This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    internetbs_api_key: Internet.BS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_internetbs'`
    internetbs_api_password: Internet.BS API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_internetbs'`
    inwx_password: INWX.de passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    inwx_shared_secret: INWX.de shared secretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    inwx_username: INWX.de usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    ionos_prefix: PrefixThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ionos'`
    ionos_secret: Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.This field is only available when the following conditions are met:- `method` must be equal to `'dns_ionos'`
    ipv64_token: IPv64.net Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ipv64'`
    ispc_api: API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )This field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_api_insecure: Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_password: ISPConfig remotePasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_user: ISPConfig remoteUserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    jd_access_key_id: jdcloud Access Key IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    jd_access_key_secret: jdcloud Access Key SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    jd_region: jdcloud RegionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    joker_password: Joker.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_joker'`
    joker_username: Joker.com UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_joker'`
    kappernetdns_key: kapper.net API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kappernet'`
    kappernetdns_secret: kapper.net API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kappernet'`
    kas_authdata: Auth dataThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kas_authtype: Auth type (default: sha1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kas_login: LoginThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kinghost_password: Kinghost API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kinghost'`
    kinghost_username: Kinghost API UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kinghost'`
    knot_key: Knot TSIG KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_knot'`
    knot_server: IP address of the Knot serverThis field is only available when the following conditions are met:- `method` must be equal to `'dns_knot'`
    la_id: IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_la'`
    la_key: KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_la'`
    limacity_apikey: API Key must have the following roles: dns.admin, domains.readerThis field is only available when the following conditions are met:- `method` must be equal to `'dns_limacity'`
    linode_api_key: Linode API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_linode'`
    linode_v4_api_key: Linode v4 API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_linode_v4'`
    loopia_password: Loopia PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_loopia'`
    loopia_user: Loopia usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_loopia'`
    lsw_key: Leaseweb API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_leaseweb'`
    lua_email: Luadns API Email AddressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_lua'`
    lua_key: Luadns API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_lua'`
    mb_ak: OAuth2 KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mythic_beasts'`
    mb_as: OAuth2 SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mythic_beasts'`
    me_key: DNSMadeEasy API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_me'`
    me_secret: DNSMadeEasy API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_me'`
    miab_password: MailinaBox PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    miab_server: MailinaBox ServerThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    miab_username: MailinaBox UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    misaka_key: misaka.io KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_misaka'`
    mydnsjp_masterid: MyDNS.jp Master IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mydnsjp'`
    mydnsjp_password: MyDNS.jp PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mydnsjp'`
    namecheap_api_key: Namecheap API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecheap'`
    namecheap_username: Namecheap UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecheap'`
    namecom_token: Name.com API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecom'`
    namecom_username: Name.com usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecom'`
    namesilo_key: Namesilo API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namesilo'`
    nanelo_token: Nanelo.com Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nanelo'`
    nc_apikey: Netcup API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nc_apipw: Netcup API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nc_cid: Netcup Customer ID/NumberThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nederhost_key: NederHost API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nederhost'`
    neodigit_api_token: Neodigit API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_neodigit'`
    netlify_access_token: Netlify API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netlify'`
    nic_clientid: nic.ru API Client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_clientsecret: nic.ru API Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_password: nic.ru PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_username: nic.ru UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nm_sha256: namemaster.de API password as SHA256 hashThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nm'`
    nm_user: namemaster.de API usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nm'`
    ns1_key: NS1 API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsone'`
    nsupdate_key: The key which authenticates updates for this zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_keyalgo: Algorithm used to generate the authentication Key for this zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'` Valid values: ['', '157', '165', '164', '163', '162', '161']
    nsupdate_keyname: (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_server: The DNS server to which updates are sent (IP address or hostname)This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_zone: (Optional) Explicitly set the zone name for updates.This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nw_api_endpoint: Choose the NW API EndpointThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nw'` Valid values: ['', 'https:\\/\\/portal.nexcess.net', 'https:\\/\\/core.thermo.io', 'https:\\/\\/my.futurehosting.com']
    nw_api_token: NW API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nw'`
    oci_cli_key: The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.This field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_region: Tenancy home regionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_tenancy: OCID of tenancy that contains the target DNS zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_user: OCID of user with permission to add/remove records from zonesThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    one984hosting_password: 1984Hosting PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_1984hosting'`
    one984hosting_username: 1984Hosting UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_1984hosting'`
    onecom_password: One.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_one'`
    onecom_user: One.com UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_one'`
    online_api_key: Online.net API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_online'`
    openprovider_passwordhash: OpenProvider Password HashThis field is only available when the following conditions are met:- `method` must be equal to `'dns_openprovider'`
    openprovider_user: OpenProvider UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_openprovider'`
    ovh_ak: OVH Application KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_as: OVH Application SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_ck: OVH Consumer KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_end_point: Choose the OVH API Endpoint / RegionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'` Valid values: ['', 'ovh-eu', 'ovh-ca', 'kimsufi-eu', 'kimsufi-ca', 'soyoustart-eu', 'soyoustart-ca', 'runabove-ca']
    pdd_token: Yandex PDD Token, generate at https://pddimp.yandex.ru/api2/admin/get_tokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yandex'`
    pdns_serverid: PowerDNS ServerId (e.g. localhost )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_token: PowerDNS Token (e.g. 0123456789ABCDEF )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_ttl: PowerDNS Record TTL (e.g. 60 )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_url: PowerDNS URL (e.g. http://ns.example.com:8081 )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pleskxml_pass: Plesk PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pleskxml_uri: Plesk Server URIThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pleskxml_user: Plesk UserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pointhq_email: PointHQ account E-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pointhq'`
    pointhq_key: PointHQ API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pointhq'`
    porkbun_api_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_porkbun'`
    porkbun_secret_api_key: Secret API Key. Obtain the key and secret from https://porkbun.com/account/apiThis field is only available when the following conditions are met:- `method` must be equal to `'dns_porkbun'`
    rackcorp_apisecret: API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackcorp'`
    rackcorp_apiuuid: API UUIDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackcorp'`
    rackspace_apikey: Rackspace API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackspace'`
    rackspace_username: Rackspace UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackspace'`
    rage4_token: TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rage4'`
    rage4_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rage4'`
    rcode0_api_token: Rcode0 API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    rcode0_ttl: Rcode0 TTLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    rcode0_url: Rcode0 URLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    regru_api_password: reg.ru API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_regru'`
    regru_api_username: reg.ru UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_regru'`
    scaleway_api_token: API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_scaleway'`
    schlundtech_password: schlundtech.de PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_schlundtech'`
    schlundtech_user: schlundtech.de UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_schlundtech'`
    selfhostdns_map: Record ID (Edit the record, value is shown in brackets)This field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    selfhostdns_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    selfhostdns_username: Username (Customer number, not email address or DynDNS account)This field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    servercow_api_password: Servercow passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_servercow'`
    servercow_api_username: Servercow usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_servercow'`
    simply_accountname: Account NameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    simply_api: API Endpoint URL. Default: https://api.simply.com/1This field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    simply_apikey: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    sl_key: Selectel API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_selectel'`
    standaloneipv6: Bind to IPv6 instead of IPv4.This field is only available when the following conditions are met:- `method` must be equal to `'standalone'`
    standaloneport: HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.This field is only available when the following conditions are met:- `method` must be equal to `'standalone'`
    standalonetlsport: TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.This field is only available when the following conditions are met:- `method` must be equal to `'standalonetls'`
    status: The activation status of the ACME certificate. Valid values: ['enable', 'disable']
    tele3_key: Tele3 KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tele3'`
    tele3_secret: Tele3 SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tele3'`
    tencent_secretid: Tencent Secret IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tencent'`
    tencent_secretkey: Tencent Secret KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tencent'`
    udr_pass: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_udr'`
    udr_user: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_udr'`
    ultra_usr: UltraDNS UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ultra'`
    uno_key: UnoEuro API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_unoeuro'`
    uno_user: UnoEuro usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_unoeuro'`
    variomedia_api_token: variomedia.de API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_variomedia'`
    veesp_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_veesp'`
    veesp_user: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_veesp'`
    vercel_token: Vercel TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vercel'`
    vscale_api_key: vscale API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vscale'`
    vultr_api_key: vultr.com API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vultr'`
    webrootfolder: Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/This field is only available when the following conditions are met:- `method` must be equal to `'webroot'`
    webrootftpfolder: Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)This field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftpftpserver: Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.This field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftppassword: Password to authenticate this user on the remote serverThis field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftpusername: Username for the remote serverThis field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    west_key: West.cn Domain API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_west_cn'`
    west_username: West.cn Domain API UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_west_cn'`
    world4you_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_world4you'`
    world4you_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_world4you'`
    ws_apikey: API Key / "Identifier" in the WS AdminThis field is only available when the following conditions are met:- `method` must be equal to `'dns_websupport'`
    ws_apisecret: API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.This field is only available when the following conditions are met:- `method` must be equal to `'dns_websupport'`
    yc_folder_id: Yandex Cloud Folder IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_id: Service Account IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_key_file_pem_b64: Base64 content of private key.This field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_key_id: Service Account IAM Key IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_zone_id: DNS Zone IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    zilore_key: Zilore API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zilore'`
    zm_key: Zonomi API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zonomi'`
    zone_key: Zone.ee API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zone'`
    zone_username: Zone.ee UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zone'`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/certificate/domain. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if method is not None:
        body["method"] = method
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if ULTRA_PWD is not None:
        body["ULTRA_PWD"] = ULTRA_PWD
    if acmedns_password is not None:
        body["acmedns_password"] = acmedns_password
    if acmedns_subdomain is not None:
        body["acmedns_subdomain"] = acmedns_subdomain
    if acmedns_update_url is not None:
        body["acmedns_update_url"] = acmedns_update_url
    if acmedns_username is not None:
        body["acmedns_username"] = acmedns_username
    if acmeproxy_endpoint is not None:
        body["acmeproxy_endpoint"] = acmeproxy_endpoint
    if acmeproxy_password is not None:
        body["acmeproxy_password"] = acmeproxy_password
    if acmeproxy_username is not None:
        body["acmeproxy_username"] = acmeproxy_username
    if active24_token is not None:
        body["active24_token"] = active24_token
    if ad_api_key is not None:
        body["ad_api_key"] = ad_api_key
    if af_api_password is not None:
        body["af_api_password"] = af_api_password
    if af_api_username is not None:
        body["af_api_username"] = af_api_username
    if akamai_access_token is not None:
        body["akamai_access_token"] = akamai_access_token
    if akamai_client_secret is not None:
        body["akamai_client_secret"] = akamai_client_secret
    if akamai_client_token is not None:
        body["akamai_client_token"] = akamai_client_token
    if akamai_host is not None:
        body["akamai_host"] = akamai_host
    if ali_key is not None:
        body["ali_key"] = ali_key
    if ali_secret is not None:
        body["ali_secret"] = ali_secret
    if anx_token is not None:
        body["anx_token"] = anx_token
    if anydnschallengealias is not None:
        body["anydnschallengealias"] = anydnschallengealias
    if anydnschallengedomain is not None:
        body["anydnschallengedomain"] = anydnschallengedomain
    if arvan_token is not None:
        body["arvan_token"] = arvan_token
    if aurora_key is not None:
        body["aurora_key"] = aurora_key
    if aurora_secret is not None:
        body["aurora_secret"] = aurora_secret
    if autodns_context is not None:
        body["autodns_context"] = autodns_context
    if autodns_password is not None:
        body["autodns_password"] = autodns_password
    if autodns_user is not None:
        body["autodns_user"] = autodns_user
    if aws_access_key_id is not None:
        body["aws_access_key_id"] = aws_access_key_id
    if aws_dns_slowrate is not None:
        body["aws_dns_slowrate"] = aws_dns_slowrate
    if aws_secret_access_key is not None:
        body["aws_secret_access_key"] = aws_secret_access_key
    if azion_email is not None:
        body["azion_email"] = azion_email
    if azion_password is not None:
        body["azion_password"] = azion_password
    if azuredns_appid is not None:
        body["azuredns_appid"] = azuredns_appid
    if azuredns_clientsecret is not None:
        body["azuredns_clientsecret"] = azuredns_clientsecret
    if azuredns_subscriptionid is not None:
        body["azuredns_subscriptionid"] = azuredns_subscriptionid
    if azuredns_tenantid is not None:
        body["azuredns_tenantid"] = azuredns_tenantid
    if bookmyname_password is not None:
        body["bookmyname_password"] = bookmyname_password
    if bookmyname_username is not None:
        body["bookmyname_username"] = bookmyname_username
    if bunny_api_key is not None:
        body["bunny_api_key"] = bunny_api_key
    if cf_account_id is not None:
        body["cf_account_id"] = cf_account_id
    if cf_email is not None:
        body["cf_email"] = cf_email
    if cf_key is not None:
        body["cf_key"] = cf_key
    if cf_token is not None:
        body["cf_token"] = cf_token
    if cf_zone_id is not None:
        body["cf_zone_id"] = cf_zone_id
    if clouddns_client_id is not None:
        body["clouddns_client_id"] = clouddns_client_id
    if clouddns_email is not None:
        body["clouddns_email"] = clouddns_email
    if clouddns_password is not None:
        body["clouddns_password"] = clouddns_password
    if cloudns_auth_id is not None:
        body["cloudns_auth_id"] = cloudns_auth_id
    if cloudns_auth_password is not None:
        body["cloudns_auth_password"] = cloudns_auth_password
    if cloudns_sub_auth_id is not None:
        body["cloudns_sub_auth_id"] = cloudns_sub_auth_id
    if cn_password is not None:
        body["cn_password"] = cn_password
    if cn_user is not None:
        body["cn_user"] = cn_user
    if conoha_identityserviceapi is not None:
        body["conoha_identityserviceapi"] = conoha_identityserviceapi
    if conoha_password is not None:
        body["conoha_password"] = conoha_password
    if conoha_tenantid is not None:
        body["conoha_tenantid"] = conoha_tenantid
    if conoha_username is not None:
        body["conoha_username"] = conoha_username
    if constellix_key is not None:
        body["constellix_key"] = constellix_key
    if constellix_secret is not None:
        body["constellix_secret"] = constellix_secret
    if cpanel_apitoken is not None:
        body["cpanel_apitoken"] = cpanel_apitoken
    if cpanel_hostname is not None:
        body["cpanel_hostname"] = cpanel_hostname
    if cpanel_username is not None:
        body["cpanel_username"] = cpanel_username
    if curanet_authclientid is not None:
        body["curanet_authclientid"] = curanet_authclientid
    if curanet_authsecret is not None:
        body["curanet_authsecret"] = curanet_authsecret
    if cy_password is not None:
        body["cy_password"] = cy_password
    if cy_username is not None:
        body["cy_username"] = cy_username
    if da_api is not None:
        body["da_api"] = da_api
    if da_api_insecure is not None:
        body["da_api_insecure"] = da_api_insecure
    if dd_api_key is not None:
        body["dd_api_key"] = dd_api_key
    if dd_api_user is not None:
        body["dd_api_user"] = dd_api_user
    if ddnss_token is not None:
        body["ddnss_token"] = ddnss_token
    if dedyn_name is not None:
        body["dedyn_name"] = dedyn_name
    if dedyn_token is not None:
        body["dedyn_token"] = dedyn_token
    if default_infomaniak_api_url is not None:
        body["default_infomaniak_api_url"] = default_infomaniak_api_url
    if df_password is not None:
        body["df_password"] = df_password
    if df_user is not None:
        body["df_user"] = df_user
    if dh_api_key is not None:
        body["dh_api_key"] = dh_api_key
    if dnsexit_api_key is not None:
        body["dnsexit_api_key"] = dnsexit_api_key
    if dnsexit_auth_pass is not None:
        body["dnsexit_auth_pass"] = dnsexit_auth_pass
    if dnsexit_auth_user is not None:
        body["dnsexit_auth_user"] = dnsexit_auth_user
    if dnshome_subdomain is not None:
        body["dnshome_subdomain"] = dnshome_subdomain
    if dnshome_subdomainpassword is not None:
        body["dnshome_subdomainpassword"] = dnshome_subdomainpassword
    if dnsimple_oauth_token is not None:
        body["dnsimple_oauth_token"] = dnsimple_oauth_token
    if dnsservices_password is not None:
        body["dnsservices_password"] = dnsservices_password
    if dnsservices_username is not None:
        body["dnsservices_username"] = dnsservices_username
    if do_api_key is not None:
        body["do_api_key"] = do_api_key
    if do_letoken is not None:
        body["do_letoken"] = do_letoken
    if do_pid is not None:
        body["do_pid"] = do_pid
    if do_pw is not None:
        body["do_pw"] = do_pw
    if domeneshop_secret is not None:
        body["domeneshop_secret"] = domeneshop_secret
    if domeneshop_token is not None:
        body["domeneshop_token"] = domeneshop_token
    if dp_id is not None:
        body["dp_id"] = dp_id
    if dp_key is not None:
        body["dp_key"] = dp_key
    if dpi_id is not None:
        body["dpi_id"] = dpi_id
    if dpi_key is not None:
        body["dpi_key"] = dpi_key
    if duckdns_token is not None:
        body["duckdns_token"] = duckdns_token
    if dyn_customer is not None:
        body["dyn_customer"] = dyn_customer
    if dyn_password is not None:
        body["dyn_password"] = dyn_password
    if dyn_username is not None:
        body["dyn_username"] = dyn_username
    if dynu_clientid is not None:
        body["dynu_clientid"] = dynu_clientid
    if dynu_secret is not None:
        body["dynu_secret"] = dynu_secret
    if easydns_key is not None:
        body["easydns_key"] = easydns_key
    if easydns_token is not None:
        body["easydns_token"] = easydns_token
    if euserv_password is not None:
        body["euserv_password"] = euserv_password
    if euserv_username is not None:
        body["euserv_username"] = euserv_username
    if exoscale_api_key is not None:
        body["exoscale_api_key"] = exoscale_api_key
    if exoscale_secret_key is not None:
        body["exoscale_secret_key"] = exoscale_secret_key
    if fornex_api_key is not None:
        body["fornex_api_key"] = fornex_api_key
    if freedns_password is not None:
        body["freedns_password"] = freedns_password
    if freedns_user is not None:
        body["freedns_user"] = freedns_user
    if gandi_livedns_key is not None:
        body["gandi_livedns_key"] = gandi_livedns_key
    if gcore_key is not None:
        body["gcore_key"] = gcore_key
    if gd_key is not None:
        body["gd_key"] = gd_key
    if gd_secret is not None:
        body["gd_secret"] = gd_secret
    if geoscaling_password is not None:
        body["geoscaling_password"] = geoscaling_password
    if geoscaling_username is not None:
        body["geoscaling_username"] = geoscaling_username
    if googledomains_access_token is not None:
        body["googledomains_access_token"] = googledomains_access_token
    if googledomains_zone is not None:
        body["googledomains_zone"] = googledomains_zone
    if he_password is not None:
        body["he_password"] = he_password
    if he_username is not None:
        body["he_username"] = he_username
    if hetzner_token is not None:
        body["hetzner_token"] = hetzner_token
    if hexonet_login is not None:
        body["hexonet_login"] = hexonet_login
    if hexonet_password is not None:
        body["hexonet_password"] = hexonet_password
    if hostingde_apikey is not None:
        body["hostingde_apikey"] = hostingde_apikey
    if hostingde_endpoint is not None:
        body["hostingde_endpoint"] = hostingde_endpoint
    if huaweicloud_domainname is not None:
        body["huaweicloud_domainname"] = huaweicloud_domainname
    if huaweicloud_password is not None:
        body["huaweicloud_password"] = huaweicloud_password
    if huaweicloud_username is not None:
        body["huaweicloud_username"] = huaweicloud_username
    if infoblox_creds is not None:
        body["infoblox_creds"] = infoblox_creds
    if infoblox_server is not None:
        body["infoblox_server"] = infoblox_server
    if infoblox_view is not None:
        body["infoblox_view"] = infoblox_view
    if infomaniak_api_token is not None:
        body["infomaniak_api_token"] = infomaniak_api_token
    if infomaniak_ttl is not None:
        body["infomaniak_ttl"] = infomaniak_ttl
    if internetbs_api_key is not None:
        body["internetbs_api_key"] = internetbs_api_key
    if internetbs_api_password is not None:
        body["internetbs_api_password"] = internetbs_api_password
    if inwx_password is not None:
        body["inwx_password"] = inwx_password
    if inwx_shared_secret is not None:
        body["inwx_shared_secret"] = inwx_shared_secret
    if inwx_username is not None:
        body["inwx_username"] = inwx_username
    if ionos_prefix is not None:
        body["ionos_prefix"] = ionos_prefix
    if ionos_secret is not None:
        body["ionos_secret"] = ionos_secret
    if ipv64_token is not None:
        body["ipv64_token"] = ipv64_token
    if ispc_api is not None:
        body["ispc_api"] = ispc_api
    if ispc_api_insecure is not None:
        body["ispc_api_insecure"] = ispc_api_insecure
    if ispc_password is not None:
        body["ispc_password"] = ispc_password
    if ispc_user is not None:
        body["ispc_user"] = ispc_user
    if jd_access_key_id is not None:
        body["jd_access_key_id"] = jd_access_key_id
    if jd_access_key_secret is not None:
        body["jd_access_key_secret"] = jd_access_key_secret
    if jd_region is not None:
        body["jd_region"] = jd_region
    if joker_password is not None:
        body["joker_password"] = joker_password
    if joker_username is not None:
        body["joker_username"] = joker_username
    if kappernetdns_key is not None:
        body["kappernetdns_key"] = kappernetdns_key
    if kappernetdns_secret is not None:
        body["kappernetdns_secret"] = kappernetdns_secret
    if kas_authdata is not None:
        body["kas_authdata"] = kas_authdata
    if kas_authtype is not None:
        body["kas_authtype"] = kas_authtype
    if kas_login is not None:
        body["kas_login"] = kas_login
    if kinghost_password is not None:
        body["kinghost_password"] = kinghost_password
    if kinghost_username is not None:
        body["kinghost_username"] = kinghost_username
    if knot_key is not None:
        body["knot_key"] = knot_key
    if knot_server is not None:
        body["knot_server"] = knot_server
    if la_id is not None:
        body["la_id"] = la_id
    if la_key is not None:
        body["la_key"] = la_key
    if limacity_apikey is not None:
        body["limacity_apikey"] = limacity_apikey
    if linode_api_key is not None:
        body["linode_api_key"] = linode_api_key
    if linode_v4_api_key is not None:
        body["linode_v4_api_key"] = linode_v4_api_key
    if loopia_password is not None:
        body["loopia_password"] = loopia_password
    if loopia_user is not None:
        body["loopia_user"] = loopia_user
    if lsw_key is not None:
        body["lsw_key"] = lsw_key
    if lua_email is not None:
        body["lua_email"] = lua_email
    if lua_key is not None:
        body["lua_key"] = lua_key
    if mb_ak is not None:
        body["mb_ak"] = mb_ak
    if mb_as is not None:
        body["mb_as"] = mb_as
    if me_key is not None:
        body["me_key"] = me_key
    if me_secret is not None:
        body["me_secret"] = me_secret
    if miab_password is not None:
        body["miab_password"] = miab_password
    if miab_server is not None:
        body["miab_server"] = miab_server
    if miab_username is not None:
        body["miab_username"] = miab_username
    if misaka_key is not None:
        body["misaka_key"] = misaka_key
    if mydnsjp_masterid is not None:
        body["mydnsjp_masterid"] = mydnsjp_masterid
    if mydnsjp_password is not None:
        body["mydnsjp_password"] = mydnsjp_password
    if namecheap_api_key is not None:
        body["namecheap_api_key"] = namecheap_api_key
    if namecheap_username is not None:
        body["namecheap_username"] = namecheap_username
    if namecom_token is not None:
        body["namecom_token"] = namecom_token
    if namecom_username is not None:
        body["namecom_username"] = namecom_username
    if namesilo_key is not None:
        body["namesilo_key"] = namesilo_key
    if nanelo_token is not None:
        body["nanelo_token"] = nanelo_token
    if nc_apikey is not None:
        body["nc_apikey"] = nc_apikey
    if nc_apipw is not None:
        body["nc_apipw"] = nc_apipw
    if nc_cid is not None:
        body["nc_cid"] = nc_cid
    if nederhost_key is not None:
        body["nederhost_key"] = nederhost_key
    if neodigit_api_token is not None:
        body["neodigit_api_token"] = neodigit_api_token
    if netlify_access_token is not None:
        body["netlify_access_token"] = netlify_access_token
    if nic_clientid is not None:
        body["nic_clientid"] = nic_clientid
    if nic_clientsecret is not None:
        body["nic_clientsecret"] = nic_clientsecret
    if nic_password is not None:
        body["nic_password"] = nic_password
    if nic_username is not None:
        body["nic_username"] = nic_username
    if nm_sha256 is not None:
        body["nm_sha256"] = nm_sha256
    if nm_user is not None:
        body["nm_user"] = nm_user
    if ns1_key is not None:
        body["ns1_key"] = ns1_key
    if nsupdate_key is not None:
        body["nsupdate_key"] = nsupdate_key
    if nsupdate_keyalgo is not None:
        body["nsupdate_keyalgo"] = nsupdate_keyalgo
    if nsupdate_keyname is not None:
        body["nsupdate_keyname"] = nsupdate_keyname
    if nsupdate_server is not None:
        body["nsupdate_server"] = nsupdate_server
    if nsupdate_zone is not None:
        body["nsupdate_zone"] = nsupdate_zone
    if nw_api_endpoint is not None:
        body["nw_api_endpoint"] = nw_api_endpoint
    if nw_api_token is not None:
        body["nw_api_token"] = nw_api_token
    if oci_cli_key is not None:
        body["oci_cli_key"] = oci_cli_key
    if oci_cli_region is not None:
        body["oci_cli_region"] = oci_cli_region
    if oci_cli_tenancy is not None:
        body["oci_cli_tenancy"] = oci_cli_tenancy
    if oci_cli_user is not None:
        body["oci_cli_user"] = oci_cli_user
    if one984hosting_password is not None:
        body["one984hosting_password"] = one984hosting_password
    if one984hosting_username is not None:
        body["one984hosting_username"] = one984hosting_username
    if onecom_password is not None:
        body["onecom_password"] = onecom_password
    if onecom_user is not None:
        body["onecom_user"] = onecom_user
    if online_api_key is not None:
        body["online_api_key"] = online_api_key
    if openprovider_passwordhash is not None:
        body["openprovider_passwordhash"] = openprovider_passwordhash
    if openprovider_user is not None:
        body["openprovider_user"] = openprovider_user
    if ovh_ak is not None:
        body["ovh_ak"] = ovh_ak
    if ovh_as is not None:
        body["ovh_as"] = ovh_as
    if ovh_ck is not None:
        body["ovh_ck"] = ovh_ck
    if ovh_end_point is not None:
        body["ovh_end_point"] = ovh_end_point
    if pdd_token is not None:
        body["pdd_token"] = pdd_token
    if pdns_serverid is not None:
        body["pdns_serverid"] = pdns_serverid
    if pdns_token is not None:
        body["pdns_token"] = pdns_token
    if pdns_ttl is not None:
        body["pdns_ttl"] = pdns_ttl
    if pdns_url is not None:
        body["pdns_url"] = pdns_url
    if pleskxml_pass is not None:
        body["pleskxml_pass"] = pleskxml_pass
    if pleskxml_uri is not None:
        body["pleskxml_uri"] = pleskxml_uri
    if pleskxml_user is not None:
        body["pleskxml_user"] = pleskxml_user
    if pointhq_email is not None:
        body["pointhq_email"] = pointhq_email
    if pointhq_key is not None:
        body["pointhq_key"] = pointhq_key
    if porkbun_api_key is not None:
        body["porkbun_api_key"] = porkbun_api_key
    if porkbun_secret_api_key is not None:
        body["porkbun_secret_api_key"] = porkbun_secret_api_key
    if rackcorp_apisecret is not None:
        body["rackcorp_apisecret"] = rackcorp_apisecret
    if rackcorp_apiuuid is not None:
        body["rackcorp_apiuuid"] = rackcorp_apiuuid
    if rackspace_apikey is not None:
        body["rackspace_apikey"] = rackspace_apikey
    if rackspace_username is not None:
        body["rackspace_username"] = rackspace_username
    if rage4_token is not None:
        body["rage4_token"] = rage4_token
    if rage4_username is not None:
        body["rage4_username"] = rage4_username
    if rcode0_api_token is not None:
        body["rcode0_api_token"] = rcode0_api_token
    if rcode0_ttl is not None:
        body["rcode0_ttl"] = rcode0_ttl
    if rcode0_url is not None:
        body["rcode0_url"] = rcode0_url
    if regru_api_password is not None:
        body["regru_api_password"] = regru_api_password
    if regru_api_username is not None:
        body["regru_api_username"] = regru_api_username
    if scaleway_api_token is not None:
        body["scaleway_api_token"] = scaleway_api_token
    if schlundtech_password is not None:
        body["schlundtech_password"] = schlundtech_password
    if schlundtech_user is not None:
        body["schlundtech_user"] = schlundtech_user
    if selfhostdns_map is not None:
        body["selfhostdns_map"] = selfhostdns_map
    if selfhostdns_password is not None:
        body["selfhostdns_password"] = selfhostdns_password
    if selfhostdns_username is not None:
        body["selfhostdns_username"] = selfhostdns_username
    if servercow_api_password is not None:
        body["servercow_api_password"] = servercow_api_password
    if servercow_api_username is not None:
        body["servercow_api_username"] = servercow_api_username
    if simply_accountname is not None:
        body["simply_accountname"] = simply_accountname
    if simply_api is not None:
        body["simply_api"] = simply_api
    if simply_apikey is not None:
        body["simply_apikey"] = simply_apikey
    if sl_key is not None:
        body["sl_key"] = sl_key
    if standaloneipv6 is not None:
        body["standaloneipv6"] = standaloneipv6
    if standaloneport is not None:
        body["standaloneport"] = standaloneport
    if standalonetlsport is not None:
        body["standalonetlsport"] = standalonetlsport
    if status is not None:
        body["status"] = status
    if tele3_key is not None:
        body["tele3_key"] = tele3_key
    if tele3_secret is not None:
        body["tele3_secret"] = tele3_secret
    if tencent_secretid is not None:
        body["tencent_secretid"] = tencent_secretid
    if tencent_secretkey is not None:
        body["tencent_secretkey"] = tencent_secretkey
    if udr_pass is not None:
        body["udr_pass"] = udr_pass
    if udr_user is not None:
        body["udr_user"] = udr_user
    if ultra_usr is not None:
        body["ultra_usr"] = ultra_usr
    if uno_key is not None:
        body["uno_key"] = uno_key
    if uno_user is not None:
        body["uno_user"] = uno_user
    if variomedia_api_token is not None:
        body["variomedia_api_token"] = variomedia_api_token
    if veesp_password is not None:
        body["veesp_password"] = veesp_password
    if veesp_user is not None:
        body["veesp_user"] = veesp_user
    if vercel_token is not None:
        body["vercel_token"] = vercel_token
    if vscale_api_key is not None:
        body["vscale_api_key"] = vscale_api_key
    if vultr_api_key is not None:
        body["vultr_api_key"] = vultr_api_key
    if webrootfolder is not None:
        body["webrootfolder"] = webrootfolder
    if webrootftpfolder is not None:
        body["webrootftpfolder"] = webrootftpfolder
    if webrootftpftpserver is not None:
        body["webrootftpftpserver"] = webrootftpftpserver
    if webrootftppassword is not None:
        body["webrootftppassword"] = webrootftppassword
    if webrootftpusername is not None:
        body["webrootftpusername"] = webrootftpusername
    if west_key is not None:
        body["west_key"] = west_key
    if west_username is not None:
        body["west_username"] = west_username
    if world4you_password is not None:
        body["world4you_password"] = world4you_password
    if world4you_username is not None:
        body["world4you_username"] = world4you_username
    if ws_apikey is not None:
        body["ws_apikey"] = ws_apikey
    if ws_apisecret is not None:
        body["ws_apisecret"] = ws_apisecret
    if yc_folder_id is not None:
        body["yc_folder_id"] = yc_folder_id
    if yc_sa_id is not None:
        body["yc_sa_id"] = yc_sa_id
    if yc_sa_key_file_pem_b64 is not None:
        body["yc_sa_key_file_pem_b64"] = yc_sa_key_file_pem_b64
    if yc_sa_key_id is not None:
        body["yc_sa_key_id"] = yc_sa_key_id
    if yc_zone_id is not None:
        body["yc_zone_id"] = yc_zone_id
    if zilore_key is not None:
        body["zilore_key"] = zilore_key
    if zm_key is not None:
        body["zm_key"] = zm_key
    if zone_key is not None:
        body["zone_key"] = zone_key
    if zone_username is not None:
        body["zone_username"] = zone_username
    return await _client.request(
        "POST",
        "/api/v2/services/acme/certificate/domain",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_acme_certificate_domain(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    ULTRA_PWD: str | None = None,
    acmedns_password: str | None = None,
    acmedns_subdomain: str | None = None,
    acmedns_update_url: str | None = None,
    acmedns_username: str | None = None,
    acmeproxy_endpoint: str | None = None,
    acmeproxy_password: str | None = None,
    acmeproxy_username: str | None = None,
    active24_token: str | None = None,
    ad_api_key: str | None = None,
    af_api_password: str | None = None,
    af_api_username: str | None = None,
    akamai_access_token: str | None = None,
    akamai_client_secret: str | None = None,
    akamai_client_token: str | None = None,
    akamai_host: str | None = None,
    ali_key: str | None = None,
    ali_secret: str | None = None,
    anx_token: str | None = None,
    anydnschallengealias: str | None = None,
    anydnschallengedomain: bool | None = None,
    arvan_token: str | None = None,
    aurora_key: str | None = None,
    aurora_secret: str | None = None,
    autodns_context: str | None = None,
    autodns_password: str | None = None,
    autodns_user: str | None = None,
    aws_access_key_id: str | None = None,
    aws_dns_slowrate: str | None = None,
    aws_secret_access_key: str | None = None,
    azion_email: str | None = None,
    azion_password: str | None = None,
    azuredns_appid: str | None = None,
    azuredns_clientsecret: str | None = None,
    azuredns_subscriptionid: str | None = None,
    azuredns_tenantid: str | None = None,
    bookmyname_password: str | None = None,
    bookmyname_username: str | None = None,
    bunny_api_key: str | None = None,
    cf_account_id: str | None = None,
    cf_email: str | None = None,
    cf_key: str | None = None,
    cf_token: str | None = None,
    cf_zone_id: str | None = None,
    clouddns_client_id: str | None = None,
    clouddns_email: str | None = None,
    clouddns_password: str | None = None,
    cloudns_auth_id: str | None = None,
    cloudns_auth_password: str | None = None,
    cloudns_sub_auth_id: str | None = None,
    cn_password: str | None = None,
    cn_user: str | None = None,
    conoha_identityserviceapi: str | None = None,
    conoha_password: str | None = None,
    conoha_tenantid: str | None = None,
    conoha_username: str | None = None,
    constellix_key: str | None = None,
    constellix_secret: str | None = None,
    cpanel_apitoken: str | None = None,
    cpanel_hostname: str | None = None,
    cpanel_username: str | None = None,
    curanet_authclientid: str | None = None,
    curanet_authsecret: str | None = None,
    cy_password: str | None = None,
    cy_username: str | None = None,
    da_api: str | None = None,
    da_api_insecure: str | None = None,
    dd_api_key: str | None = None,
    dd_api_user: str | None = None,
    ddnss_token: str | None = None,
    dedyn_name: str | None = None,
    dedyn_token: str | None = None,
    default_infomaniak_api_url: str | None = None,
    df_password: str | None = None,
    df_user: str | None = None,
    dh_api_key: str | None = None,
    dnsexit_api_key: str | None = None,
    dnsexit_auth_pass: str | None = None,
    dnsexit_auth_user: str | None = None,
    dnshome_subdomain: str | None = None,
    dnshome_subdomainpassword: str | None = None,
    dnsimple_oauth_token: str | None = None,
    dnsservices_password: str | None = None,
    dnsservices_username: str | None = None,
    do_api_key: str | None = None,
    do_letoken: str | None = None,
    do_pid: str | None = None,
    do_pw: str | None = None,
    domeneshop_secret: str | None = None,
    domeneshop_token: str | None = None,
    dp_id: str | None = None,
    dp_key: str | None = None,
    dpi_id: str | None = None,
    dpi_key: str | None = None,
    duckdns_token: str | None = None,
    dyn_customer: str | None = None,
    dyn_password: str | None = None,
    dyn_username: str | None = None,
    dynu_clientid: str | None = None,
    dynu_secret: str | None = None,
    easydns_key: str | None = None,
    easydns_token: str | None = None,
    euserv_password: str | None = None,
    euserv_username: str | None = None,
    exoscale_api_key: str | None = None,
    exoscale_secret_key: str | None = None,
    fornex_api_key: str | None = None,
    freedns_password: str | None = None,
    freedns_user: str | None = None,
    gandi_livedns_key: str | None = None,
    gcore_key: str | None = None,
    gd_key: str | None = None,
    gd_secret: str | None = None,
    geoscaling_password: str | None = None,
    geoscaling_username: str | None = None,
    googledomains_access_token: str | None = None,
    googledomains_zone: str | None = None,
    he_password: str | None = None,
    he_username: str | None = None,
    hetzner_token: str | None = None,
    hexonet_login: str | None = None,
    hexonet_password: str | None = None,
    hostingde_apikey: str | None = None,
    hostingde_endpoint: str | None = None,
    huaweicloud_domainname: str | None = None,
    huaweicloud_password: str | None = None,
    huaweicloud_username: str | None = None,
    infoblox_creds: str | None = None,
    infoblox_server: str | None = None,
    infoblox_view: str | None = None,
    infomaniak_api_token: str | None = None,
    infomaniak_ttl: str | None = None,
    internetbs_api_key: str | None = None,
    internetbs_api_password: str | None = None,
    inwx_password: str | None = None,
    inwx_shared_secret: str | None = None,
    inwx_username: str | None = None,
    ionos_prefix: str | None = None,
    ionos_secret: str | None = None,
    ipv64_token: str | None = None,
    ispc_api: str | None = None,
    ispc_api_insecure: str | None = None,
    ispc_password: str | None = None,
    ispc_user: str | None = None,
    jd_access_key_id: str | None = None,
    jd_access_key_secret: str | None = None,
    jd_region: str | None = None,
    joker_password: str | None = None,
    joker_username: str | None = None,
    kappernetdns_key: str | None = None,
    kappernetdns_secret: str | None = None,
    kas_authdata: str | None = None,
    kas_authtype: str | None = None,
    kas_login: str | None = None,
    kinghost_password: str | None = None,
    kinghost_username: str | None = None,
    knot_key: str | None = None,
    knot_server: str | None = None,
    la_id: str | None = None,
    la_key: str | None = None,
    limacity_apikey: str | None = None,
    linode_api_key: str | None = None,
    linode_v4_api_key: str | None = None,
    loopia_password: str | None = None,
    loopia_user: str | None = None,
    lsw_key: str | None = None,
    lua_email: str | None = None,
    lua_key: str | None = None,
    mb_ak: str | None = None,
    mb_as: str | None = None,
    me_key: str | None = None,
    me_secret: str | None = None,
    method: str | None = None,
    miab_password: str | None = None,
    miab_server: str | None = None,
    miab_username: str | None = None,
    misaka_key: str | None = None,
    mydnsjp_masterid: str | None = None,
    mydnsjp_password: str | None = None,
    name: str | None = None,
    namecheap_api_key: str | None = None,
    namecheap_username: str | None = None,
    namecom_token: str | None = None,
    namecom_username: str | None = None,
    namesilo_key: str | None = None,
    nanelo_token: str | None = None,
    nc_apikey: str | None = None,
    nc_apipw: str | None = None,
    nc_cid: str | None = None,
    nederhost_key: str | None = None,
    neodigit_api_token: str | None = None,
    netlify_access_token: str | None = None,
    nic_clientid: str | None = None,
    nic_clientsecret: str | None = None,
    nic_password: str | None = None,
    nic_username: str | None = None,
    nm_sha256: str | None = None,
    nm_user: str | None = None,
    ns1_key: str | None = None,
    nsupdate_key: str | None = None,
    nsupdate_keyalgo: str | None = None,
    nsupdate_keyname: str | None = None,
    nsupdate_server: str | None = None,
    nsupdate_zone: str | None = None,
    nw_api_endpoint: str | None = None,
    nw_api_token: str | None = None,
    oci_cli_key: str | None = None,
    oci_cli_region: str | None = None,
    oci_cli_tenancy: str | None = None,
    oci_cli_user: str | None = None,
    one984hosting_password: str | None = None,
    one984hosting_username: str | None = None,
    onecom_password: str | None = None,
    onecom_user: str | None = None,
    online_api_key: str | None = None,
    openprovider_passwordhash: str | None = None,
    openprovider_user: str | None = None,
    ovh_ak: str | None = None,
    ovh_as: str | None = None,
    ovh_ck: str | None = None,
    ovh_end_point: str | None = None,
    pdd_token: str | None = None,
    pdns_serverid: str | None = None,
    pdns_token: str | None = None,
    pdns_ttl: str | None = None,
    pdns_url: str | None = None,
    pleskxml_pass: str | None = None,
    pleskxml_uri: str | None = None,
    pleskxml_user: str | None = None,
    pointhq_email: str | None = None,
    pointhq_key: str | None = None,
    porkbun_api_key: str | None = None,
    porkbun_secret_api_key: str | None = None,
    rackcorp_apisecret: str | None = None,
    rackcorp_apiuuid: str | None = None,
    rackspace_apikey: str | None = None,
    rackspace_username: str | None = None,
    rage4_token: str | None = None,
    rage4_username: str | None = None,
    rcode0_api_token: str | None = None,
    rcode0_ttl: str | None = None,
    rcode0_url: str | None = None,
    regru_api_password: str | None = None,
    regru_api_username: str | None = None,
    scaleway_api_token: str | None = None,
    schlundtech_password: str | None = None,
    schlundtech_user: str | None = None,
    selfhostdns_map: str | None = None,
    selfhostdns_password: str | None = None,
    selfhostdns_username: str | None = None,
    servercow_api_password: str | None = None,
    servercow_api_username: str | None = None,
    simply_accountname: str | None = None,
    simply_api: str | None = None,
    simply_apikey: str | None = None,
    sl_key: str | None = None,
    standaloneipv6: bool | None = None,
    standaloneport: str | None = None,
    standalonetlsport: str | None = None,
    status: str | None = None,
    tele3_key: str | None = None,
    tele3_secret: str | None = None,
    tencent_secretid: str | None = None,
    tencent_secretkey: str | None = None,
    udr_pass: str | None = None,
    udr_user: str | None = None,
    ultra_usr: str | None = None,
    uno_key: str | None = None,
    uno_user: str | None = None,
    variomedia_api_token: str | None = None,
    veesp_password: str | None = None,
    veesp_user: str | None = None,
    vercel_token: str | None = None,
    vscale_api_key: str | None = None,
    vultr_api_key: str | None = None,
    webrootfolder: str | None = None,
    webrootftpfolder: str | None = None,
    webrootftpftpserver: str | None = None,
    webrootftppassword: str | None = None,
    webrootftpusername: str | None = None,
    west_key: str | None = None,
    west_username: str | None = None,
    world4you_password: str | None = None,
    world4you_username: str | None = None,
    ws_apikey: str | None = None,
    ws_apisecret: str | None = None,
    yc_folder_id: str | None = None,
    yc_sa_id: str | None = None,
    yc_sa_key_file_pem_b64: str | None = None,
    yc_sa_key_id: str | None = None,
    yc_zone_id: str | None = None,
    zilore_key: str | None = None,
    zm_key: str | None = None,
    zone_key: str | None = None,
    zone_username: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/acme/certificate/domain

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    ULTRA_PWD: UltraDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ultra'`
    acmedns_password: acme-dns.io PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_subdomain: acme-dns.io subdomainThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_update_url: (optional) Custom ACME DNS Base URLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmedns_username: acme-dns.io UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmedns'`
    acmeproxy_endpoint: Acmeproxy Endpoint URL (https://ip:port)This field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    acmeproxy_password: Acmeproxy PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    acmeproxy_username: Acmeproxy UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_acmeproxy'`
    active24_token: Active24 TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_active24'`
    ad_api_key: Alwaysdata API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ad'`
    af_api_password: ArtFiles PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_artfiles'`
    af_api_username: ArtFiles UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_artfiles'`
    akamai_access_token: Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_client_secret: Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_client_token: Client TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    akamai_host: HostnameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_edgedns'`
    ali_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ali'`
    ali_secret: API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ali'`
    anx_token: API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_anx'`
    anydnschallengealias: (Optional) Adds the --challenge-alias flag to the acme.sh call.To use a CNAME for _acme-challenge.importantDomain.tld to direct the acme validation to a different (sub)domain _acme-challenge.aliasDomainForValidationOnly.tld, configure the alternate domain here.More information can be found here.This field is only available when the following conditions are met:- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]
    anydnschallengedomain: (Optional) Uses the challenge domain alias value as --domain-alias instead in the acme.sh call.This field is only available when the following conditions are met:- `method` must not be one of [ webroot, webrootftp, standalone, standalonetls ]
    arvan_token: Arvan API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_arvan'`
    aurora_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aurora'`
    aurora_secret: API Secret. Obtain the key and secret from https://cp.pcextreme.nl/auroradns/users.This field is only available when the following conditions are met:- `method` must be equal to `'dns_aurora'`
    autodns_context: autoDNS ContextThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    autodns_password: autoDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    autodns_user: autoDNS UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_autodns'`
    aws_access_key_id: AWS Access Key / API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    aws_dns_slowrate: Sleep interval after TXT record update, in seconds (default: 1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    aws_secret_access_key: AWS Secret Access / API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_aws'`
    azion_email: Account e-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azion'`
    azion_password: Account passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azion'`
    azuredns_appid: Azure App IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_clientsecret: Azure Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_subscriptionid: Azure Subscription ID. First, setup a service principal for access to the DNS Zone.This field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    azuredns_tenantid: Azure Tenant IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_azure'`
    bookmyname_password: BookMyName PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bookmyname'`
    bookmyname_username: BookMyName UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bookmyname'`
    bunny_api_key: Bunny DNS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_bunny'`
    cf_account_id: Cloudflare API Account IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_email: Cloudflare API Email AddressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_key: Cloudflare API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_token: Cloudflare API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    cf_zone_id: Cloudflare API Zone IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cf'`
    clouddns_client_id: CloudDNS client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    clouddns_email: CloudDNS e-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    clouddns_password: CloudDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_clouddns'`
    cloudns_auth_id: Authentication IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cloudns_auth_password: ClouDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cloudns_sub_auth_id: Sub authentication IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cloudns'`
    cn_password: Core Networks PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cn'`
    cn_user: Core Networks UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cn'`
    conoha_identityserviceapi: Conoha Identity Service APIThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_password: Conoha PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_tenantid: Conoha Tenant IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    conoha_username: Conoha UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_conoha'`
    constellix_key: Constellix KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_constellix'`
    constellix_secret: Constellix SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_constellix'`
    cpanel_apitoken: cPanel API tokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    cpanel_hostname: URL to cPanel instanceThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    cpanel_username: cPanel usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cpanel'`
    curanet_authclientid: Authentication Client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_curanet'`
    curanet_authsecret: Authentication SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_curanet'`
    cy_password: CY PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cyon'`
    cy_username: CY usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_cyon'`
    da_api: DirectAdmin API URI (e.g. https://remoteUser:remotePassword@da.example.com:8443)This field is only available when the following conditions are met:- `method` must be equal to `'dns_da'`
    da_api_insecure: DirectAdmin API Security check, 0=check for valid SSL certificate, 1=always acceptThis field is only available when the following conditions are met:- `method` must be equal to `'dns_da'`
    dd_api_key: DurableDNS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_durabledns'`
    dd_api_user: DurableDNS API UserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_durabledns'`
    ddnss_token: API Token (e.g. aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)This field is only available when the following conditions are met:- `method` must be equal to `'dns_ddnss'`
    dedyn_name: deSEC.io UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_desec'`
    dedyn_token: deSEC.io API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_desec'`
    default_infomaniak_api_url: Infomaniak API URL (Default: https://api.infomaniak.com)This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    df_password: dyndnsfree.de PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_df'`
    df_user: dyndnsfree.de UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_df'`
    dh_api_key: Dreamhost API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dreamhost'`
    dnsexit_api_key: DNSExit API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnsexit_auth_pass: DNSExit PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnsexit_auth_user: DNSExit UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsexit'`
    dnshome_subdomain: SubdomainThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnshome'`
    dnshome_subdomainpassword: Subdomain PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnshome'`
    dnsimple_oauth_token: DNSimple oauth token, visit https://dnsimple.com/user to generate.This field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsimple'`
    dnsservices_password: dns.services PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsservices'`
    dnsservices_username: dns.services UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dnsservices'`
    do_api_key: DigitalOcean API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dgon'`
    do_letoken: DO.de API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_doapi'`
    do_pid: DO Customer IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_do'`
    do_pw: DO PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_do'`
    domeneshop_secret: Domeneshop API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_domeneshop'`
    domeneshop_token: Domeneshop API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_domeneshop'`
    dp_id: Dnspod API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dp'`
    dp_key: Dnspod API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dp'`
    dpi_id: Dnspod API IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dpi'`
    dpi_key: Dnspod API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dpi'`
    duckdns_token: DuckDNS API Token (Look in DuckDNS account settings)This field is only available when the following conditions are met:- `method` must be equal to `'dns_duckdns'`
    dyn_customer: dyn.com customer IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dyn_password: dyn.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dyn_username: dyn.com API Username (Dyn Managed DNS user, Needs Z&R Permissions for RecordAdd, RecordUpdate, RecordDelete, RecordGet, ZoneGet, ZoneAddNode, ZoneRemoveNode, ZonePublish)This field is only available when the following conditions are met:- `method` must be equal to `'dns_dyn'`
    dynu_clientid: Dynu API Client ID created in the Dynu account settingsThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dynu'`
    dynu_secret: Dynu API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_dynu'`
    easydns_key: easyDNS API Key. Sign up for a key at https://cp.easydns.com/manage/security/api/signup.phpThis field is only available when the following conditions are met:- `method` must be equal to `'dns_easydns'`
    easydns_token: easyDNS API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_easydns'`
    euserv_password: Euserv.eu PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_euserv'`
    euserv_username: Euserv.eu UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_euserv'`
    exoscale_api_key: Exoscale API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_exoscale'`
    exoscale_secret_key: Exoscale Secret KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_exoscale'`
    fornex_api_key: Fornex API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_fornex'`
    freedns_password: FreeDNS PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_freedns'`
    freedns_user: FreeDNS usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_freedns'`
    gandi_livedns_key: Gandi LiveDNS API Key, retrieved from https://account.gandi.netThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gandi_livedns'`
    gcore_key: Gcore API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gcore'`
    gd_key: GoDaddy API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gd'`
    gd_secret: GoDaddy API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_gd'`
    geoscaling_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_geoscaling'`
    geoscaling_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_geoscaling'`
    googledomains_access_token: Google Domains API Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_googledomains'`
    googledomains_zone: Google Domains DNS ZoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_googledomains'`
    he_password: Hurricane Electric passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_he'`
    he_username: Hurricane Electric usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_he'`
    hetzner_token: Hetzner API Token. Visit https://dns.hetzner.com/settings/api-token to retrieve.This field is only available when the following conditions are met:- `method` must be equal to `'dns_hetzner'`
    hexonet_login: Hexonet UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hexonet'`
    hexonet_password: Hexonet PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hexonet'`
    hostingde_apikey: Hosting.de API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hostingde'`
    hostingde_endpoint: Hosting.de API endpoint, e.g. https://secure.hosting.deThis field is only available when the following conditions are met:- `method` must be equal to `'dns_hostingde'`
    huaweicloud_domainname: Domain NameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    huaweicloud_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    huaweicloud_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_huaweicloud'`
    infoblox_creds: Infoblox credentials in username:password formatThis field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infoblox_server: Infoblox server IP address or hostnameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infoblox_view: Infoblox DNS View name, or enter "default"This field is only available when the following conditions are met:- `method` must be equal to `'dns_infoblox'`
    infomaniak_api_token: Infomaniak API token. Visit https://manager.infomaniak.com/v3/&lt;account_id&gt;/api/dashboard and generate a token with the scope Domain.This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    infomaniak_ttl: Infomaniak DNS record TTL (Default: 300)This field is only available when the following conditions are met:- `method` must be equal to `'dns_infomaniak'`
    internetbs_api_key: Internet.BS API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_internetbs'`
    internetbs_api_password: Internet.BS API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_internetbs'`
    inwx_password: INWX.de passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    inwx_shared_secret: INWX.de shared secretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    inwx_username: INWX.de usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_inwx'`
    ionos_prefix: PrefixThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ionos'`
    ionos_secret: Secret. Read https://beta.developer.hosting.ionos.de/docs/getstarted to learn how to get a prefix and secret.This field is only available when the following conditions are met:- `method` must be equal to `'dns_ionos'`
    ipv64_token: IPv64.net Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ipv64'`
    ispc_api: API URL (e.g. https://ispc.domain.tld:8080/remote/json.php )This field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_api_insecure: Set 1 for insecure and 0 for secure. Controls whether the server TLS certificate is checked for validity (0) or always accepted (1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_password: ISPConfig remotePasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    ispc_user: ISPConfig remoteUserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ispconfig'`
    jd_access_key_id: jdcloud Access Key IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    jd_access_key_secret: jdcloud Access Key SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    jd_region: jdcloud RegionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_jd'`
    joker_password: Joker.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_joker'`
    joker_username: Joker.com UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_joker'`
    kappernetdns_key: kapper.net API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kappernet'`
    kappernetdns_secret: kapper.net API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kappernet'`
    kas_authdata: Auth dataThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kas_authtype: Auth type (default: sha1)This field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kas_login: LoginThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kas'`
    kinghost_password: Kinghost API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kinghost'`
    kinghost_username: Kinghost API UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_kinghost'`
    knot_key: Knot TSIG KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_knot'`
    knot_server: IP address of the Knot serverThis field is only available when the following conditions are met:- `method` must be equal to `'dns_knot'`
    la_id: IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_la'`
    la_key: KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_la'`
    limacity_apikey: API Key must have the following roles: dns.admin, domains.readerThis field is only available when the following conditions are met:- `method` must be equal to `'dns_limacity'`
    linode_api_key: Linode API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_linode'`
    linode_v4_api_key: Linode v4 API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_linode_v4'`
    loopia_password: Loopia PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_loopia'`
    loopia_user: Loopia usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_loopia'`
    lsw_key: Leaseweb API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_leaseweb'`
    lua_email: Luadns API Email AddressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_lua'`
    lua_key: Luadns API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_lua'`
    mb_ak: OAuth2 KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mythic_beasts'`
    mb_as: OAuth2 SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mythic_beasts'`
    me_key: DNSMadeEasy API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_me'`
    me_secret: DNSMadeEasy API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_me'`
    method: The method to use to validate this domain.
    miab_password: MailinaBox PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    miab_server: MailinaBox ServerThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    miab_username: MailinaBox UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_miab'`
    misaka_key: misaka.io KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_misaka'`
    mydnsjp_masterid: MyDNS.jp Master IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mydnsjp'`
    mydnsjp_password: MyDNS.jp PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_mydnsjp'`
    name: The fully-qualified domain name of this domain (SAN).
    namecheap_api_key: Namecheap API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecheap'`
    namecheap_username: Namecheap UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecheap'`
    namecom_token: Name.com API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecom'`
    namecom_username: Name.com usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namecom'`
    namesilo_key: Namesilo API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_namesilo'`
    nanelo_token: Nanelo.com Access TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nanelo'`
    nc_apikey: Netcup API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nc_apipw: Netcup API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nc_cid: Netcup Customer ID/NumberThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netcup'`
    nederhost_key: NederHost API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nederhost'`
    neodigit_api_token: Neodigit API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_neodigit'`
    netlify_access_token: Netlify API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_netlify'`
    nic_clientid: nic.ru API Client IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_clientsecret: nic.ru API Client SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_password: nic.ru PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nic_username: nic.ru UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nic'`
    nm_sha256: namemaster.de API password as SHA256 hashThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nm'`
    nm_user: namemaster.de API usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nm'`
    ns1_key: NS1 API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsone'`
    nsupdate_key: The key which authenticates updates for this zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_keyalgo: Algorithm used to generate the authentication Key for this zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'` Valid values: ['', '157', '165', '164', '163', '162', '161']
    nsupdate_keyname: (Optional) A name for the key, if it is different than _acme-challenge.[DomainName]This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_server: The DNS server to which updates are sent (IP address or hostname)This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nsupdate_zone: (Optional) Explicitly set the zone name for updates.This field is only available when the following conditions are met:- `method` must be equal to `'dns_nsupdate'`
    nw_api_endpoint: Choose the NW API EndpointThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nw'` Valid values: ['', 'https:\\/\\/portal.nexcess.net', 'https:\\/\\/core.thermo.io', 'https:\\/\\/my.futurehosting.com']
    nw_api_token: NW API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_nw'`
    oci_cli_key: The private API signing key in PEM format. Using an encrypted private key that needs a passphrase is not supported.This field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_region: Tenancy home regionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_tenancy: OCID of tenancy that contains the target DNS zoneThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    oci_cli_user: OCID of user with permission to add/remove records from zonesThis field is only available when the following conditions are met:- `method` must be equal to `'dns_oci'`
    one984hosting_password: 1984Hosting PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_1984hosting'`
    one984hosting_username: 1984Hosting UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_1984hosting'`
    onecom_password: One.com PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_one'`
    onecom_user: One.com UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_one'`
    online_api_key: Online.net API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_online'`
    openprovider_passwordhash: OpenProvider Password HashThis field is only available when the following conditions are met:- `method` must be equal to `'dns_openprovider'`
    openprovider_user: OpenProvider UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_openprovider'`
    ovh_ak: OVH Application KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_as: OVH Application SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_ck: OVH Consumer KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'`
    ovh_end_point: Choose the OVH API Endpoint / RegionThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ovh'` Valid values: ['', 'ovh-eu', 'ovh-ca', 'kimsufi-eu', 'kimsufi-ca', 'soyoustart-eu', 'soyoustart-ca', 'runabove-ca']
    pdd_token: Yandex PDD Token, generate at https://pddimp.yandex.ru/api2/admin/get_tokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yandex'`
    pdns_serverid: PowerDNS ServerId (e.g. localhost )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_token: PowerDNS Token (e.g. 0123456789ABCDEF )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_ttl: PowerDNS Record TTL (e.g. 60 )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pdns_url: PowerDNS URL (e.g. http://ns.example.com:8081 )This field is only available when the following conditions are met:- `method` must be equal to `'dns_pdns'`
    pleskxml_pass: Plesk PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pleskxml_uri: Plesk Server URIThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pleskxml_user: Plesk UserThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pleskxml'`
    pointhq_email: PointHQ account E-mail addressThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pointhq'`
    pointhq_key: PointHQ API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_pointhq'`
    porkbun_api_key: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_porkbun'`
    porkbun_secret_api_key: Secret API Key. Obtain the key and secret from https://porkbun.com/account/apiThis field is only available when the following conditions are met:- `method` must be equal to `'dns_porkbun'`
    rackcorp_apisecret: API SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackcorp'`
    rackcorp_apiuuid: API UUIDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackcorp'`
    rackspace_apikey: Rackspace API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackspace'`
    rackspace_username: Rackspace UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rackspace'`
    rage4_token: TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rage4'`
    rage4_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rage4'`
    rcode0_api_token: Rcode0 API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    rcode0_ttl: Rcode0 TTLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    rcode0_url: Rcode0 URLThis field is only available when the following conditions are met:- `method` must be equal to `'dns_rcode0'`
    regru_api_password: reg.ru API PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_regru'`
    regru_api_username: reg.ru UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_regru'`
    scaleway_api_token: API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_scaleway'`
    schlundtech_password: schlundtech.de PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_schlundtech'`
    schlundtech_user: schlundtech.de UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_schlundtech'`
    selfhostdns_map: Record ID (Edit the record, value is shown in brackets)This field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    selfhostdns_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    selfhostdns_username: Username (Customer number, not email address or DynDNS account)This field is only available when the following conditions are met:- `method` must be equal to `'dns_selfhost'`
    servercow_api_password: Servercow passwordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_servercow'`
    servercow_api_username: Servercow usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_servercow'`
    simply_accountname: Account NameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    simply_api: API Endpoint URL. Default: https://api.simply.com/1This field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    simply_apikey: API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_simply'`
    sl_key: Selectel API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_selectel'`
    standaloneipv6: Bind to IPv6 instead of IPv4.This field is only available when the following conditions are met:- `method` must be equal to `'standalone'`
    standaloneport: HTTP listen port for stand-alone server. Must be 80 or have port 80 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.This field is only available when the following conditions are met:- `method` must be equal to `'standalone'`
    standalonetlsport: TLS listen port for stand-alone server. Must be 443 or have port 443 on WAN forwarded to this port. Firewall rules must allow traffic to reach this port.This field is only available when the following conditions are met:- `method` must be equal to `'standalonetls'`
    status: The activation status of the ACME certificate. Valid values: ['enable', 'disable']
    tele3_key: Tele3 KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tele3'`
    tele3_secret: Tele3 SecretThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tele3'`
    tencent_secretid: Tencent Secret IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tencent'`
    tencent_secretkey: Tencent Secret KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_tencent'`
    udr_pass: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_udr'`
    udr_user: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_udr'`
    ultra_usr: UltraDNS UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_ultra'`
    uno_key: UnoEuro API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_unoeuro'`
    uno_user: UnoEuro usernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_unoeuro'`
    variomedia_api_token: variomedia.de API TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_variomedia'`
    veesp_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_veesp'`
    veesp_user: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_veesp'`
    vercel_token: Vercel TokenThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vercel'`
    vscale_api_key: vscale API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vscale'`
    vultr_api_key: vultr.com API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_vultr'`
    webrootfolder: Folder into which the acme challenge response is written; for example: /usr/local/www/.well-known/acme-challenge/This field is only available when the following conditions are met:- `method` must be equal to `'webroot'`
    webrootftpfolder: Folder into which the acme challenge response is written (e.g. /.well-known/acme-challenge/)This field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftpftpserver: Hostname of FTP server to which ACME will connect (e.g. ftps://www.webserver.tld ). Currently supports FTPS (passive) and SFTP.This field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftppassword: Password to authenticate this user on the remote serverThis field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    webrootftpusername: Username for the remote serverThis field is only available when the following conditions are met:- `method` must be equal to `'webrootftp'`
    west_key: West.cn Domain API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_west_cn'`
    west_username: West.cn Domain API UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_west_cn'`
    world4you_password: PasswordThis field is only available when the following conditions are met:- `method` must be equal to `'dns_world4you'`
    world4you_username: UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_world4you'`
    ws_apikey: API Key / "Identifier" in the WS AdminThis field is only available when the following conditions are met:- `method` must be equal to `'dns_websupport'`
    ws_apisecret: API Secret / "Secret key" in the WS Admin. Obtain the API Key and Secret from https://admin.websupport.sk/en/auth/apiKey.This field is only available when the following conditions are met:- `method` must be equal to `'dns_websupport'`
    yc_folder_id: Yandex Cloud Folder IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_id: Service Account IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_key_file_pem_b64: Base64 content of private key.This field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_sa_key_id: Service Account IAM Key IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    yc_zone_id: DNS Zone IDThis field is only available when the following conditions are met:- `method` must be equal to `'dns_yc'`
    zilore_key: Zilore API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zilore'`
    zm_key: Zonomi API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zonomi'`
    zone_key: Zone.ee API KeyThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zone'`
    zone_username: Zone.ee UsernameThis field is only available when the following conditions are met:- `method` must be equal to `'dns_zone'`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/acme/certificate/domain. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if ULTRA_PWD is not None:
        body["ULTRA_PWD"] = ULTRA_PWD
    if acmedns_password is not None:
        body["acmedns_password"] = acmedns_password
    if acmedns_subdomain is not None:
        body["acmedns_subdomain"] = acmedns_subdomain
    if acmedns_update_url is not None:
        body["acmedns_update_url"] = acmedns_update_url
    if acmedns_username is not None:
        body["acmedns_username"] = acmedns_username
    if acmeproxy_endpoint is not None:
        body["acmeproxy_endpoint"] = acmeproxy_endpoint
    if acmeproxy_password is not None:
        body["acmeproxy_password"] = acmeproxy_password
    if acmeproxy_username is not None:
        body["acmeproxy_username"] = acmeproxy_username
    if active24_token is not None:
        body["active24_token"] = active24_token
    if ad_api_key is not None:
        body["ad_api_key"] = ad_api_key
    if af_api_password is not None:
        body["af_api_password"] = af_api_password
    if af_api_username is not None:
        body["af_api_username"] = af_api_username
    if akamai_access_token is not None:
        body["akamai_access_token"] = akamai_access_token
    if akamai_client_secret is not None:
        body["akamai_client_secret"] = akamai_client_secret
    if akamai_client_token is not None:
        body["akamai_client_token"] = akamai_client_token
    if akamai_host is not None:
        body["akamai_host"] = akamai_host
    if ali_key is not None:
        body["ali_key"] = ali_key
    if ali_secret is not None:
        body["ali_secret"] = ali_secret
    if anx_token is not None:
        body["anx_token"] = anx_token
    if anydnschallengealias is not None:
        body["anydnschallengealias"] = anydnschallengealias
    if anydnschallengedomain is not None:
        body["anydnschallengedomain"] = anydnschallengedomain
    if arvan_token is not None:
        body["arvan_token"] = arvan_token
    if aurora_key is not None:
        body["aurora_key"] = aurora_key
    if aurora_secret is not None:
        body["aurora_secret"] = aurora_secret
    if autodns_context is not None:
        body["autodns_context"] = autodns_context
    if autodns_password is not None:
        body["autodns_password"] = autodns_password
    if autodns_user is not None:
        body["autodns_user"] = autodns_user
    if aws_access_key_id is not None:
        body["aws_access_key_id"] = aws_access_key_id
    if aws_dns_slowrate is not None:
        body["aws_dns_slowrate"] = aws_dns_slowrate
    if aws_secret_access_key is not None:
        body["aws_secret_access_key"] = aws_secret_access_key
    if azion_email is not None:
        body["azion_email"] = azion_email
    if azion_password is not None:
        body["azion_password"] = azion_password
    if azuredns_appid is not None:
        body["azuredns_appid"] = azuredns_appid
    if azuredns_clientsecret is not None:
        body["azuredns_clientsecret"] = azuredns_clientsecret
    if azuredns_subscriptionid is not None:
        body["azuredns_subscriptionid"] = azuredns_subscriptionid
    if azuredns_tenantid is not None:
        body["azuredns_tenantid"] = azuredns_tenantid
    if bookmyname_password is not None:
        body["bookmyname_password"] = bookmyname_password
    if bookmyname_username is not None:
        body["bookmyname_username"] = bookmyname_username
    if bunny_api_key is not None:
        body["bunny_api_key"] = bunny_api_key
    if cf_account_id is not None:
        body["cf_account_id"] = cf_account_id
    if cf_email is not None:
        body["cf_email"] = cf_email
    if cf_key is not None:
        body["cf_key"] = cf_key
    if cf_token is not None:
        body["cf_token"] = cf_token
    if cf_zone_id is not None:
        body["cf_zone_id"] = cf_zone_id
    if clouddns_client_id is not None:
        body["clouddns_client_id"] = clouddns_client_id
    if clouddns_email is not None:
        body["clouddns_email"] = clouddns_email
    if clouddns_password is not None:
        body["clouddns_password"] = clouddns_password
    if cloudns_auth_id is not None:
        body["cloudns_auth_id"] = cloudns_auth_id
    if cloudns_auth_password is not None:
        body["cloudns_auth_password"] = cloudns_auth_password
    if cloudns_sub_auth_id is not None:
        body["cloudns_sub_auth_id"] = cloudns_sub_auth_id
    if cn_password is not None:
        body["cn_password"] = cn_password
    if cn_user is not None:
        body["cn_user"] = cn_user
    if conoha_identityserviceapi is not None:
        body["conoha_identityserviceapi"] = conoha_identityserviceapi
    if conoha_password is not None:
        body["conoha_password"] = conoha_password
    if conoha_tenantid is not None:
        body["conoha_tenantid"] = conoha_tenantid
    if conoha_username is not None:
        body["conoha_username"] = conoha_username
    if constellix_key is not None:
        body["constellix_key"] = constellix_key
    if constellix_secret is not None:
        body["constellix_secret"] = constellix_secret
    if cpanel_apitoken is not None:
        body["cpanel_apitoken"] = cpanel_apitoken
    if cpanel_hostname is not None:
        body["cpanel_hostname"] = cpanel_hostname
    if cpanel_username is not None:
        body["cpanel_username"] = cpanel_username
    if curanet_authclientid is not None:
        body["curanet_authclientid"] = curanet_authclientid
    if curanet_authsecret is not None:
        body["curanet_authsecret"] = curanet_authsecret
    if cy_password is not None:
        body["cy_password"] = cy_password
    if cy_username is not None:
        body["cy_username"] = cy_username
    if da_api is not None:
        body["da_api"] = da_api
    if da_api_insecure is not None:
        body["da_api_insecure"] = da_api_insecure
    if dd_api_key is not None:
        body["dd_api_key"] = dd_api_key
    if dd_api_user is not None:
        body["dd_api_user"] = dd_api_user
    if ddnss_token is not None:
        body["ddnss_token"] = ddnss_token
    if dedyn_name is not None:
        body["dedyn_name"] = dedyn_name
    if dedyn_token is not None:
        body["dedyn_token"] = dedyn_token
    if default_infomaniak_api_url is not None:
        body["default_infomaniak_api_url"] = default_infomaniak_api_url
    if df_password is not None:
        body["df_password"] = df_password
    if df_user is not None:
        body["df_user"] = df_user
    if dh_api_key is not None:
        body["dh_api_key"] = dh_api_key
    if dnsexit_api_key is not None:
        body["dnsexit_api_key"] = dnsexit_api_key
    if dnsexit_auth_pass is not None:
        body["dnsexit_auth_pass"] = dnsexit_auth_pass
    if dnsexit_auth_user is not None:
        body["dnsexit_auth_user"] = dnsexit_auth_user
    if dnshome_subdomain is not None:
        body["dnshome_subdomain"] = dnshome_subdomain
    if dnshome_subdomainpassword is not None:
        body["dnshome_subdomainpassword"] = dnshome_subdomainpassword
    if dnsimple_oauth_token is not None:
        body["dnsimple_oauth_token"] = dnsimple_oauth_token
    if dnsservices_password is not None:
        body["dnsservices_password"] = dnsservices_password
    if dnsservices_username is not None:
        body["dnsservices_username"] = dnsservices_username
    if do_api_key is not None:
        body["do_api_key"] = do_api_key
    if do_letoken is not None:
        body["do_letoken"] = do_letoken
    if do_pid is not None:
        body["do_pid"] = do_pid
    if do_pw is not None:
        body["do_pw"] = do_pw
    if domeneshop_secret is not None:
        body["domeneshop_secret"] = domeneshop_secret
    if domeneshop_token is not None:
        body["domeneshop_token"] = domeneshop_token
    if dp_id is not None:
        body["dp_id"] = dp_id
    if dp_key is not None:
        body["dp_key"] = dp_key
    if dpi_id is not None:
        body["dpi_id"] = dpi_id
    if dpi_key is not None:
        body["dpi_key"] = dpi_key
    if duckdns_token is not None:
        body["duckdns_token"] = duckdns_token
    if dyn_customer is not None:
        body["dyn_customer"] = dyn_customer
    if dyn_password is not None:
        body["dyn_password"] = dyn_password
    if dyn_username is not None:
        body["dyn_username"] = dyn_username
    if dynu_clientid is not None:
        body["dynu_clientid"] = dynu_clientid
    if dynu_secret is not None:
        body["dynu_secret"] = dynu_secret
    if easydns_key is not None:
        body["easydns_key"] = easydns_key
    if easydns_token is not None:
        body["easydns_token"] = easydns_token
    if euserv_password is not None:
        body["euserv_password"] = euserv_password
    if euserv_username is not None:
        body["euserv_username"] = euserv_username
    if exoscale_api_key is not None:
        body["exoscale_api_key"] = exoscale_api_key
    if exoscale_secret_key is not None:
        body["exoscale_secret_key"] = exoscale_secret_key
    if fornex_api_key is not None:
        body["fornex_api_key"] = fornex_api_key
    if freedns_password is not None:
        body["freedns_password"] = freedns_password
    if freedns_user is not None:
        body["freedns_user"] = freedns_user
    if gandi_livedns_key is not None:
        body["gandi_livedns_key"] = gandi_livedns_key
    if gcore_key is not None:
        body["gcore_key"] = gcore_key
    if gd_key is not None:
        body["gd_key"] = gd_key
    if gd_secret is not None:
        body["gd_secret"] = gd_secret
    if geoscaling_password is not None:
        body["geoscaling_password"] = geoscaling_password
    if geoscaling_username is not None:
        body["geoscaling_username"] = geoscaling_username
    if googledomains_access_token is not None:
        body["googledomains_access_token"] = googledomains_access_token
    if googledomains_zone is not None:
        body["googledomains_zone"] = googledomains_zone
    if he_password is not None:
        body["he_password"] = he_password
    if he_username is not None:
        body["he_username"] = he_username
    if hetzner_token is not None:
        body["hetzner_token"] = hetzner_token
    if hexonet_login is not None:
        body["hexonet_login"] = hexonet_login
    if hexonet_password is not None:
        body["hexonet_password"] = hexonet_password
    if hostingde_apikey is not None:
        body["hostingde_apikey"] = hostingde_apikey
    if hostingde_endpoint is not None:
        body["hostingde_endpoint"] = hostingde_endpoint
    if huaweicloud_domainname is not None:
        body["huaweicloud_domainname"] = huaweicloud_domainname
    if huaweicloud_password is not None:
        body["huaweicloud_password"] = huaweicloud_password
    if huaweicloud_username is not None:
        body["huaweicloud_username"] = huaweicloud_username
    if infoblox_creds is not None:
        body["infoblox_creds"] = infoblox_creds
    if infoblox_server is not None:
        body["infoblox_server"] = infoblox_server
    if infoblox_view is not None:
        body["infoblox_view"] = infoblox_view
    if infomaniak_api_token is not None:
        body["infomaniak_api_token"] = infomaniak_api_token
    if infomaniak_ttl is not None:
        body["infomaniak_ttl"] = infomaniak_ttl
    if internetbs_api_key is not None:
        body["internetbs_api_key"] = internetbs_api_key
    if internetbs_api_password is not None:
        body["internetbs_api_password"] = internetbs_api_password
    if inwx_password is not None:
        body["inwx_password"] = inwx_password
    if inwx_shared_secret is not None:
        body["inwx_shared_secret"] = inwx_shared_secret
    if inwx_username is not None:
        body["inwx_username"] = inwx_username
    if ionos_prefix is not None:
        body["ionos_prefix"] = ionos_prefix
    if ionos_secret is not None:
        body["ionos_secret"] = ionos_secret
    if ipv64_token is not None:
        body["ipv64_token"] = ipv64_token
    if ispc_api is not None:
        body["ispc_api"] = ispc_api
    if ispc_api_insecure is not None:
        body["ispc_api_insecure"] = ispc_api_insecure
    if ispc_password is not None:
        body["ispc_password"] = ispc_password
    if ispc_user is not None:
        body["ispc_user"] = ispc_user
    if jd_access_key_id is not None:
        body["jd_access_key_id"] = jd_access_key_id
    if jd_access_key_secret is not None:
        body["jd_access_key_secret"] = jd_access_key_secret
    if jd_region is not None:
        body["jd_region"] = jd_region
    if joker_password is not None:
        body["joker_password"] = joker_password
    if joker_username is not None:
        body["joker_username"] = joker_username
    if kappernetdns_key is not None:
        body["kappernetdns_key"] = kappernetdns_key
    if kappernetdns_secret is not None:
        body["kappernetdns_secret"] = kappernetdns_secret
    if kas_authdata is not None:
        body["kas_authdata"] = kas_authdata
    if kas_authtype is not None:
        body["kas_authtype"] = kas_authtype
    if kas_login is not None:
        body["kas_login"] = kas_login
    if kinghost_password is not None:
        body["kinghost_password"] = kinghost_password
    if kinghost_username is not None:
        body["kinghost_username"] = kinghost_username
    if knot_key is not None:
        body["knot_key"] = knot_key
    if knot_server is not None:
        body["knot_server"] = knot_server
    if la_id is not None:
        body["la_id"] = la_id
    if la_key is not None:
        body["la_key"] = la_key
    if limacity_apikey is not None:
        body["limacity_apikey"] = limacity_apikey
    if linode_api_key is not None:
        body["linode_api_key"] = linode_api_key
    if linode_v4_api_key is not None:
        body["linode_v4_api_key"] = linode_v4_api_key
    if loopia_password is not None:
        body["loopia_password"] = loopia_password
    if loopia_user is not None:
        body["loopia_user"] = loopia_user
    if lsw_key is not None:
        body["lsw_key"] = lsw_key
    if lua_email is not None:
        body["lua_email"] = lua_email
    if lua_key is not None:
        body["lua_key"] = lua_key
    if mb_ak is not None:
        body["mb_ak"] = mb_ak
    if mb_as is not None:
        body["mb_as"] = mb_as
    if me_key is not None:
        body["me_key"] = me_key
    if me_secret is not None:
        body["me_secret"] = me_secret
    if method is not None:
        body["method"] = method
    if miab_password is not None:
        body["miab_password"] = miab_password
    if miab_server is not None:
        body["miab_server"] = miab_server
    if miab_username is not None:
        body["miab_username"] = miab_username
    if misaka_key is not None:
        body["misaka_key"] = misaka_key
    if mydnsjp_masterid is not None:
        body["mydnsjp_masterid"] = mydnsjp_masterid
    if mydnsjp_password is not None:
        body["mydnsjp_password"] = mydnsjp_password
    if name is not None:
        body["name"] = name
    if namecheap_api_key is not None:
        body["namecheap_api_key"] = namecheap_api_key
    if namecheap_username is not None:
        body["namecheap_username"] = namecheap_username
    if namecom_token is not None:
        body["namecom_token"] = namecom_token
    if namecom_username is not None:
        body["namecom_username"] = namecom_username
    if namesilo_key is not None:
        body["namesilo_key"] = namesilo_key
    if nanelo_token is not None:
        body["nanelo_token"] = nanelo_token
    if nc_apikey is not None:
        body["nc_apikey"] = nc_apikey
    if nc_apipw is not None:
        body["nc_apipw"] = nc_apipw
    if nc_cid is not None:
        body["nc_cid"] = nc_cid
    if nederhost_key is not None:
        body["nederhost_key"] = nederhost_key
    if neodigit_api_token is not None:
        body["neodigit_api_token"] = neodigit_api_token
    if netlify_access_token is not None:
        body["netlify_access_token"] = netlify_access_token
    if nic_clientid is not None:
        body["nic_clientid"] = nic_clientid
    if nic_clientsecret is not None:
        body["nic_clientsecret"] = nic_clientsecret
    if nic_password is not None:
        body["nic_password"] = nic_password
    if nic_username is not None:
        body["nic_username"] = nic_username
    if nm_sha256 is not None:
        body["nm_sha256"] = nm_sha256
    if nm_user is not None:
        body["nm_user"] = nm_user
    if ns1_key is not None:
        body["ns1_key"] = ns1_key
    if nsupdate_key is not None:
        body["nsupdate_key"] = nsupdate_key
    if nsupdate_keyalgo is not None:
        body["nsupdate_keyalgo"] = nsupdate_keyalgo
    if nsupdate_keyname is not None:
        body["nsupdate_keyname"] = nsupdate_keyname
    if nsupdate_server is not None:
        body["nsupdate_server"] = nsupdate_server
    if nsupdate_zone is not None:
        body["nsupdate_zone"] = nsupdate_zone
    if nw_api_endpoint is not None:
        body["nw_api_endpoint"] = nw_api_endpoint
    if nw_api_token is not None:
        body["nw_api_token"] = nw_api_token
    if oci_cli_key is not None:
        body["oci_cli_key"] = oci_cli_key
    if oci_cli_region is not None:
        body["oci_cli_region"] = oci_cli_region
    if oci_cli_tenancy is not None:
        body["oci_cli_tenancy"] = oci_cli_tenancy
    if oci_cli_user is not None:
        body["oci_cli_user"] = oci_cli_user
    if one984hosting_password is not None:
        body["one984hosting_password"] = one984hosting_password
    if one984hosting_username is not None:
        body["one984hosting_username"] = one984hosting_username
    if onecom_password is not None:
        body["onecom_password"] = onecom_password
    if onecom_user is not None:
        body["onecom_user"] = onecom_user
    if online_api_key is not None:
        body["online_api_key"] = online_api_key
    if openprovider_passwordhash is not None:
        body["openprovider_passwordhash"] = openprovider_passwordhash
    if openprovider_user is not None:
        body["openprovider_user"] = openprovider_user
    if ovh_ak is not None:
        body["ovh_ak"] = ovh_ak
    if ovh_as is not None:
        body["ovh_as"] = ovh_as
    if ovh_ck is not None:
        body["ovh_ck"] = ovh_ck
    if ovh_end_point is not None:
        body["ovh_end_point"] = ovh_end_point
    if pdd_token is not None:
        body["pdd_token"] = pdd_token
    if pdns_serverid is not None:
        body["pdns_serverid"] = pdns_serverid
    if pdns_token is not None:
        body["pdns_token"] = pdns_token
    if pdns_ttl is not None:
        body["pdns_ttl"] = pdns_ttl
    if pdns_url is not None:
        body["pdns_url"] = pdns_url
    if pleskxml_pass is not None:
        body["pleskxml_pass"] = pleskxml_pass
    if pleskxml_uri is not None:
        body["pleskxml_uri"] = pleskxml_uri
    if pleskxml_user is not None:
        body["pleskxml_user"] = pleskxml_user
    if pointhq_email is not None:
        body["pointhq_email"] = pointhq_email
    if pointhq_key is not None:
        body["pointhq_key"] = pointhq_key
    if porkbun_api_key is not None:
        body["porkbun_api_key"] = porkbun_api_key
    if porkbun_secret_api_key is not None:
        body["porkbun_secret_api_key"] = porkbun_secret_api_key
    if rackcorp_apisecret is not None:
        body["rackcorp_apisecret"] = rackcorp_apisecret
    if rackcorp_apiuuid is not None:
        body["rackcorp_apiuuid"] = rackcorp_apiuuid
    if rackspace_apikey is not None:
        body["rackspace_apikey"] = rackspace_apikey
    if rackspace_username is not None:
        body["rackspace_username"] = rackspace_username
    if rage4_token is not None:
        body["rage4_token"] = rage4_token
    if rage4_username is not None:
        body["rage4_username"] = rage4_username
    if rcode0_api_token is not None:
        body["rcode0_api_token"] = rcode0_api_token
    if rcode0_ttl is not None:
        body["rcode0_ttl"] = rcode0_ttl
    if rcode0_url is not None:
        body["rcode0_url"] = rcode0_url
    if regru_api_password is not None:
        body["regru_api_password"] = regru_api_password
    if regru_api_username is not None:
        body["regru_api_username"] = regru_api_username
    if scaleway_api_token is not None:
        body["scaleway_api_token"] = scaleway_api_token
    if schlundtech_password is not None:
        body["schlundtech_password"] = schlundtech_password
    if schlundtech_user is not None:
        body["schlundtech_user"] = schlundtech_user
    if selfhostdns_map is not None:
        body["selfhostdns_map"] = selfhostdns_map
    if selfhostdns_password is not None:
        body["selfhostdns_password"] = selfhostdns_password
    if selfhostdns_username is not None:
        body["selfhostdns_username"] = selfhostdns_username
    if servercow_api_password is not None:
        body["servercow_api_password"] = servercow_api_password
    if servercow_api_username is not None:
        body["servercow_api_username"] = servercow_api_username
    if simply_accountname is not None:
        body["simply_accountname"] = simply_accountname
    if simply_api is not None:
        body["simply_api"] = simply_api
    if simply_apikey is not None:
        body["simply_apikey"] = simply_apikey
    if sl_key is not None:
        body["sl_key"] = sl_key
    if standaloneipv6 is not None:
        body["standaloneipv6"] = standaloneipv6
    if standaloneport is not None:
        body["standaloneport"] = standaloneport
    if standalonetlsport is not None:
        body["standalonetlsport"] = standalonetlsport
    if status is not None:
        body["status"] = status
    if tele3_key is not None:
        body["tele3_key"] = tele3_key
    if tele3_secret is not None:
        body["tele3_secret"] = tele3_secret
    if tencent_secretid is not None:
        body["tencent_secretid"] = tencent_secretid
    if tencent_secretkey is not None:
        body["tencent_secretkey"] = tencent_secretkey
    if udr_pass is not None:
        body["udr_pass"] = udr_pass
    if udr_user is not None:
        body["udr_user"] = udr_user
    if ultra_usr is not None:
        body["ultra_usr"] = ultra_usr
    if uno_key is not None:
        body["uno_key"] = uno_key
    if uno_user is not None:
        body["uno_user"] = uno_user
    if variomedia_api_token is not None:
        body["variomedia_api_token"] = variomedia_api_token
    if veesp_password is not None:
        body["veesp_password"] = veesp_password
    if veesp_user is not None:
        body["veesp_user"] = veesp_user
    if vercel_token is not None:
        body["vercel_token"] = vercel_token
    if vscale_api_key is not None:
        body["vscale_api_key"] = vscale_api_key
    if vultr_api_key is not None:
        body["vultr_api_key"] = vultr_api_key
    if webrootfolder is not None:
        body["webrootfolder"] = webrootfolder
    if webrootftpfolder is not None:
        body["webrootftpfolder"] = webrootftpfolder
    if webrootftpftpserver is not None:
        body["webrootftpftpserver"] = webrootftpftpserver
    if webrootftppassword is not None:
        body["webrootftppassword"] = webrootftppassword
    if webrootftpusername is not None:
        body["webrootftpusername"] = webrootftpusername
    if west_key is not None:
        body["west_key"] = west_key
    if west_username is not None:
        body["west_username"] = west_username
    if world4you_password is not None:
        body["world4you_password"] = world4you_password
    if world4you_username is not None:
        body["world4you_username"] = world4you_username
    if ws_apikey is not None:
        body["ws_apikey"] = ws_apikey
    if ws_apisecret is not None:
        body["ws_apisecret"] = ws_apisecret
    if yc_folder_id is not None:
        body["yc_folder_id"] = yc_folder_id
    if yc_sa_id is not None:
        body["yc_sa_id"] = yc_sa_id
    if yc_sa_key_file_pem_b64 is not None:
        body["yc_sa_key_file_pem_b64"] = yc_sa_key_file_pem_b64
    if yc_sa_key_id is not None:
        body["yc_sa_key_id"] = yc_sa_key_id
    if yc_zone_id is not None:
        body["yc_zone_id"] = yc_zone_id
    if zilore_key is not None:
        body["zilore_key"] = zilore_key
    if zm_key is not None:
        body["zm_key"] = zm_key
    if zone_key is not None:
        body["zone_key"] = zone_key
    if zone_username is not None:
        body["zone_username"] = zone_username
    return await _client.request(
        "PATCH",
        "/api/v2/services/acme/certificate/domain",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_certificate_domain(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/certificate/domain

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/certificate/domain. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/certificate/domain",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_acme_certificate(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificate

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_certificate(
    a_domainlist: list[dict[str, Any]],
    acmeaccount: str,
    name: str,
    confirm: bool = False,
    a_actionlist: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    dnssleep: int | None = None,
    keylength: str | None = '2048',
    keypaste: str | None = None,
    oscpstaple: bool | None = None,
    preferredchain: str | None = None,
    renewafter: int | None = 60,
    status: str | None = 'active',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/certificate

    a_domainlist: The list of domain verifications to include in the ACME certificate.
    acmeaccount: The ACME account key to use for the ACME certificate.
    name: The name of the ACME certificate.
    a_actionlist: The list of actions to perform on the ACME certificate after being issued/renewed.
    descr: A description of the ACME certificate.
    dnssleep: The number of seconds to wait for DNS propagation before requesting verification.
    keylength: The length of the private key to use for the ACME certificate. Valid values: ['2048', '3072', '4096', 'ec-256', 'ec-384', 'custom']
    keypaste: The custom private key to use for the ACME certificate.This field is only available when the following conditions are met:- `keylength` must be equal to `'custom'`
    oscpstaple: Whether to enable OCSP Stapling for the ACME certificate.
    preferredchain: The preferred certificate chain to use for the ACME certificate.
    renewafter: The number of days before expiration to renew the ACME certificate.
    status: The activation status of the ACME certificate. Valid values: ['active', 'disabled']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if a_domainlist is not None:
        body["a_domainlist"] = a_domainlist
    if acmeaccount is not None:
        body["acmeaccount"] = acmeaccount
    if name is not None:
        body["name"] = name
    if a_actionlist is not None:
        body["a_actionlist"] = a_actionlist
    if descr is not None:
        body["descr"] = descr
    if dnssleep is not None:
        body["dnssleep"] = dnssleep
    if keylength is not None:
        body["keylength"] = keylength
    if keypaste is not None:
        body["keypaste"] = keypaste
    if oscpstaple is not None:
        body["oscpstaple"] = oscpstaple
    if preferredchain is not None:
        body["preferredchain"] = preferredchain
    if renewafter is not None:
        body["renewafter"] = renewafter
    if status is not None:
        body["status"] = status
    return await _client.request(
        "POST",
        "/api/v2/services/acme/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_acme_certificate(
    id: str | int,
    confirm: bool = False,
    a_actionlist: list[dict[str, Any]] | None = None,
    a_domainlist: list[dict[str, Any]] | None = None,
    acmeaccount: str | None = None,
    descr: str | None = None,
    dnssleep: int | None = None,
    keylength: str | None = None,
    keypaste: str | None = None,
    name: str | None = None,
    oscpstaple: bool | None = None,
    preferredchain: str | None = None,
    renewafter: int | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/acme/certificate

    id: The ID of the object or resource to interact with.
    a_actionlist: The list of actions to perform on the ACME certificate after being issued/renewed.
    a_domainlist: The list of domain verifications to include in the ACME certificate.
    acmeaccount: The ACME account key to use for the ACME certificate.
    descr: A description of the ACME certificate.
    dnssleep: The number of seconds to wait for DNS propagation before requesting verification.
    keylength: The length of the private key to use for the ACME certificate. Valid values: ['2048', '3072', '4096', 'ec-256', 'ec-384', 'custom']
    keypaste: The custom private key to use for the ACME certificate.This field is only available when the following conditions are met:- `keylength` must be equal to `'custom'`
    name: The name of the ACME certificate.
    oscpstaple: Whether to enable OCSP Stapling for the ACME certificate.
    preferredchain: The preferred certificate chain to use for the ACME certificate.
    renewafter: The number of days before expiration to renew the ACME certificate.
    status: The activation status of the ACME certificate. Valid values: ['active', 'disabled']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/acme/certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if a_actionlist is not None:
        body["a_actionlist"] = a_actionlist
    if a_domainlist is not None:
        body["a_domainlist"] = a_domainlist
    if acmeaccount is not None:
        body["acmeaccount"] = acmeaccount
    if descr is not None:
        body["descr"] = descr
    if dnssleep is not None:
        body["dnssleep"] = dnssleep
    if keylength is not None:
        body["keylength"] = keylength
    if keypaste is not None:
        body["keypaste"] = keypaste
    if name is not None:
        body["name"] = name
    if oscpstaple is not None:
        body["oscpstaple"] = oscpstaple
    if preferredchain is not None:
        body["preferredchain"] = preferredchain
    if renewafter is not None:
        body["renewafter"] = renewafter
    if status is not None:
        body["status"] = status
    return await _client.request(
        "PATCH",
        "/api/v2/services/acme/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_certificate(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/certificate

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/certificate. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_acme_certificate_issuances(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificate/issuances

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificate/issuances",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_acme_certificate_issue(
    certificate: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/certificate/issue

    certificate: The name of the ACME certificate to be issued.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/certificate/issue. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if certificate is not None:
        body["certificate"] = certificate
    return await _client.request(
        "POST",
        "/api/v2/services/acme/certificate/issue",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_services_acme_certificate_renew(
    certificate: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/acme/certificate/renew

    certificate: The name of the ACME certificate to be renewed.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/acme/certificate/renew. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if certificate is not None:
        body["certificate"] = certificate
    return await _client.request(
        "POST",
        "/api/v2/services/acme/certificate/renew",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_services_acme_certificate_renewals(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificate/renewals

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificate/renewals",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_acme_certificates(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/certificates

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/acme/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_acme_certificates(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/acme/certificates

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/acme/certificates. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/acme/certificates",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_acme_certificates(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/acme/certificates

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/acme/certificates. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/acme/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_acme_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/acme/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/acme/settings",
    )


@mcp.tool()
async def pfsense_update_services_acme_settings(
    confirm: bool = False,
    enable: bool | None = None,
    writecerts: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/acme/settings

    enable: Enables or disables the ACME renewal job.
    writecerts: Enables or disables the writing of certificates to /conf/acme/ in various formats for use by other scripts or daemons which do not integrate with the pfSense certificate manager.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/acme/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if enable is not None:
        body["enable"] = enable
    if writecerts is not None:
        body["writecerts"] = writecerts
    return await _client.request(
        "PATCH",
        "/api/v2/services/acme/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_bind_access_list(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/access_list

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_access_list(
    entries: list[dict[str, Any]],
    name: str,
    confirm: bool = False,
    description: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/access_list

    entries: The network entries for this access list.
    name: The name of the access list.
    description: A description for the access list.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/access_list. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if entries is not None:
        body["entries"] = entries
    if name is not None:
        body["name"] = name
    if description is not None:
        body["description"] = description
    return await _client.request(
        "POST",
        "/api/v2/services/bind/access_list",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_access_list(
    id: str | int,
    confirm: bool = False,
    description: str | None = None,
    entries: list[dict[str, Any]] | None = None,
    name: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/access_list

    id: The ID of the object or resource to interact with.
    description: A description for the access list.
    entries: The network entries for this access list.
    name: The name of the access list.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/access_list. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if description is not None:
        body["description"] = description
    if entries is not None:
        body["entries"] = entries
    if name is not None:
        body["name"] = name
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/access_list",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_access_list(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/access_list

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/access_list. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_bind_access_list_entries(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/access_list/entries

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/bind/access_list/entries",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_bind_access_list_entries(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/access_list/entries

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/access_list/entries. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/access_list/entries",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_bind_access_list_entry(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/access_list/entry

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/access_list/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_access_list_entry(
    parent_id: str | int,
    value: str,
    confirm: bool = False,
    description: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/access_list/entry

    parent_id: The ID of the parent this object is nested under.
    value: The network CIDR to allow.
    description: A description of the access list entry.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/access_list/entry. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if parent_id is not None:
        body["parent_id"] = parent_id
    if value is not None:
        body["value"] = value
    if description is not None:
        body["description"] = description
    return await _client.request(
        "POST",
        "/api/v2/services/bind/access_list/entry",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_access_list_entry(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    description: str | None = None,
    value: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/access_list/entry

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    description: A description of the access list entry.
    value: The network CIDR to allow.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/access_list/entry. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if description is not None:
        body["description"] = description
    if value is not None:
        body["value"] = value
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/access_list/entry",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_access_list_entry(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/access_list/entry

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/access_list/entry. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/access_list/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_bind_access_lists(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/access_lists

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/bind/access_lists",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_bind_access_lists(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/bind/access_lists

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/bind/access_lists. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/bind/access_lists",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_access_lists(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/access_lists

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/access_lists. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/access_lists",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_bind_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/bind/settings",
    )


@mcp.tool()
async def pfsense_update_services_bind_settings(
    confirm: bool = False,
    bind_custom_options: str | None = None,
    bind_dnssec_validation: str | None = None,
    bind_forwarder: bool | None = None,
    bind_forwarder_ips: list[str] | None = None,
    bind_global_settings: str | None = None,
    bind_hide_version: bool | None = None,
    bind_ip_version: str | None = None,
    bind_logging: bool | None = None,
    bind_notify: bool | None = None,
    bind_ram_limit: str | None = None,
    controlport: str | None = None,
    enable_bind: bool | None = None,
    listenon: list[str] | None = None,
    listenport: str | None = None,
    log_only: bool | None = None,
    log_options: list[str] | None = None,
    log_severity: str | None = None,
    rate_enabled: bool | None = None,
    rate_limit: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/settings

    bind_custom_options: Custom BIND options to include in the configuration file.
    bind_dnssec_validation: Enable DNSSEC validation when BIND is acting as a recursive resolver. Valid values: ['auto', 'on', 'off']
    bind_forwarder: Enable forwarding queries to other DNS servers listed below rather than this server performing its own recursion.
    bind_forwarder_ips: The IP addresses of the DNS servers to forward queries to.This field is only available when the following conditions are met:- `bind_forwarder` must be equal to `true`
    bind_global_settings: Global BIND settings to include in the configuration file.
    bind_hide_version: Hide the BIND version in responses.
    bind_ip_version: The IP version to use for the BIND service. Leave empty to use both IPv4 and IPv6. Valid values: ['', '-4', '-6']
    bind_logging: Enable logging for the BIND service.
    bind_notify: Notify slave server after any update on master.
    bind_ram_limit: The maximum amount of RAM to use for the BIND service.
    controlport: The TCP port to listen on for control requests (localhost only). Valid options are: a TCP/UDP port number
    enable_bind: Enables the BIND service.
    listenon: The interfaces to listen on for DNS requests.
    listenport: The TCP and UDP port to listen on for DNS requests. Valid options are: a TCP/UDP port number
    log_only: When rate limiting, only log that the query limit has been exceeded. If disabled, the query will be dropped instead.
    log_options: The categories to log.
    log_severity: The minimum severity of events to log. Valid values: ['critical', 'error', 'warning', 'notice', 'info', 'debug 1', 'debug 3', 'debug 5', 'dynamic']
    rate_enabled: Enable rate limiting for the BIND service.
    rate_limit: The maximum number of queries per second to allow.This field is only available when the following conditions are met:- `rate_enabled` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if bind_custom_options is not None:
        body["bind_custom_options"] = bind_custom_options
    if bind_dnssec_validation is not None:
        body["bind_dnssec_validation"] = bind_dnssec_validation
    if bind_forwarder is not None:
        body["bind_forwarder"] = bind_forwarder
    if bind_forwarder_ips is not None:
        body["bind_forwarder_ips"] = bind_forwarder_ips
    if bind_global_settings is not None:
        body["bind_global_settings"] = bind_global_settings
    if bind_hide_version is not None:
        body["bind_hide_version"] = bind_hide_version
    if bind_ip_version is not None:
        body["bind_ip_version"] = bind_ip_version
    if bind_logging is not None:
        body["bind_logging"] = bind_logging
    if bind_notify is not None:
        body["bind_notify"] = bind_notify
    if bind_ram_limit is not None:
        body["bind_ram_limit"] = bind_ram_limit
    if controlport is not None:
        body["controlport"] = controlport
    if enable_bind is not None:
        body["enable_bind"] = enable_bind
    if listenon is not None:
        body["listenon"] = listenon
    if listenport is not None:
        body["listenport"] = listenport
    if log_only is not None:
        body["log_only"] = log_only
    if log_options is not None:
        body["log_options"] = log_options
    if log_severity is not None:
        body["log_severity"] = log_severity
    if rate_enabled is not None:
        body["rate_enabled"] = rate_enabled
    if rate_limit is not None:
        body["rate_limit"] = rate_limit
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_bind_sync_remote_host(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/sync/remote_host

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/sync/remote_host",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_sync_remote_host(
    ipaddress: str,
    password: str,
    syncport: str,
    syncprotocol: str,
    username: str,
    confirm: bool = False,
    syncdestinenable: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/sync/remote_host

    ipaddress: The IP address/hostname of the remote host.
    password: The password to use to authenticate when syncing.
    syncport: The remote host port to use for syncing. Valid options are: a TCP/UDP port number
    syncprotocol: The protocol to use for syncing. Valid values: ['http', 'https']
    username: The username to use to authenticate when syncing.
    syncdestinenable: Enable this remote host for syncing.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/sync/remote_host. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if ipaddress is not None:
        body["ipaddress"] = ipaddress
    if password is not None:
        body["password"] = password
    if syncport is not None:
        body["syncport"] = syncport
    if syncprotocol is not None:
        body["syncprotocol"] = syncprotocol
    if username is not None:
        body["username"] = username
    if syncdestinenable is not None:
        body["syncdestinenable"] = syncdestinenable
    return await _client.request(
        "POST",
        "/api/v2/services/bind/sync/remote_host",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_sync_remote_host(
    id: str | int,
    confirm: bool = False,
    ipaddress: str | None = None,
    password: str | None = None,
    syncdestinenable: bool | None = None,
    syncport: str | None = None,
    syncprotocol: str | None = None,
    username: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/sync/remote_host

    id: The ID of the object or resource to interact with.
    ipaddress: The IP address/hostname of the remote host.
    password: The password to use to authenticate when syncing.
    syncdestinenable: Enable this remote host for syncing.
    syncport: The remote host port to use for syncing. Valid options are: a TCP/UDP port number
    syncprotocol: The protocol to use for syncing. Valid values: ['http', 'https']
    username: The username to use to authenticate when syncing.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/sync/remote_host. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if ipaddress is not None:
        body["ipaddress"] = ipaddress
    if password is not None:
        body["password"] = password
    if syncdestinenable is not None:
        body["syncdestinenable"] = syncdestinenable
    if syncport is not None:
        body["syncport"] = syncport
    if syncprotocol is not None:
        body["syncprotocol"] = syncprotocol
    if username is not None:
        body["username"] = username
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/sync/remote_host",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_sync_remote_host(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/sync/remote_host

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/sync/remote_host. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/sync/remote_host",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_bind_sync_remote_hosts(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/sync/remote_hosts

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/bind/sync/remote_hosts",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_bind_sync_remote_hosts(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/bind/sync/remote_hosts

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/bind/sync/remote_hosts. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/bind/sync/remote_hosts",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_sync_remote_hosts(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/sync/remote_hosts

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/sync/remote_hosts. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/sync/remote_hosts",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_bind_sync_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/sync/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/bind/sync/settings",
    )


@mcp.tool()
async def pfsense_update_services_bind_sync_settings(
    masterip: str,
    synconchanges: str,
    confirm: bool = False,
    synctimeout: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/sync/settings

    masterip: The IP address of the master BIND server.
    synconchanges: The sync mode to use. Valid values: ['disabled', 'manual', 'auto']
    synctimeout: The timeout for the sync process. Valid values: [30, 60, 90, 120, 150, 250]
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/sync/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if masterip is not None:
        body["masterip"] = masterip
    if synconchanges is not None:
        body["synconchanges"] = synconchanges
    if synctimeout is not None:
        body["synctimeout"] = synctimeout
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/sync/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_bind_view(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/view

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/view",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_view(
    name: str,
    confirm: bool = False,
    allow_recursion: list[str] | None = None,
    bind_custom_options: str | None = None,
    descr: str | None = None,
    match_clients: list[str] | None = None,
    recursion: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/view

    name: The name of the view.
    allow_recursion: The access lists to allow recursion for.
    bind_custom_options: Custom BIND options for the view.
    descr: A description for the view.
    match_clients: The access lists to match clients against.
    recursion: Enables or disables recursion for the view.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/view. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if allow_recursion is not None:
        body["allow_recursion"] = allow_recursion
    if bind_custom_options is not None:
        body["bind_custom_options"] = bind_custom_options
    if descr is not None:
        body["descr"] = descr
    if match_clients is not None:
        body["match_clients"] = match_clients
    if recursion is not None:
        body["recursion"] = recursion
    return await _client.request(
        "POST",
        "/api/v2/services/bind/view",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_view(
    id: str | int,
    confirm: bool = False,
    allow_recursion: list[str] | None = None,
    bind_custom_options: str | None = None,
    descr: str | None = None,
    match_clients: list[str] | None = None,
    name: str | None = None,
    recursion: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/view

    id: The ID of the object or resource to interact with.
    allow_recursion: The access lists to allow recursion for.
    bind_custom_options: Custom BIND options for the view.
    descr: A description for the view.
    match_clients: The access lists to match clients against.
    name: The name of the view.
    recursion: Enables or disables recursion for the view.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/view. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if allow_recursion is not None:
        body["allow_recursion"] = allow_recursion
    if bind_custom_options is not None:
        body["bind_custom_options"] = bind_custom_options
    if descr is not None:
        body["descr"] = descr
    if match_clients is not None:
        body["match_clients"] = match_clients
    if name is not None:
        body["name"] = name
    if recursion is not None:
        body["recursion"] = recursion
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/view",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_view(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/view

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/view. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/view",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_bind_views(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/views

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/bind/views",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_bind_views(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/bind/views

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/bind/views. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/bind/views",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_views(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/views

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/views. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/views",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_bind_zone(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/zone

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/zone",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_zone(
    name: str,
    confirm: bool = False,
    allowquery: list[str] | None = None,
    allowtransfer: list[str] | None = None,
    allowupdate: list[str] | None = None,
    backupkeys: bool | None = None,
    baseip: str | None = None,
    custom: str | None = None,
    customzonerecords: str | None = None,
    description: str | None = None,
    disabled: bool | None = None,
    dnssec: bool | None = None,
    enable_updatepolicy: bool | None = None,
    expire: str | None = None,
    forwarders: list[str] | None = None,
    mail: str | None = None,
    minimum: str | None = None,
    nameserver: str | None = None,
    records: list[dict[str, Any]] | None = None,
    refresh: str | None = None,
    regdhcpstatic: bool | None = None,
    retry: str | None = None,
    reversev4: bool | None = None,
    reversev6: bool | None = None,
    rpz: bool | None = None,
    serial: int | None = None,
    slaveip: str | None = None,
    ttl: int | None = None,
    type_: str | None = 'master',
    updatepolicy: str | None = None,
    view: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/zone

    name: The name of this BIND zone.
    allowquery: The access lists that are allowed to query this BIND zone.
    allowtransfer: The access lists that are allowed to transfer this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    allowupdate: The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).This field is only available when the following conditions are met:- `type` must be equal to `'master'`- `enable_updatepolicy` must be equal to `false`
    backupkeys: Enable backing up DNSSEC keys in the XML configuration for this BIND zone.This field is only available when the following conditions are met:- `dnssec` must be equal to `true`
    baseip: The IP address of the base domain for this zone. This sets an A record for the base domain.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    custom: Custom BIND options for this BIND zone.
    customzonerecords: Custom records for this BIND zone.
    description: A description for this BIND zone.
    disabled: Disable this BIND zone.
    dnssec: Enable DNSSEC for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    enable_updatepolicy: Enable a specific dynamic update policy for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    expire: The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    forwarders: The forwarders for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'forward'`
    mail: The SOA email address (RNAME) for this zone. This must be in an FQDN format.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    minimum: The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    nameserver: The SOA nameserver for this zone.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    records: The records for this BIND zone.
    refresh: The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    regdhcpstatic: Register DHCP static mappings as records in this BIND zone.
    retry: The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    reversev4: Enable reverse DNS for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    reversev6: Enable reverse IPv6 DNS for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    rpz: Enable this zone as part of a response policy.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    serial: The SOA serial number for this zone.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    slaveip: The IP address of the slave server for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'slave'`
    ttl: The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    type_: The type of this BIND zone. Valid values: ['master', 'slave', 'forward', 'redirect']
    updatepolicy: The update policy for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`- `enable_updatepolicy` must be equal to `true`
    view: The views this BIND zone belongs to.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/zone. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if allowquery is not None:
        body["allowquery"] = allowquery
    if allowtransfer is not None:
        body["allowtransfer"] = allowtransfer
    if allowupdate is not None:
        body["allowupdate"] = allowupdate
    if backupkeys is not None:
        body["backupkeys"] = backupkeys
    if baseip is not None:
        body["baseip"] = baseip
    if custom is not None:
        body["custom"] = custom
    if customzonerecords is not None:
        body["customzonerecords"] = customzonerecords
    if description is not None:
        body["description"] = description
    if disabled is not None:
        body["disabled"] = disabled
    if dnssec is not None:
        body["dnssec"] = dnssec
    if enable_updatepolicy is not None:
        body["enable_updatepolicy"] = enable_updatepolicy
    if expire is not None:
        body["expire"] = expire
    if forwarders is not None:
        body["forwarders"] = forwarders
    if mail is not None:
        body["mail"] = mail
    if minimum is not None:
        body["minimum"] = minimum
    if nameserver is not None:
        body["nameserver"] = nameserver
    if records is not None:
        body["records"] = records
    if refresh is not None:
        body["refresh"] = refresh
    if regdhcpstatic is not None:
        body["regdhcpstatic"] = regdhcpstatic
    if retry is not None:
        body["retry"] = retry
    if reversev4 is not None:
        body["reversev4"] = reversev4
    if reversev6 is not None:
        body["reversev6"] = reversev6
    if rpz is not None:
        body["rpz"] = rpz
    if serial is not None:
        body["serial"] = serial
    if slaveip is not None:
        body["slaveip"] = slaveip
    if ttl is not None:
        body["ttl"] = ttl
    if type_ is not None:
        body["type"] = type_
    if updatepolicy is not None:
        body["updatepolicy"] = updatepolicy
    if view is not None:
        body["view"] = view
    return await _client.request(
        "POST",
        "/api/v2/services/bind/zone",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_zone(
    id: str | int,
    confirm: bool = False,
    allowquery: list[str] | None = None,
    allowtransfer: list[str] | None = None,
    allowupdate: list[str] | None = None,
    backupkeys: bool | None = None,
    baseip: str | None = None,
    custom: str | None = None,
    customzonerecords: str | None = None,
    description: str | None = None,
    disabled: bool | None = None,
    dnssec: bool | None = None,
    enable_updatepolicy: bool | None = None,
    expire: str | None = None,
    forwarders: list[str] | None = None,
    mail: str | None = None,
    minimum: str | None = None,
    name: str | None = None,
    nameserver: str | None = None,
    records: list[dict[str, Any]] | None = None,
    refresh: str | None = None,
    regdhcpstatic: bool | None = None,
    retry: str | None = None,
    reversev4: bool | None = None,
    reversev6: bool | None = None,
    rpz: bool | None = None,
    serial: int | None = None,
    slaveip: str | None = None,
    ttl: int | None = None,
    type_: str | None = None,
    updatepolicy: str | None = None,
    view: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/zone

    id: The ID of the object or resource to interact with.
    allowquery: The access lists that are allowed to query this BIND zone.
    allowtransfer: The access lists that are allowed to transfer this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    allowupdate: The access lists that are allowed to submit dynamic updates for 'master' zones (e.g. dynamic DNS).This field is only available when the following conditions are met:- `type` must be equal to `'master'`- `enable_updatepolicy` must be equal to `false`
    backupkeys: Enable backing up DNSSEC keys in the XML configuration for this BIND zone.This field is only available when the following conditions are met:- `dnssec` must be equal to `true`
    baseip: The IP address of the base domain for this zone. This sets an A record for the base domain.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    custom: Custom BIND options for this BIND zone.
    customzonerecords: Custom records for this BIND zone.
    description: A description for this BIND zone.
    disabled: Disable this BIND zone.
    dnssec: Enable DNSSEC for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    enable_updatepolicy: Enable a specific dynamic update policy for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    expire: The SOA expiry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    forwarders: The forwarders for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'forward'`
    mail: The SOA email address (RNAME) for this zone. This must be in an FQDN format.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    minimum: The SOA minimum TTL interval (in seconds) for this zone. This is also referred to as the negative TTL. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    name: The name of this BIND zone.
    nameserver: The SOA nameserver for this zone.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    records: The records for this BIND zone.
    refresh: The SOA refresh interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    regdhcpstatic: Register DHCP static mappings as records in this BIND zone.
    retry: The SOA retry interval for this zone. TTL-style time-unit suffixes are supported (e.g. 1h, 1d, 1w), otherwise time in seconds is assumed.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    reversev4: Enable reverse DNS for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    reversev6: Enable reverse IPv6 DNS for this BIND zone.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    rpz: Enable this zone as part of a response policy.This field is only available when the following conditions are met:- `type` must be one of [ master, slave ]
    serial: The SOA serial number for this zone.This field is only available when the following conditions are met:- `type` must be one of [ master, redirect ]
    slaveip: The IP address of the slave server for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'slave'`
    ttl: The default TTL interval (in seconds) for records within this BIND zone without a specific TTL.This field is only available when the following conditions are met:- `type` must be equal to `'master'`
    type_: The type of this BIND zone. Valid values: ['master', 'slave', 'forward', 'redirect']
    updatepolicy: The update policy for this BIND zone.This field is only available when the following conditions are met:- `type` must be equal to `'master'`- `enable_updatepolicy` must be equal to `true`
    view: The views this BIND zone belongs to.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/zone. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if allowquery is not None:
        body["allowquery"] = allowquery
    if allowtransfer is not None:
        body["allowtransfer"] = allowtransfer
    if allowupdate is not None:
        body["allowupdate"] = allowupdate
    if backupkeys is not None:
        body["backupkeys"] = backupkeys
    if baseip is not None:
        body["baseip"] = baseip
    if custom is not None:
        body["custom"] = custom
    if customzonerecords is not None:
        body["customzonerecords"] = customzonerecords
    if description is not None:
        body["description"] = description
    if disabled is not None:
        body["disabled"] = disabled
    if dnssec is not None:
        body["dnssec"] = dnssec
    if enable_updatepolicy is not None:
        body["enable_updatepolicy"] = enable_updatepolicy
    if expire is not None:
        body["expire"] = expire
    if forwarders is not None:
        body["forwarders"] = forwarders
    if mail is not None:
        body["mail"] = mail
    if minimum is not None:
        body["minimum"] = minimum
    if name is not None:
        body["name"] = name
    if nameserver is not None:
        body["nameserver"] = nameserver
    if records is not None:
        body["records"] = records
    if refresh is not None:
        body["refresh"] = refresh
    if regdhcpstatic is not None:
        body["regdhcpstatic"] = regdhcpstatic
    if retry is not None:
        body["retry"] = retry
    if reversev4 is not None:
        body["reversev4"] = reversev4
    if reversev6 is not None:
        body["reversev6"] = reversev6
    if rpz is not None:
        body["rpz"] = rpz
    if serial is not None:
        body["serial"] = serial
    if slaveip is not None:
        body["slaveip"] = slaveip
    if ttl is not None:
        body["ttl"] = ttl
    if type_ is not None:
        body["type"] = type_
    if updatepolicy is not None:
        body["updatepolicy"] = updatepolicy
    if view is not None:
        body["view"] = view
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/zone",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_zone(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/zone

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/zone. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/zone",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_bind_zone_record(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/zone/record

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/bind/zone/record",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_bind_zone_record(
    name: str,
    parent_id: str | int,
    rdata: str,
    type_: str,
    confirm: bool = False,
    priority: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/bind/zone/record

    name: The domain name for this record.
    parent_id: The ID of the parent this object is nested under.
    rdata: The data for this record. This can be an IP address, domain name, or other data depending on the record type.
    type_: The type of record. Valid values: ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'LOC', 'PTR', 'SRV', 'TXT', 'SPF']
    priority: The priority for this record.This field is only available when the following conditions are met:- `type` must be one of [ MX, SRV ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/bind/zone/record. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if rdata is not None:
        body["rdata"] = rdata
    if type_ is not None:
        body["type"] = type_
    if priority is not None:
        body["priority"] = priority
    return await _client.request(
        "POST",
        "/api/v2/services/bind/zone/record",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_bind_zone_record(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    name: str | None = None,
    priority: int | None = None,
    rdata: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/bind/zone/record

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    name: The domain name for this record.
    priority: The priority for this record.This field is only available when the following conditions are met:- `type` must be one of [ MX, SRV ]
    rdata: The data for this record. This can be an IP address, domain name, or other data depending on the record type.
    type_: The type of record. Valid values: ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'LOC', 'PTR', 'SRV', 'TXT', 'SPF']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/bind/zone/record. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if name is not None:
        body["name"] = name
    if priority is not None:
        body["priority"] = priority
    if rdata is not None:
        body["rdata"] = rdata
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/services/bind/zone/record",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_zone_record(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/zone/record

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/zone/record. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/zone/record",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_bind_zones(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/bind/zones

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/bind/zones",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_bind_zones(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/bind/zones

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/bind/zones. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/bind/zones",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_bind_zones(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/bind/zones

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/bind/zones. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/bind/zones",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_cron_job(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/cron/job

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/cron/job",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_cron_job(
    command: str,
    minute: str,
    who: str,
    confirm: bool = False,
    hour: str | None = None,
    mday: str | None = None,
    month: str | None = None,
    wday: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/cron/job

    command: The command to run. Use full file paths for this command and include an command parameters.
    minute: The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.
    who: The OS user to use when cron runs the command.
    hour: The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    mday: The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    month: The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    wday: The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/cron/job. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if command is not None:
        body["command"] = command
    if minute is not None:
        body["minute"] = minute
    if who is not None:
        body["who"] = who
    if hour is not None:
        body["hour"] = hour
    if mday is not None:
        body["mday"] = mday
    if month is not None:
        body["month"] = month
    if wday is not None:
        body["wday"] = wday
    return await _client.request(
        "POST",
        "/api/v2/services/cron/job",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_cron_job(
    id: str | int,
    confirm: bool = False,
    command: str | None = None,
    hour: str | None = None,
    mday: str | None = None,
    minute: str | None = None,
    month: str | None = None,
    wday: str | None = None,
    who: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/cron/job

    id: The ID of the object or resource to interact with.
    command: The command to run. Use full file paths for this command and include an command parameters.
    hour: The hour(s) at which the command will be executed. (0-23, ranges, or divided, *=all)This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    mday: The day(s) of the month on which the command will be executed. (1-31, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    minute: The minute(s) at which the command will be executed or a special @ event string. (0-59, ranges, divided, @ event or delay, *=all). When using a special @ event, such as @reboot, the other time fields must be empty.
    month: The month(s) of the year in which the command will be executed. (1-31, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    wday: The day(s) of the week on which the command will be executed. (0-7, 7=Sun or use names, ranges, or divided, *=all).This field is only available when the following conditions are met:- `minute` must not be one of [ @reboot, @yearly, @annually, @monthly, @weekly, @daily, @midnight, @hourly, @every_minute, @every_second ]
    who: The OS user to use when cron runs the command.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/cron/job. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if command is not None:
        body["command"] = command
    if hour is not None:
        body["hour"] = hour
    if mday is not None:
        body["mday"] = mday
    if minute is not None:
        body["minute"] = minute
    if month is not None:
        body["month"] = month
    if wday is not None:
        body["wday"] = wday
    if who is not None:
        body["who"] = who
    return await _client.request(
        "PATCH",
        "/api/v2/services/cron/job",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_cron_job(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/cron/job

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/cron/job. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/cron/job",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_cron_jobs(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/cron/jobs

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/cron/jobs",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_cron_jobs(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/cron/jobs

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/cron/jobs. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/cron/jobs",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_cron_jobs(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/cron/jobs

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/cron/jobs. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/cron/jobs",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_relay(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_relay
    """
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_relay",
    )


@mcp.tool()
async def pfsense_update_services_dhcp_relay(
    server: list[str],
    confirm: bool = False,
    agentoption: bool | None = None,
    carpstatusvip: str | None = None,
    enable: bool | None = None,
    interface: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_relay

    server: The IPv4 addresses of the DHCP server to relay requests to.
    agentoption: Enables or disables appending the circuit ID (interface number) and the agent ID to the DHCP request.
    carpstatusvip: DHCP Relay will be stopped when the chosen VIP is in BACKUP status, and started in MASTER status.
    enable: Enables or disables the DHCP relay.
    interface: The downstream interfaces to listen on for DHCP requests.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_relay. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if server is not None:
        body["server"] = server
    if agentoption is not None:
        body["agentoption"] = agentoption
    if carpstatusvip is not None:
        body["carpstatusvip"] = carpstatusvip
    if enable is not None:
        body["enable"] = enable
    if interface is not None:
        body["interface"] = interface
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_relay",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_server_address_pool(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/address_pool

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/address_pool",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dhcp_server_address_pool(
    parent_id: str | int,
    range_from: str,
    range_to: str,
    confirm: bool = False,
    defaultleasetime: int | None = 7200,
    denyunknown: str | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    gateway: str | None = None,
    ignorebootp: bool | None = None,
    ignoreclientuids: bool | None = None,
    mac_allow: list[str] | None = None,
    mac_deny: list[str] | None = None,
    maxleasetime: int | None = 86400,
    ntpserver: list[str] | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dhcp_server/address_pool

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    parent_id: The ID of the parent this object is nested under.
    range_from: The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.
    range_to: The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    denyunknown: Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range. Valid values: ['enabled', 'class']
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    ignorebootp: Force this DHCP server to ignore BOOTP queries.
    ignoreclientuids: Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.
    mac_allow: MAC addresses this DHCP server is allowed to provide leases for.
    mac_deny: MAC addresses this DHCP server is not allowed to provide leases for.
    maxleasetime: The maximum DHCP lease validity period (in seconds) a client can request.
    ntpserver: The NTP servers to provide via DHCP.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dhcp_server/address_pool. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if parent_id is not None:
        body["parent_id"] = parent_id
    if range_from is not None:
        body["range_from"] = range_from
    if range_to is not None:
        body["range_to"] = range_to
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if denyunknown is not None:
        body["denyunknown"] = denyunknown
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if gateway is not None:
        body["gateway"] = gateway
    if ignorebootp is not None:
        body["ignorebootp"] = ignorebootp
    if ignoreclientuids is not None:
        body["ignoreclientuids"] = ignoreclientuids
    if mac_allow is not None:
        body["mac_allow"] = mac_allow
    if mac_deny is not None:
        body["mac_deny"] = mac_deny
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "POST",
        "/api/v2/services/dhcp_server/address_pool",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dhcp_server_address_pool(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    defaultleasetime: int | None = None,
    denyunknown: str | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    gateway: str | None = None,
    ignorebootp: bool | None = None,
    ignoreclientuids: bool | None = None,
    mac_allow: list[str] | None = None,
    mac_deny: list[str] | None = None,
    maxleasetime: int | None = None,
    ntpserver: list[str] | None = None,
    range_from: str | None = None,
    range_to: str | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_server/address_pool

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    denyunknown: Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range. Valid values: ['enabled', 'class']
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    ignorebootp: Force this DHCP server to ignore BOOTP queries.
    ignoreclientuids: Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.
    mac_allow: MAC addresses this DHCP server is allowed to provide leases for.
    mac_deny: MAC addresses this DHCP server is not allowed to provide leases for.
    maxleasetime: The maximum DHCP lease validity period (in seconds) a client can request.
    ntpserver: The NTP servers to provide via DHCP.
    range_from: The starting IP address for this address pool. This address must be less than or equal to the `range_to` field.
    range_to: The ending IP address for the this address pool. This address must be greater than or equal to the `range_to` field.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_server/address_pool. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if denyunknown is not None:
        body["denyunknown"] = denyunknown
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if gateway is not None:
        body["gateway"] = gateway
    if ignorebootp is not None:
        body["ignorebootp"] = ignorebootp
    if ignoreclientuids is not None:
        body["ignoreclientuids"] = ignoreclientuids
    if mac_allow is not None:
        body["mac_allow"] = mac_allow
    if mac_deny is not None:
        body["mac_deny"] = mac_deny
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if range_from is not None:
        body["range_from"] = range_from
    if range_to is not None:
        body["range_to"] = range_to
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_server/address_pool",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_address_pool(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/address_pool

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/address_pool. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/address_pool",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dhcp_server_address_pools(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/address_pools

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/address_pools",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_address_pools(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/address_pools

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/address_pools. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/address_pools",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_server_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/apply",
    )


@mcp.tool()
async def pfsense_services_dhcp_server_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dhcp_server/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dhcp_server/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/services/dhcp_server/apply",
    )


@mcp.tool()
async def pfsense_update_services_dhcp_server_backend(
    confirm: bool = False,
    dhcpbackend: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_server/backend

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    dhcpbackend: The backend DHCP server service to use. ISC DHCP is deprecate and will be removed in a future version of pfSense. Valid values: ['isc', 'kea']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_server/backend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if dhcpbackend is not None:
        body["dhcpbackend"] = dhcpbackend
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_server/backend",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_server_custom_option(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/custom_option

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/custom_option",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dhcp_server_custom_option(
    number: int,
    parent_id: str | int,
    type_: str,
    value: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dhcp_server/custom_option

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    number: The DHCP option number to configure.
    parent_id: The ID of the parent this object is nested under.
    type_: The type of value to configure for the option. Valid values: ['text', 'string', 'boolean', 'unsigned integer 8', 'unsigned integer 16', 'unsigned integer 32', 'signed integer 8', 'signed integer 16', 'signed integer 32', 'ip-address']
    value: The value to configure for the option.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dhcp_server/custom_option. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if number is not None:
        body["number"] = number
    if parent_id is not None:
        body["parent_id"] = parent_id
    if type_ is not None:
        body["type"] = type_
    if value is not None:
        body["value"] = value
    return await _client.request(
        "POST",
        "/api/v2/services/dhcp_server/custom_option",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dhcp_server_custom_option(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    number: int | None = None,
    type_: str | None = None,
    value: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_server/custom_option

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    number: The DHCP option number to configure.
    type_: The type of value to configure for the option. Valid values: ['text', 'string', 'boolean', 'unsigned integer 8', 'unsigned integer 16', 'unsigned integer 32', 'signed integer 8', 'signed integer 16', 'signed integer 32', 'ip-address']
    value: The value to configure for the option.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_server/custom_option. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if number is not None:
        body["number"] = number
    if type_ is not None:
        body["type"] = type_
    if value is not None:
        body["value"] = value
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_server/custom_option",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_custom_option(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/custom_option

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/custom_option. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/custom_option",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dhcp_server_custom_options(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/custom_options

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/custom_options",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_custom_options(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/custom_options

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/custom_options. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/custom_options",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_server(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dhcp_server(
    interface: str,
    confirm: bool = False,
    defaultleasetime: int | None = 7200,
    denyunknown: str | None = None,
    dhcpleaseinlocaltime: bool | None = None,
    disablepingcheck: bool | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    enable: bool | None = None,
    failover_peerip: str | None = None,
    gateway: str | None = None,
    ignorebootp: bool | None = None,
    ignoreclientuids: bool | None = None,
    mac_allow: list[str] | None = None,
    mac_deny: list[str] | None = None,
    maxleasetime: int | None = 86400,
    nonak: bool | None = None,
    ntpserver: list[str] | None = None,
    numberoptions: list[dict[str, Any]] | None = None,
    pool: list[dict[str, Any]] | None = None,
    range_from: str | None = None,
    range_to: str | None = None,
    staticarp: bool | None = None,
    staticmap: list[dict[str, Any]] | None = None,
    statsgraph: bool | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dhcp_server

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    interface: The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    denyunknown: Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range. Valid values: ['enabled', 'class']
    dhcpleaseinlocaltime: Display the DHCP lease times in local time instead of UTC.
    disablepingcheck: Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    enable: Enable the DHCP server for this interface.
    failover_peerip: The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    ignorebootp: Force this DHCP server to ignore BOOTP queries.
    ignoreclientuids: Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.
    mac_allow: MAC addresses this DHCP server is allowed to provide leases for.
    mac_deny: MAC addresses this DHCP server is not allowed to provide leases for.
    maxleasetime: The maximum DHCP lease validity period (in seconds) a client can request.
    nonak: Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.
    ntpserver: The NTP servers to provide via DHCP.
    numberoptions: The custom DHCP options to apply to this DHCP server.
    pool: Additional address pools applied to this DHCP server.
    range_from: The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.
    range_to: The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.
    staticarp: Assign static ARP entries for DHCP leases provided by this server.
    staticmap: Static mappings applied to this DHCP server.
    statsgraph: Enable adding DHCP lease statistics to the pfSense Monitoring graphs.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dhcp_server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if interface is not None:
        body["interface"] = interface
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if denyunknown is not None:
        body["denyunknown"] = denyunknown
    if dhcpleaseinlocaltime is not None:
        body["dhcpleaseinlocaltime"] = dhcpleaseinlocaltime
    if disablepingcheck is not None:
        body["disablepingcheck"] = disablepingcheck
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if enable is not None:
        body["enable"] = enable
    if failover_peerip is not None:
        body["failover_peerip"] = failover_peerip
    if gateway is not None:
        body["gateway"] = gateway
    if ignorebootp is not None:
        body["ignorebootp"] = ignorebootp
    if ignoreclientuids is not None:
        body["ignoreclientuids"] = ignoreclientuids
    if mac_allow is not None:
        body["mac_allow"] = mac_allow
    if mac_deny is not None:
        body["mac_deny"] = mac_deny
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if nonak is not None:
        body["nonak"] = nonak
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if numberoptions is not None:
        body["numberoptions"] = numberoptions
    if pool is not None:
        body["pool"] = pool
    if range_from is not None:
        body["range_from"] = range_from
    if range_to is not None:
        body["range_to"] = range_to
    if staticarp is not None:
        body["staticarp"] = staticarp
    if staticmap is not None:
        body["staticmap"] = staticmap
    if statsgraph is not None:
        body["statsgraph"] = statsgraph
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "POST",
        "/api/v2/services/dhcp_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dhcp_server(
    id: str | int,
    confirm: bool = False,
    defaultleasetime: int | None = None,
    denyunknown: str | None = None,
    dhcpleaseinlocaltime: bool | None = None,
    disablepingcheck: bool | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    enable: bool | None = None,
    failover_peerip: str | None = None,
    gateway: str | None = None,
    ignorebootp: bool | None = None,
    ignoreclientuids: bool | None = None,
    interface: str | None = None,
    mac_allow: list[str] | None = None,
    mac_deny: list[str] | None = None,
    maxleasetime: int | None = None,
    nonak: bool | None = None,
    ntpserver: list[str] | None = None,
    numberoptions: list[dict[str, Any]] | None = None,
    pool: list[dict[str, Any]] | None = None,
    range_from: str | None = None,
    range_to: str | None = None,
    staticarp: bool | None = None,
    staticmap: list[dict[str, Any]] | None = None,
    statsgraph: bool | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_server

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    denyunknown: Define how to handle unknown clients requesting DHCP leases. When set to `null`, any DHCP client will get an IP address within this scope/range on this interface. If set to `enabled`, any DHCP client with a MAC address listed in a static mapping on any scope(s)/interface(s) will get an IP address. If set to `class`, only MAC addresses listed in static mappings on this interface will get an IP address within this scope/range. Valid values: ['enabled', 'class']
    dhcpleaseinlocaltime: Display the DHCP lease times in local time instead of UTC.
    disablepingcheck: Prevent the DHCP server from sending a ping to the address being assigned, where if no response has been heard, it assigns the address.
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    enable: Enable the DHCP server for this interface.
    failover_peerip: The interface IP address of the other firewall (failover peer) in this subnet. Leave empty to disable failover peering.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    ignorebootp: Force this DHCP server to ignore BOOTP queries.
    ignoreclientuids: Prevent recording a unique identifier (UID) in client lease data if present in the client DHCP request. This option may be useful when a client can dual boot using different client identifiers but the same hardware (MAC) address. Note that the resulting server behavior violates the official DHCP specification.
    interface: The interface to configure the DHCP server for. This field is only necessary when you wantto change the interface (ID) of an existing DHCP server, or you are replacing all DHCP server objects with a new configuration. Note that specifying an interface in this field will update the ID of the DHCP server to match the interface specified here. Leaving this field empty will retain the existing interface.
    mac_allow: MAC addresses this DHCP server is allowed to provide leases for.
    mac_deny: MAC addresses this DHCP server is not allowed to provide leases for.
    maxleasetime: The maximum DHCP lease validity period (in seconds) a client can request.
    nonak: Ignore denied clients rather than reject. This option is not compatible with failover and cannot be enabled when a Failover Peer IP address is configured.
    ntpserver: The NTP servers to provide via DHCP.
    numberoptions: The custom DHCP options to apply to this DHCP server.
    pool: Additional address pools applied to this DHCP server.
    range_from: The starting IP address for the primary DHCP pool. This address must be less than or equal to the `range_to` field.
    range_to: The ending IP address for the primary DHCP pool. This address must be greater than or equal to the `range_to` field.
    staticarp: Assign static ARP entries for DHCP leases provided by this server.
    staticmap: Static mappings applied to this DHCP server.
    statsgraph: Enable adding DHCP lease statistics to the pfSense Monitoring graphs.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if denyunknown is not None:
        body["denyunknown"] = denyunknown
    if dhcpleaseinlocaltime is not None:
        body["dhcpleaseinlocaltime"] = dhcpleaseinlocaltime
    if disablepingcheck is not None:
        body["disablepingcheck"] = disablepingcheck
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if enable is not None:
        body["enable"] = enable
    if failover_peerip is not None:
        body["failover_peerip"] = failover_peerip
    if gateway is not None:
        body["gateway"] = gateway
    if ignorebootp is not None:
        body["ignorebootp"] = ignorebootp
    if ignoreclientuids is not None:
        body["ignoreclientuids"] = ignoreclientuids
    if interface is not None:
        body["interface"] = interface
    if mac_allow is not None:
        body["mac_allow"] = mac_allow
    if mac_deny is not None:
        body["mac_deny"] = mac_deny
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if nonak is not None:
        body["nonak"] = nonak
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if numberoptions is not None:
        body["numberoptions"] = numberoptions
    if pool is not None:
        body["pool"] = pool
    if range_from is not None:
        body["range_from"] = range_from
    if range_to is not None:
        body["range_to"] = range_to
    if staticarp is not None:
        body["staticarp"] = staticarp
    if staticmap is not None:
        body["staticmap"] = staticmap
    if statsgraph is not None:
        body["statsgraph"] = statsgraph
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dhcp_server_static_mapping(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/static_mapping

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/static_mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dhcp_server_static_mapping(
    mac: str,
    parent_id: str | int,
    confirm: bool = False,
    arp_table_static_entry: bool | None = None,
    cid: str | None = None,
    defaultleasetime: int | None = 7200,
    descr: str | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    gateway: str | None = None,
    hostname: str | None = None,
    ipaddr: str | None = None,
    maxleasetime: int | None = 86400,
    ntpserver: list[str] | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dhcp_server/static_mapping

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    mac: The MAC address of the client this mapping is for.
    parent_id: The ID of the parent this object is nested under.
    arp_table_static_entry: Assign a static ARP entry for this static mapping.
    cid: The client identifier of the client this mapping is for.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    descr: The description of this static mapping.
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    hostname: The hostname to assign this client via DHCP.
    ipaddr: The IP address to assign this client via DHCP.
    maxleasetime: The maximum DHCP lease validity period (in seconds) this client can request.
    ntpserver: The NTP servers to provide via DHCP.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dhcp_server/static_mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if mac is not None:
        body["mac"] = mac
    if parent_id is not None:
        body["parent_id"] = parent_id
    if arp_table_static_entry is not None:
        body["arp_table_static_entry"] = arp_table_static_entry
    if cid is not None:
        body["cid"] = cid
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if descr is not None:
        body["descr"] = descr
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if gateway is not None:
        body["gateway"] = gateway
    if hostname is not None:
        body["hostname"] = hostname
    if ipaddr is not None:
        body["ipaddr"] = ipaddr
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "POST",
        "/api/v2/services/dhcp_server/static_mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dhcp_server_static_mapping(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    arp_table_static_entry: bool | None = None,
    cid: str | None = None,
    defaultleasetime: int | None = None,
    descr: str | None = None,
    dnsserver: list[str] | None = None,
    domain: str | None = None,
    domainsearchlist: list[str] | None = None,
    gateway: str | None = None,
    hostname: str | None = None,
    ipaddr: str | None = None,
    mac: str | None = None,
    maxleasetime: int | None = None,
    ntpserver: list[str] | None = None,
    winsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dhcp_server/static_mapping

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    arp_table_static_entry: Assign a static ARP entry for this static mapping.
    cid: The client identifier of the client this mapping is for.
    defaultleasetime: The default DHCP lease validity period (in seconds). This is used for clients that do not ask for a specific expiration time.
    descr: The description of this static mapping.
    dnsserver: The DNS servers to provide via DHCP. Leave empty to default to system nameservers.
    domain: The domain to be assigned via DHCP.
    domainsearchlist: The domain search list to provide via DHCP.
    gateway: The gateway IPv4 address to provide via DHCP. This is only necessary if you are not using the interface's IP as the gateway. Specify `none` for no gateway assignment.
    hostname: The hostname to assign this client via DHCP.
    ipaddr: The IP address to assign this client via DHCP.
    mac: The MAC address of the client this mapping is for.
    maxleasetime: The maximum DHCP lease validity period (in seconds) this client can request.
    ntpserver: The NTP servers to provide via DHCP.
    winsserver: The WINS servers to provide via DHCP.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dhcp_server/static_mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if arp_table_static_entry is not None:
        body["arp_table_static_entry"] = arp_table_static_entry
    if cid is not None:
        body["cid"] = cid
    if defaultleasetime is not None:
        body["defaultleasetime"] = defaultleasetime
    if descr is not None:
        body["descr"] = descr
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    if domain is not None:
        body["domain"] = domain
    if domainsearchlist is not None:
        body["domainsearchlist"] = domainsearchlist
    if gateway is not None:
        body["gateway"] = gateway
    if hostname is not None:
        body["hostname"] = hostname
    if ipaddr is not None:
        body["ipaddr"] = ipaddr
    if mac is not None:
        body["mac"] = mac
    if maxleasetime is not None:
        body["maxleasetime"] = maxleasetime
    if ntpserver is not None:
        body["ntpserver"] = ntpserver
    if winsserver is not None:
        body["winsserver"] = winsserver
    return await _client.request(
        "PATCH",
        "/api/v2/services/dhcp_server/static_mapping",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_static_mapping(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/static_mapping

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/static_mapping. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/static_mapping",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dhcp_server_static_mappings(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_server/static_mappings

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_server/static_mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dhcp_server_static_mappings(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dhcp_server/static_mappings

    Note: Call pfsense_services_dhcp_server_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dhcp_server/static_mappings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dhcp_server_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dhcp_server/static_mappings",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dhcp_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dhcp_servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dhcp_servers",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_dhcp_servers(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/dhcp_servers

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/dhcp_servers. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/dhcp_servers",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_dns_forwarder_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_forwarder/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/services/dns_forwarder/apply",
    )


@mcp.tool()
async def pfsense_services_dns_forwarder_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_forwarder/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_forwarder/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/services/dns_forwarder/apply",
    )


@mcp.tool()
async def pfsense_get_services_dns_forwarder_host_override_alias(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_forwarder/host_override/alias

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_forwarder/host_override/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_forwarder_host_override_alias(
    domain: str,
    host: str,
    parent_id: str | int,
    confirm: bool = False,
    description: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_forwarder/host_override/alias

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    domain: The domain of this override alias.
    host: The hostname of this override alias.
    parent_id: The ID of the parent this object is nested under.
    description: The description of this override alias.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_forwarder/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if parent_id is not None:
        body["parent_id"] = parent_id
    if description is not None:
        body["description"] = description
    return await _client.request(
        "POST",
        "/api/v2/services/dns_forwarder/host_override/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_forwarder_host_override_alias(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    description: str | None = None,
    domain: str | None = None,
    host: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_forwarder/host_override/alias

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    description: The description of this override alias.
    domain: The domain of this override alias.
    host: The hostname of this override alias.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_forwarder/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if description is not None:
        body["description"] = description
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_forwarder/host_override/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_forwarder_host_override_alias(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_forwarder/host_override/alias

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_forwarder/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_forwarder/host_override/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_forwarder_host_override_aliases(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_forwarder/host_override/aliases

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_forwarder/host_override/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dns_forwarder_host_override_aliases(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_forwarder/host_override/aliases

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_forwarder/host_override/aliases. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_forwarder/host_override/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_forwarder_host_override(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_forwarder/host_override

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_forwarder/host_override",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_forwarder_host_override(
    domain: str,
    host: str,
    ip: str,
    confirm: bool = False,
    aliases: list[dict[str, Any]] | None = None,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_forwarder/host_override

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    domain: The domain of this override.
    host: The hostname of this override.
    ip: The IP address of this override.
    aliases: The aliases for this override.
    descr: The description for this override.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_forwarder/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if ip is not None:
        body["ip"] = ip
    if aliases is not None:
        body["aliases"] = aliases
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/services/dns_forwarder/host_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_forwarder_host_override(
    id: str | int,
    confirm: bool = False,
    aliases: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    domain: str | None = None,
    host: str | None = None,
    ip: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_forwarder/host_override

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    aliases: The aliases for this override.
    descr: The description for this override.
    domain: The domain of this override.
    host: The hostname of this override.
    ip: The IP address of this override.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_forwarder/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if aliases is not None:
        body["aliases"] = aliases
    if descr is not None:
        body["descr"] = descr
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if ip is not None:
        body["ip"] = ip
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_forwarder/host_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_forwarder_host_override(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_forwarder/host_override

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_forwarder/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_forwarder/host_override",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_forwarder_host_overrides(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_forwarder/host_overrides

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_forwarder/host_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_dns_forwarder_host_overrides(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/dns_forwarder/host_overrides

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/dns_forwarder/host_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/dns_forwarder/host_overrides",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_forwarder_host_overrides(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_forwarder/host_overrides

    Note: Call pfsense_services_dns_forwarder_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_forwarder/host_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_forwarder_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_forwarder/host_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_access_list(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/access_list

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_resolver_access_list(
    action: str,
    name: str,
    networks: list[dict[str, Any]],
    confirm: bool = False,
    description: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/access_list

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    action: The action to take when an access list match is found. Valid values: ['allow', 'deny', 'refuse', 'allow snoop', 'deny nonlocal', 'refuse nonlocal']
    name: The name of this access list.
    networks: The DNS Resolver access list network entries to include in this access list.
    description: A description for this access list.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/access_list. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if action is not None:
        body["action"] = action
    if name is not None:
        body["name"] = name
    if networks is not None:
        body["networks"] = networks
    if description is not None:
        body["description"] = description
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/access_list",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_access_list(
    id: str | int,
    confirm: bool = False,
    action: str | None = None,
    description: str | None = None,
    name: str | None = None,
    networks: list[dict[str, Any]] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/access_list

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    action: The action to take when an access list match is found. Valid values: ['allow', 'deny', 'refuse', 'allow snoop', 'deny nonlocal', 'refuse nonlocal']
    description: A description for this access list.
    name: The name of this access list.
    networks: The DNS Resolver access list network entries to include in this access list.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/access_list. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if action is not None:
        body["action"] = action
    if description is not None:
        body["description"] = description
    if name is not None:
        body["name"] = name
    if networks is not None:
        body["networks"] = networks
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/access_list",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_access_list(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/access_list

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/access_list. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_access_list_network(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/access_list/network

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/access_list/network",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_resolver_access_list_network(
    mask: int,
    network: str,
    parent_id: str | int,
    confirm: bool = False,
    description: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/access_list/network

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    mask: The subnet mask of this access list entry's network.
    network: The network address of this access list entry.
    parent_id: The ID of the parent this object is nested under.
    description: A description for this access list entry.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/access_list/network. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if mask is not None:
        body["mask"] = mask
    if network is not None:
        body["network"] = network
    if parent_id is not None:
        body["parent_id"] = parent_id
    if description is not None:
        body["description"] = description
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/access_list/network",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_access_list_network(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    description: str | None = None,
    mask: int | None = None,
    network: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/access_list/network

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    description: A description for this access list entry.
    mask: The subnet mask of this access list entry's network.
    network: The network address of this access list entry.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/access_list/network. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if description is not None:
        body["description"] = description
    if mask is not None:
        body["mask"] = mask
    if network is not None:
        body["network"] = network
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/access_list/network",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_access_list_network(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/access_list/network

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/access_list/network. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/access_list/network",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_resolver_access_list_networks(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/access_list/networks

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/access_list/networks",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_access_list_networks(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/access_list/networks

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/access_list/networks. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/access_list/networks",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_resolver_access_lists(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/access_lists

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/access_lists",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_dns_resolver_access_lists(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/dns_resolver/access_lists

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/dns_resolver/access_lists. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/dns_resolver/access_lists",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_access_lists(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/access_lists

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/access_lists. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/access_lists",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/apply",
    )


@mcp.tool()
async def pfsense_services_dns_resolver_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/apply",
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_domain_override(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/domain_override

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/domain_override",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_resolver_domain_override(
    domain: str,
    ip: str,
    confirm: bool = False,
    descr: str | None = None,
    forward_tls_upstream: bool | None = None,
    tls_hostname: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/domain_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    domain: The domain to override.
    ip: The IP address to which the domain should resolve.
    descr: The description for this domain override.
    forward_tls_upstream: Enables or disables forwarding DNS queries to the upstream DNS server using TLS.
    tls_hostname: The hostname to use for the TLS connection to the upstream DNS server.This field is only available when the following conditions are met:- `forward_tls_upstream` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/domain_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if ip is not None:
        body["ip"] = ip
    if descr is not None:
        body["descr"] = descr
    if forward_tls_upstream is not None:
        body["forward_tls_upstream"] = forward_tls_upstream
    if tls_hostname is not None:
        body["tls_hostname"] = tls_hostname
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/domain_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_domain_override(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    domain: str | None = None,
    forward_tls_upstream: bool | None = None,
    ip: str | None = None,
    tls_hostname: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/domain_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: The description for this domain override.
    domain: The domain to override.
    forward_tls_upstream: Enables or disables forwarding DNS queries to the upstream DNS server using TLS.
    ip: The IP address to which the domain should resolve.
    tls_hostname: The hostname to use for the TLS connection to the upstream DNS server.This field is only available when the following conditions are met:- `forward_tls_upstream` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/domain_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if domain is not None:
        body["domain"] = domain
    if forward_tls_upstream is not None:
        body["forward_tls_upstream"] = forward_tls_upstream
    if ip is not None:
        body["ip"] = ip
    if tls_hostname is not None:
        body["tls_hostname"] = tls_hostname
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/domain_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_domain_override(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/domain_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/domain_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/domain_override",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_resolver_domain_overrides(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/domain_overrides

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/domain_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_dns_resolver_domain_overrides(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/dns_resolver/domain_overrides

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/dns_resolver/domain_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/dns_resolver/domain_overrides",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_domain_overrides(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/domain_overrides

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/domain_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/domain_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_host_override_alias(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/host_override/alias

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/host_override/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_resolver_host_override_alias(
    domain: str,
    host: str,
    parent_id: str | int,
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/host_override/alias

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    domain: The hostname portion of the host override alias.
    host: The hostname portion of the host override alias.
    parent_id: The ID of the parent this object is nested under.
    descr: A detailed description for this host override alias.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if parent_id is not None:
        body["parent_id"] = parent_id
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/host_override/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_host_override_alias(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    domain: str | None = None,
    host: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/host_override/alias

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    descr: A detailed description for this host override alias.
    domain: The hostname portion of the host override alias.
    host: The hostname portion of the host override alias.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if descr is not None:
        body["descr"] = descr
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/host_override/alias",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_host_override_alias(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/host_override/alias

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/host_override/alias. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/host_override/alias",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_resolver_host_override_aliases(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/host_override/aliases

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/host_override/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_host_override_aliases(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/host_override/aliases

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/host_override/aliases. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/host_override/aliases",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_host_override(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/host_override

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/host_override",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_dns_resolver_host_override(
    domain: str,
    host: str,
    ip: list[str],
    confirm: bool = False,
    aliases: list[dict[str, Any]] | None = None,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/dns_resolver/host_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    domain: The hostname portion of the host override.
    host: The hostname portion of the host override.
    ip: The IP addresses this host override will resolve.
    aliases: Additional alias hostnames that should resolve the same IP(s).
    descr: A detailed description for this host override.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/dns_resolver/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if ip is not None:
        body["ip"] = ip
    if aliases is not None:
        body["aliases"] = aliases
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/services/dns_resolver/host_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_host_override(
    id: str | int,
    confirm: bool = False,
    aliases: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    domain: str | None = None,
    host: str | None = None,
    ip: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/host_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    aliases: Additional alias hostnames that should resolve the same IP(s).
    descr: A detailed description for this host override.
    domain: The hostname portion of the host override.
    host: The hostname portion of the host override.
    ip: The IP addresses this host override will resolve.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if aliases is not None:
        body["aliases"] = aliases
    if descr is not None:
        body["descr"] = descr
    if domain is not None:
        body["domain"] = domain
    if host is not None:
        body["host"] = host
    if ip is not None:
        body["ip"] = ip
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/host_override",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_host_override(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/host_override

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/host_override. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/host_override",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_dns_resolver_host_overrides(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/host_overrides

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/host_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_dns_resolver_host_overrides(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/dns_resolver/host_overrides

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/dns_resolver/host_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/dns_resolver/host_overrides",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_dns_resolver_host_overrides(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/dns_resolver/host_overrides

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/dns_resolver/host_overrides. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/dns_resolver/host_overrides",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_dns_resolver_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/dns_resolver/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/dns_resolver/settings",
    )


@mcp.tool()
async def pfsense_update_services_dns_resolver_settings(
    confirm: bool = False,
    active_interface: list[str] | None = None,
    custom_options: str | None = None,
    dnssec: bool | None = None,
    enable: bool | None = None,
    enablessl: bool | None = None,
    forwarding: bool | None = None,
    outgoing_interface: list[str] | None = None,
    port: str | None = None,
    python: bool | None = None,
    python_order: str | None = None,
    python_script: str | None = None,
    regdhcp: bool | None = None,
    regdhcpstatic: bool | None = None,
    regovpnclients: bool | None = None,
    sslcertref: str | None = None,
    strictout: bool | None = None,
    system_domain_local_zone_type: str | None = None,
    tlsport: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/dns_resolver/settings

    Note: Call pfsense_services_dns_resolver_apply after this to apply changes.

    active_interface: The interface on which the DNS Resolver service listens for DNS queries. Set empty value ". "to listen on all interfaces.
    custom_options: Custom options to add to the DNS Resolver configuration.
    dnssec: Enables or disables DNSSEC validation.
    enable: Enables or disables the DNS Resolver service.
    enablessl: Enables or disables SSL/TLS for the DNS Resolver service.
    forwarding: Enables or disables DNS Resolver forwarding mode.
    outgoing_interface: The interface on which the DNS Resolver service sends outgoing DNS queries. Set empty value ". "to use any interface.
    port: The port on which the DNS Resolver service listens. Valid options are: a TCP/UDP port number
    python: Enables or disables the Python module.
    python_order: The order in which the Python module is loaded.This field is only available when the following conditions are met:- `python` must be equal to `true` Valid values: ['pre_validator', 'post_validator']
    python_script: The Python module to utilize.This field is only available when the following conditions are met:- `python` must be equal to `true`
    regdhcp: Enables or disables registering DHCP leases in the DNS Resolver service.
    regdhcpstatic: Enables or disables registering static DHCP mappings in the DNS Resolver service.
    regovpnclients: Enables or disables registering OpenVPN clients in the DNS Resolver service.
    sslcertref: The SSL/TLS certificate to use for the DNS Resolver service.This field is only available when the following conditions are met:- `enablessl` must be equal to `true`
    strictout: Enables or disables sending recursive queries if none of the selected Outgoing Network ". "Interfaces are available.
    system_domain_local_zone_type: The type of local zone used for the system domain. Valid values: ['deny', 'refuse', 'static', 'transparent', 'typetransparent', 'redirect', 'inform', 'inform_deny', 'nodefault']
    tlsport: The port on which the DNS Resolver service listens for SSL/TLS connections. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `enablessl` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/dns_resolver/settings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_dns_resolver_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if active_interface is not None:
        body["active_interface"] = active_interface
    if custom_options is not None:
        body["custom_options"] = custom_options
    if dnssec is not None:
        body["dnssec"] = dnssec
    if enable is not None:
        body["enable"] = enable
    if enablessl is not None:
        body["enablessl"] = enablessl
    if forwarding is not None:
        body["forwarding"] = forwarding
    if outgoing_interface is not None:
        body["outgoing_interface"] = outgoing_interface
    if port is not None:
        body["port"] = port
    if python is not None:
        body["python"] = python
    if python_order is not None:
        body["python_order"] = python_order
    if python_script is not None:
        body["python_script"] = python_script
    if regdhcp is not None:
        body["regdhcp"] = regdhcp
    if regdhcpstatic is not None:
        body["regdhcpstatic"] = regdhcpstatic
    if regovpnclients is not None:
        body["regovpnclients"] = regovpnclients
    if sslcertref is not None:
        body["sslcertref"] = sslcertref
    if strictout is not None:
        body["strictout"] = strictout
    if system_domain_local_zone_type is not None:
        body["system_domain_local_zone_type"] = system_domain_local_zone_type
    if tlsport is not None:
        body["tlsport"] = tlsport
    return await _client.request(
        "PATCH",
        "/api/v2/services/dns_resolver/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_free_radius_client(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/client

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/client",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_free_radius_client(
    addr: str,
    secret: str,
    shortname: str,
    confirm: bool = False,
    description: str | None = None,
    ip_version: str | None = 'ipaddr',
    maxconn: int | None = 16,
    msgauth: bool | None = None,
    naslogin: str | None = None,
    naspassword: str | None = None,
    nastype: str | None = 'other',
    proto: str | None = 'udp',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/freeradius/client

    addr: The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)
    secret: This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.
    shortname: A short name for the client. This is generally the hostname of the NAS.
    description: The description for this interface.
    ip_version: The IP version of the this Client. Valid values: ['ipaddr', 'ipv6addr']
    maxconn: Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP connections from a client.
    msgauth: RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.
    naslogin: If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.
    naspassword: If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.
    nastype: The NAS type of the client. This is used by checkrad.pl for simultaneous use checks. Valid values: ['cisco', 'cvx', 'computone', 'digitro', 'livingston', 'juniper', 'max40xx', 'mikrotik', 'mikrotik_snmp', 'dot1x', 'other']
    proto: The protocol the client uses. Valid values: ['udp', 'tcp']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/freeradius/client. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if addr is not None:
        body["addr"] = addr
    if secret is not None:
        body["secret"] = secret
    if shortname is not None:
        body["shortname"] = shortname
    if description is not None:
        body["description"] = description
    if ip_version is not None:
        body["ip_version"] = ip_version
    if maxconn is not None:
        body["maxconn"] = maxconn
    if msgauth is not None:
        body["msgauth"] = msgauth
    if naslogin is not None:
        body["naslogin"] = naslogin
    if naspassword is not None:
        body["naspassword"] = naspassword
    if nastype is not None:
        body["nastype"] = nastype
    if proto is not None:
        body["proto"] = proto
    return await _client.request(
        "POST",
        "/api/v2/services/freeradius/client",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_free_radius_client(
    id: str | int,
    confirm: bool = False,
    addr: str | None = None,
    description: str | None = None,
    ip_version: str | None = None,
    maxconn: int | None = None,
    msgauth: bool | None = None,
    naslogin: str | None = None,
    naspassword: str | None = None,
    nastype: str | None = None,
    proto: str | None = None,
    secret: str | None = None,
    shortname: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/freeradius/client

    id: The ID of the object or resource to interact with.
    addr: The IP address or network of the RADIUS client(s) in CIDR notation. This is the IP of the NAS (switch, access point, firewall, router, etc.)
    description: The description for this interface.
    ip_version: The IP version of the this Client. Valid values: ['ipaddr', 'ipv6addr']
    maxconn: Takes only effect if you use TCP as protocol. Limits the number of simultaneous TCP connections from a client.
    msgauth: RFC5080 requires Message-Authenticator in Access-Request. But older NAS (switches or accesspoints) do not include that.
    naslogin: If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.
    naspassword: If supported by your NAS, you can use SNMP or finger for simultaneous-use checks instead of (s)radutmp file and accounting. Leave empty to choose (s)radutmp.
    nastype: The NAS type of the client. This is used by checkrad.pl for simultaneous use checks. Valid values: ['cisco', 'cvx', 'computone', 'digitro', 'livingston', 'juniper', 'max40xx', 'mikrotik', 'mikrotik_snmp', 'dot1x', 'other']
    proto: The protocol the client uses. Valid values: ['udp', 'tcp']
    secret: This is the shared secret (password) which the NAS (switch, accesspoint, etc.) needs to communicate with the RADIUS server.
    shortname: A short name for the client. This is generally the hostname of the NAS.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/freeradius/client. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if addr is not None:
        body["addr"] = addr
    if description is not None:
        body["description"] = description
    if ip_version is not None:
        body["ip_version"] = ip_version
    if maxconn is not None:
        body["maxconn"] = maxconn
    if msgauth is not None:
        body["msgauth"] = msgauth
    if naslogin is not None:
        body["naslogin"] = naslogin
    if naspassword is not None:
        body["naspassword"] = naspassword
    if nastype is not None:
        body["nastype"] = nastype
    if proto is not None:
        body["proto"] = proto
    if secret is not None:
        body["secret"] = secret
    if shortname is not None:
        body["shortname"] = shortname
    return await _client.request(
        "PATCH",
        "/api/v2/services/freeradius/client",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_client(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/client

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/client. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/client",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_free_radius_clients(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/clients

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/clients",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_free_radius_clients(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/freeradius/clients

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/freeradius/clients. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/freeradius/clients",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_clients(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/clients

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/clients. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/clients",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_free_radius_interface(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/interface

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/interface",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_free_radius_interface(
    addr: str,
    ip_version: str,
    confirm: bool = False,
    description: str | None = None,
    port: str | None = '1812',
    type_: str | None = 'auth',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/freeradius/interface

    addr: The IP address of the listening interface. If you choose * then it means all interfaces.
    ip_version: The IP version of the listening interface. Valid values: ['ipaddr', 'ipv6addr']
    description: The description for this interface.
    port: The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number
    type_: The type of the listening interface: Authentication/Accounting. Valid values: ['auth', 'acct', 'proxy', 'detail', 'status', 'coa']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/freeradius/interface. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if addr is not None:
        body["addr"] = addr
    if ip_version is not None:
        body["ip_version"] = ip_version
    if description is not None:
        body["description"] = description
    if port is not None:
        body["port"] = port
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/services/freeradius/interface",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_free_radius_interface(
    id: str | int,
    confirm: bool = False,
    addr: str | None = None,
    description: str | None = None,
    ip_version: str | None = None,
    port: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/freeradius/interface

    id: The ID of the object or resource to interact with.
    addr: The IP address of the listening interface. If you choose * then it means all interfaces.
    description: The description for this interface.
    ip_version: The IP version of the listening interface. Valid values: ['ipaddr', 'ipv6addr']
    port: The port number of the listening interface. Different interface types need different ports. Valid options are: a TCP/UDP port number
    type_: The type of the listening interface: Authentication/Accounting. Valid values: ['auth', 'acct', 'proxy', 'detail', 'status', 'coa']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/freeradius/interface. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if addr is not None:
        body["addr"] = addr
    if description is not None:
        body["description"] = description
    if ip_version is not None:
        body["ip_version"] = ip_version
    if port is not None:
        body["port"] = port
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/services/freeradius/interface",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_interface(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/interface

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/interface. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/interface",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_free_radius_interfaces(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/interfaces

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_free_radius_interfaces(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/freeradius/interfaces

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/freeradius/interfaces. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/freeradius/interfaces",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_interfaces(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/interfaces

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/interfaces. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_free_radius_user(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/user

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/user",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_free_radius_user(
    username: str,
    confirm: bool = False,
    description: str | None = None,
    framed_ip_address: str | None = None,
    framed_ip_netmask: str | None = None,
    motp_authmethod: str | None = None,
    motp_enable: bool | None = None,
    motp_offset: int | None = None,
    motp_pin: str | None = None,
    motp_secret: str | None = None,
    password: str | None = None,
    password_encryption: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/freeradius/user

    username: The username for this user.
    description: A description for this user.
    framed_ip_address: Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.
    framed_ip_netmask: Framed-IP-Netmask MUST be supported by NAS
    motp_authmethod: The authentication method for the Mobile One-Time Password (MOTP).This field is only available when the following conditions are met:- `motp_enable` must be equal to `true` Valid values: ['motp', 'googleauth']
    motp_enable: Enable or disable the use of Mobile One-Time Password (MOTP) for this user.
    motp_offset: The timezone offset for this user.This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    motp_pin: The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    motp_secret: The secret for the Mobile One-Time Password (MOTP).This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    password: The password for this username.This field is only available when the following conditions are met:- `motp_enable` must be equal to `false`
    password_encryption: The encryption method for the password.This field is only available when the following conditions are met:- `motp_enable` must be equal to `false` Valid values: ['Cleartext-Password', 'MD5-Password', 'MD5-Password-hashed', 'NT-Password-hashed']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/freeradius/user. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if username is not None:
        body["username"] = username
    if description is not None:
        body["description"] = description
    if framed_ip_address is not None:
        body["framed_ip_address"] = framed_ip_address
    if framed_ip_netmask is not None:
        body["framed_ip_netmask"] = framed_ip_netmask
    if motp_authmethod is not None:
        body["motp_authmethod"] = motp_authmethod
    if motp_enable is not None:
        body["motp_enable"] = motp_enable
    if motp_offset is not None:
        body["motp_offset"] = motp_offset
    if motp_pin is not None:
        body["motp_pin"] = motp_pin
    if motp_secret is not None:
        body["motp_secret"] = motp_secret
    if password is not None:
        body["password"] = password
    if password_encryption is not None:
        body["password_encryption"] = password_encryption
    return await _client.request(
        "POST",
        "/api/v2/services/freeradius/user",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_free_radius_user(
    id: str | int,
    confirm: bool = False,
    description: str | None = None,
    framed_ip_address: str | None = None,
    framed_ip_netmask: str | None = None,
    motp_authmethod: str | None = None,
    motp_enable: bool | None = None,
    motp_offset: int | None = None,
    motp_pin: str | None = None,
    motp_secret: str | None = None,
    password: str | None = None,
    password_encryption: str | None = None,
    username: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/freeradius/user

    id: The ID of the object or resource to interact with.
    description: A description for this user.
    framed_ip_address: Framed-IP-Address MUST be supported by NAS. If the OpenVPN server uses a subnet style Topology the RADIUS server MUST also send back an appropriate Framed-IP-Netmask value matching the VPN Tunnel Network.
    framed_ip_netmask: Framed-IP-Netmask MUST be supported by NAS
    motp_authmethod: The authentication method for the Mobile One-Time Password (MOTP).This field is only available when the following conditions are met:- `motp_enable` must be equal to `true` Valid values: ['motp', 'googleauth']
    motp_enable: Enable or disable the use of Mobile One-Time Password (MOTP) for this user.
    motp_offset: The timezone offset for this user.This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    motp_pin: The PIN for the Mobile One-Time Password (MOTP). It must be exactly 4 digits.This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    motp_secret: The secret for the Mobile One-Time Password (MOTP).This field is only available when the following conditions are met:- `motp_enable` must be equal to `true`
    password: The password for this username.This field is only available when the following conditions are met:- `motp_enable` must be equal to `false`
    password_encryption: The encryption method for the password.This field is only available when the following conditions are met:- `motp_enable` must be equal to `false` Valid values: ['Cleartext-Password', 'MD5-Password', 'MD5-Password-hashed', 'NT-Password-hashed']
    username: The username for this user.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/freeradius/user. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if description is not None:
        body["description"] = description
    if framed_ip_address is not None:
        body["framed_ip_address"] = framed_ip_address
    if framed_ip_netmask is not None:
        body["framed_ip_netmask"] = framed_ip_netmask
    if motp_authmethod is not None:
        body["motp_authmethod"] = motp_authmethod
    if motp_enable is not None:
        body["motp_enable"] = motp_enable
    if motp_offset is not None:
        body["motp_offset"] = motp_offset
    if motp_pin is not None:
        body["motp_pin"] = motp_pin
    if motp_secret is not None:
        body["motp_secret"] = motp_secret
    if password is not None:
        body["password"] = password
    if password_encryption is not None:
        body["password_encryption"] = password_encryption
    if username is not None:
        body["username"] = username
    return await _client.request(
        "PATCH",
        "/api/v2/services/freeradius/user",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_user(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/user

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/user. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/user",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_free_radius_users(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/freeradius/users

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/freeradius/users",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_free_radius_users(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/freeradius/users

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/freeradius/users. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/freeradius/users",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_free_radius_users(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/freeradius/users

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/freeradius/users. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/freeradius/users",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/apply",
    )


@mcp.tool()
async def pfsense_services_ha_proxy_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/apply",
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_backend_acl(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/acl

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/acl",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_backend_acl(
    expression: str,
    name: str,
    parent_id: str | int,
    value: str,
    confirm: bool = False,
    casesensitive: bool | None = None,
    not_: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/backend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    expression: The expression to use to determine the match for this ACL. Valid values: ['host_starts_with', 'host_ends_with', 'host_matches', 'host_regex', 'host_contains', 'path_starts_with', 'path_ends_with', 'path_matches', 'path_regex', 'path_contains', 'path_dir', 'url_parameter', 'ssl_c_verify_code', 'ssl_c_verify', 'ssl_c_ca_commonname', 'source_ip', 'backendservercount', 'traffic_is_http', 'traffic_is_ssl', 'ssl_sni_matches', 'ssl_sni_contains', 'ssl_sni_starts_with', 'ssl_sni_ends_with', 'ssl_sni_regex', 'custom']
    name: The unique name for this backend ACL.
    parent_id: The ID of the parent this object is nested under.
    value: The value which indicates a match for this ACL.
    casesensitive: Enables or disables case-sensitive matching for this ACL.
    not_: Enables or disables inverting the context of this ACL.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/backend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if expression is not None:
        body["expression"] = expression
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if value is not None:
        body["value"] = value
    if casesensitive is not None:
        body["casesensitive"] = casesensitive
    if not_ is not None:
        body["not"] = not_
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/backend/acl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_backend_acl(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    casesensitive: bool | None = None,
    expression: str | None = None,
    name: str | None = None,
    not_: bool | None = None,
    value: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/backend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    casesensitive: Enables or disables case-sensitive matching for this ACL.
    expression: The expression to use to determine the match for this ACL. Valid values: ['host_starts_with', 'host_ends_with', 'host_matches', 'host_regex', 'host_contains', 'path_starts_with', 'path_ends_with', 'path_matches', 'path_regex', 'path_contains', 'path_dir', 'url_parameter', 'ssl_c_verify_code', 'ssl_c_verify', 'ssl_c_ca_commonname', 'source_ip', 'backendservercount', 'traffic_is_http', 'traffic_is_ssl', 'ssl_sni_matches', 'ssl_sni_contains', 'ssl_sni_starts_with', 'ssl_sni_ends_with', 'ssl_sni_regex', 'custom']
    name: The unique name for this backend ACL.
    not_: Enables or disables inverting the context of this ACL.
    value: The value which indicates a match for this ACL.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/backend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if casesensitive is not None:
        body["casesensitive"] = casesensitive
    if expression is not None:
        body["expression"] = expression
    if name is not None:
        body["name"] = name
    if not_ is not None:
        body["not"] = not_
    if value is not None:
        body["value"] = value
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/backend/acl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_acl(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/acl",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_backend_ac_ls(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/acls

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/acls",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_ac_ls(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/acls

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/acls. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/acls",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_backend_action(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/action

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/action",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_backend_action(
    acl: str,
    action: str,
    parent_id: str | int,
    confirm: bool = False,
    customaction: str | None = None,
    deny_status: str | None = None,
    find: str | None = None,
    fmt: str | None = None,
    lua_function: str | None = None,
    name: str | None = None,
    path: str | None = None,
    realm: str | None = None,
    reason: str | None = None,
    replace: str | None = None,
    rule: str | None = None,
    server: str | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/backend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    acl: The name of the backend ACL this action is associated with.
    action: The action to take when an ACL match is found. Valid values: ['use_server', 'custom', 'http-request_allow', 'http-request_deny', 'http-request_tarpit', 'http-request_auth', 'http-request_redirect', 'http-request_lua', 'http-request_use-service', 'http-request_add-header', 'http-request_set-header', 'http-request_del-header', 'http-request_replace-header', 'http-request_replace-path', 'http-request_replace-value', 'http-request_set-method', 'http-request_set-path', 'http-request_set-query', 'http-request_set-uri', 'http-response_allow', 'http-response_deny', 'http-response_lua', 'http-response_add-header', 'http-response_set-header', 'http-response_del-header', 'http-response_replace-header', 'http-response_replace-value', 'http-response_set-status', 'http-after-response_add-header', 'http-after-response_set-header', 'http-after-response_del-header', 'http-after-response_replace-header', 'http-after-response_replace-value', 'http-after-response_set-status', 'tcp-request_connection_accept', 'tcp-request_connection_reject', 'tcp-request_content_accept', 'tcp-request_content_reject', 'tcp-request_content_lua', 'tcp-request_content_use-service', 'tcp-response_content_accept', 'tcp-response_content_close', 'tcp-response_content_reject', 'tcp-response_content_lua']
    parent_id: The ID of the parent this object is nested under.
    customaction: The custom action to take when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'custom'`
    deny_status: The deny status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_deny, http-request_tarpit ]
    find: The value to find when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    fmt: The fmt value to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]
    lua_function: The Lua function to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]
    name: The name to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]
    path: The path to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_replace-path'`
    realm: The authentication realm to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_auth'`
    reason: The status reason to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    replace: The value to replace with when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    rule: The redirect rule to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_redirect'`
    server: The backend server to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'use_server'`
    status: The status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/backend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if acl is not None:
        body["acl"] = acl
    if action is not None:
        body["action"] = action
    if parent_id is not None:
        body["parent_id"] = parent_id
    if customaction is not None:
        body["customaction"] = customaction
    if deny_status is not None:
        body["deny_status"] = deny_status
    if find is not None:
        body["find"] = find
    if fmt is not None:
        body["fmt"] = fmt
    if lua_function is not None:
        body["lua_function"] = lua_function
    if name is not None:
        body["name"] = name
    if path is not None:
        body["path"] = path
    if realm is not None:
        body["realm"] = realm
    if reason is not None:
        body["reason"] = reason
    if replace is not None:
        body["replace"] = replace
    if rule is not None:
        body["rule"] = rule
    if server is not None:
        body["server"] = server
    if status is not None:
        body["status"] = status
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/backend/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_backend_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    acl: str | None = None,
    action: str | None = None,
    customaction: str | None = None,
    deny_status: str | None = None,
    find: str | None = None,
    fmt: str | None = None,
    lua_function: str | None = None,
    name: str | None = None,
    path: str | None = None,
    realm: str | None = None,
    reason: str | None = None,
    replace: str | None = None,
    rule: str | None = None,
    server: str | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/backend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    acl: The name of the backend ACL this action is associated with.
    action: The action to take when an ACL match is found. Valid values: ['use_server', 'custom', 'http-request_allow', 'http-request_deny', 'http-request_tarpit', 'http-request_auth', 'http-request_redirect', 'http-request_lua', 'http-request_use-service', 'http-request_add-header', 'http-request_set-header', 'http-request_del-header', 'http-request_replace-header', 'http-request_replace-path', 'http-request_replace-value', 'http-request_set-method', 'http-request_set-path', 'http-request_set-query', 'http-request_set-uri', 'http-response_allow', 'http-response_deny', 'http-response_lua', 'http-response_add-header', 'http-response_set-header', 'http-response_del-header', 'http-response_replace-header', 'http-response_replace-value', 'http-response_set-status', 'http-after-response_add-header', 'http-after-response_set-header', 'http-after-response_del-header', 'http-after-response_replace-header', 'http-after-response_replace-value', 'http-after-response_set-status', 'tcp-request_connection_accept', 'tcp-request_connection_reject', 'tcp-request_content_accept', 'tcp-request_content_reject', 'tcp-request_content_lua', 'tcp-request_content_use-service', 'tcp-response_content_accept', 'tcp-response_content_close', 'tcp-response_content_reject', 'tcp-response_content_lua']
    customaction: The custom action to take when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'custom'`
    deny_status: The deny status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_deny, http-request_tarpit ]
    find: The value to find when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    fmt: The fmt value to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]
    lua_function: The Lua function to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]
    name: The name to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]
    path: The path to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_replace-path'`
    realm: The authentication realm to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_auth'`
    reason: The status reason to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    replace: The value to replace with when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    rule: The redirect rule to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_redirect'`
    server: The backend server to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'use_server'`
    status: The status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/backend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if acl is not None:
        body["acl"] = acl
    if action is not None:
        body["action"] = action
    if customaction is not None:
        body["customaction"] = customaction
    if deny_status is not None:
        body["deny_status"] = deny_status
    if find is not None:
        body["find"] = find
    if fmt is not None:
        body["fmt"] = fmt
    if lua_function is not None:
        body["lua_function"] = lua_function
    if name is not None:
        body["name"] = name
    if path is not None:
        body["path"] = path
    if realm is not None:
        body["realm"] = realm
    if reason is not None:
        body["reason"] = reason
    if replace is not None:
        body["replace"] = replace
    if rule is not None:
        body["rule"] = rule
    if server is not None:
        body["server"] = server
    if status is not None:
        body["status"] = status
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/backend/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/action",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_backend_actions(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/actions

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/actions",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_actions(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/actions

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/actions. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/actions",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_backend(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_backend(
    name: str,
    confirm: bool = False,
    acls: list[dict[str, Any]] | None = None,
    actions: list[dict[str, Any]] | None = None,
    advanced: str | None = None,
    advanced_backend: str | None = None,
    agent_checks: bool | None = None,
    agent_inter: int | None = None,
    agent_port: str | None = None,
    balance: str | None = None,
    balance_uridepth: int | None = None,
    balance_urilen: int | None = None,
    balance_uriwhole: bool | None = None,
    check_type: str | None = 'none',
    checkinter: int | None = None,
    connection_timeout: int | None = 30000,
    cookie_attribute_secure: bool | None = None,
    email_level: str | None = None,
    email_to: str | None = None,
    errorfiles: list[dict[str, Any]] | None = None,
    haproxy_cookie_domains: list[str] | None = None,
    haproxy_cookie_dynamic_cookie_key: str | None = None,
    haproxy_cookie_maxidle: int | None = None,
    haproxy_cookie_maxlife: int | None = None,
    httpcheck_method: str | None = None,
    log_health_checks: bool | None = None,
    monitor_domain: str | None = None,
    monitor_httpversion: str | None = None,
    monitor_uri: str | None = None,
    monitor_username: str | None = None,
    persist_cookie_cachable: bool | None = None,
    persist_cookie_enabled: bool | None = None,
    persist_cookie_httponly: bool | None = None,
    persist_cookie_mode: str | None = None,
    persist_cookie_name: str | None = None,
    persist_cookie_postonly: bool | None = None,
    persist_cookie_secure: bool | None = None,
    persist_stick_cookiename: str | None = None,
    persist_stick_expire: str | None = None,
    persist_stick_length: int | None = None,
    persist_stick_tablesize: str | None = None,
    persist_sticky_type: str | None = 'none',
    retries: int | None = None,
    server_timeout: int | None = 30000,
    servers: list[dict[str, Any]] | None = None,
    stats_admin: str | None = None,
    stats_desc: str | None = None,
    stats_enabled: bool | None = None,
    stats_node: str | None = None,
    stats_password: str | None = None,
    stats_realm: str | None = None,
    stats_refresh: int | None = None,
    stats_scope: list[str] | None = None,
    stats_uri: str | None = None,
    stats_username: str | None = None,
    strict_transport_security: int | None = None,
    transparent_clientip: bool | None = None,
    transparent_interface: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/backend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    name: The unique name for this backend.
    acls: The ACLs to apply to this backend.
    actions: The actions to apply to this backend.
    advanced: The per server pass thru to apply to each server line.
    advanced_backend: The backend pass thru to apply to the backend section.
    agent_checks: Enables or disables using a TCP connection to read an ASCII string of the form.
    agent_inter: The interval (in milliseconds) between agent checks.This field is only available when the following conditions are met:- `agent_checks` must be equal to `true`
    agent_port: Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `agent_checks` must be equal to `true`
    balance: The load balancing option to use for servers assigned to this backend. Valid values: ['', 'roundrobin', 'static-rr', 'leastconn', 'source', 'uri']
    balance_uridepth: The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    balance_urilen: The number of URI characters the algorithm should consider when hashing.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    balance_uriwhole: Enables or disables allowing the use of whole URIs, including URL parameters.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    check_type: The health check method to use when checking the health of backend servers. Valid values: ['none', 'Basic', 'HTTP', 'LDAP', 'MySQL', 'PostgreSQL', 'Redis', 'SMTP', 'ESMTP', 'SSL']
    checkinter: The interval (in milliseconds) in which health checks will be performed.This field is only available when the following conditions are met:- `check_type` must not be equal to `'none'`
    connection_timeout: The amount of time (in milliseconds) to wait before giving up on connections.
    cookie_attribute_secure: Enables or disables assigning the secure attributes on cookies for this backend.
    email_level: The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used. Valid values: ['', 'dontlog', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']
    email_to: The email address to send emails to. If left empty, the value set in the global settings will be used.
    errorfiles: The HAProxy error file mappings to use for this backend.
    haproxy_cookie_domains: The domains to set the cookies for.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_dynamic_cookie_key: The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_maxidle: The max-idle time to allow. This option only applies to insert mode cookies.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_maxlife: The max-life time to allow. This option only applies to insert mode cookies.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    httpcheck_method: The HTTP method to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'` Valid values: ['OPTIONS', 'HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'TRACE']
    log_health_checks: Enables or disables logging changes to the health check statusThis field is only available when the following conditions are met:- `check_type` must not be equal to `'none'`
    monitor_domain: The domain to use for SMTP or ESMTP health checks.This field is only available when the following conditions are met:- `check_type` must be one of [ SMTP, ESMTP ]
    monitor_httpversion: The HTTP version to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'`
    monitor_uri: The URL to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'`
    monitor_username: The username to use for MySQL or PostgreSQL health checks.This field is only available when the following conditions are met:- `check_type` must be one of [ MySQL, PostgreSQL ]
    persist_cookie_cachable: Enables or disables allowing shared caches to cache the server response.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_enabled: Enables or disables cookie based persistence.
    persist_cookie_httponly: Enables or disables preventing the use of cookies with non-HTTP components.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_mode: The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true` Valid values: ['passive', 'passive-silent', 'reset', 'set', 'set-silent', 'insert-only', 'insert-only-silent', 'session-prefix', 'passive-session-prefix']
    persist_cookie_name: The string name to track in Set-Cookie and Cookie HTTP headers.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_postonly: Enables or disables only inserting cookies on POST requests.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_secure: Enables or disables prevention of cookie usage over non-secure channels.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_stick_cookiename: The cookie name to use for stick table.This field is only available when the following conditions are met:- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]
    persist_stick_expire: The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.This field is only available when the following conditions are met:- `persist_sticky_type` must not be equal to `'none'`
    persist_stick_length: The maximum number of characters allowed in a string type stick tableThis field is only available when the following conditions are met:- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]
    persist_stick_tablesize: The maximum number of entries allowed in the table. This value directly impacts memory usage.This field is only available when the following conditions are met:- `persist_sticky_type` must not be equal to `'none'`
    persist_sticky_type: The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend. Valid values: ['none', 'stick_sslsessionid', 'stick_sourceipv4', 'stick_sourceipv6', 'stick_cookie_value', 'stick_rdp_cookie']
    retries: The number of retry attempts to allow after a connection failure to the server.
    server_timeout: The amount of time (in milliseconds) to wait for data transferred to or from the server.
    servers: The pool of servers this backend will use.
    stats_admin: The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_desc: The verbose description for this node.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_enabled: Enables or disables the HAProxy statistics page for this backend.
    stats_node: The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_password: The stats page password.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_realm: The realm that is shown when authentication is requested by HAProxy.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_refresh: The interval (in seconds) in which the stats page is refreshed.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_scope: The frontends and backends stats to be shown, leave empty to show all.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_uri: The statistics URL for this backend.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_username: The stats page usernameThis field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    strict_transport_security: The HSTS validity period for this backend. Leave empty to disable HSTS.
    transparent_clientip: Enables or disables using the client-IP to connect to backend servers.
    transparent_interface: The interface that will connect to the backend server.This field is only available when the following conditions are met:- `transparent_clientip` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/backend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if acls is not None:
        body["acls"] = acls
    if actions is not None:
        body["actions"] = actions
    if advanced is not None:
        body["advanced"] = advanced
    if advanced_backend is not None:
        body["advanced_backend"] = advanced_backend
    if agent_checks is not None:
        body["agent_checks"] = agent_checks
    if agent_inter is not None:
        body["agent_inter"] = agent_inter
    if agent_port is not None:
        body["agent_port"] = agent_port
    if balance is not None:
        body["balance"] = balance
    if balance_uridepth is not None:
        body["balance_uridepth"] = balance_uridepth
    if balance_urilen is not None:
        body["balance_urilen"] = balance_urilen
    if balance_uriwhole is not None:
        body["balance_uriwhole"] = balance_uriwhole
    if check_type is not None:
        body["check_type"] = check_type
    if checkinter is not None:
        body["checkinter"] = checkinter
    if connection_timeout is not None:
        body["connection_timeout"] = connection_timeout
    if cookie_attribute_secure is not None:
        body["cookie_attribute_secure"] = cookie_attribute_secure
    if email_level is not None:
        body["email_level"] = email_level
    if email_to is not None:
        body["email_to"] = email_to
    if errorfiles is not None:
        body["errorfiles"] = errorfiles
    if haproxy_cookie_domains is not None:
        body["haproxy_cookie_domains"] = haproxy_cookie_domains
    if haproxy_cookie_dynamic_cookie_key is not None:
        body["haproxy_cookie_dynamic_cookie_key"] = haproxy_cookie_dynamic_cookie_key
    if haproxy_cookie_maxidle is not None:
        body["haproxy_cookie_maxidle"] = haproxy_cookie_maxidle
    if haproxy_cookie_maxlife is not None:
        body["haproxy_cookie_maxlife"] = haproxy_cookie_maxlife
    if httpcheck_method is not None:
        body["httpcheck_method"] = httpcheck_method
    if log_health_checks is not None:
        body["log_health_checks"] = log_health_checks
    if monitor_domain is not None:
        body["monitor_domain"] = monitor_domain
    if monitor_httpversion is not None:
        body["monitor_httpversion"] = monitor_httpversion
    if monitor_uri is not None:
        body["monitor_uri"] = monitor_uri
    if monitor_username is not None:
        body["monitor_username"] = monitor_username
    if persist_cookie_cachable is not None:
        body["persist_cookie_cachable"] = persist_cookie_cachable
    if persist_cookie_enabled is not None:
        body["persist_cookie_enabled"] = persist_cookie_enabled
    if persist_cookie_httponly is not None:
        body["persist_cookie_httponly"] = persist_cookie_httponly
    if persist_cookie_mode is not None:
        body["persist_cookie_mode"] = persist_cookie_mode
    if persist_cookie_name is not None:
        body["persist_cookie_name"] = persist_cookie_name
    if persist_cookie_postonly is not None:
        body["persist_cookie_postonly"] = persist_cookie_postonly
    if persist_cookie_secure is not None:
        body["persist_cookie_secure"] = persist_cookie_secure
    if persist_stick_cookiename is not None:
        body["persist_stick_cookiename"] = persist_stick_cookiename
    if persist_stick_expire is not None:
        body["persist_stick_expire"] = persist_stick_expire
    if persist_stick_length is not None:
        body["persist_stick_length"] = persist_stick_length
    if persist_stick_tablesize is not None:
        body["persist_stick_tablesize"] = persist_stick_tablesize
    if persist_sticky_type is not None:
        body["persist_sticky_type"] = persist_sticky_type
    if retries is not None:
        body["retries"] = retries
    if server_timeout is not None:
        body["server_timeout"] = server_timeout
    if servers is not None:
        body["servers"] = servers
    if stats_admin is not None:
        body["stats_admin"] = stats_admin
    if stats_desc is not None:
        body["stats_desc"] = stats_desc
    if stats_enabled is not None:
        body["stats_enabled"] = stats_enabled
    if stats_node is not None:
        body["stats_node"] = stats_node
    if stats_password is not None:
        body["stats_password"] = stats_password
    if stats_realm is not None:
        body["stats_realm"] = stats_realm
    if stats_refresh is not None:
        body["stats_refresh"] = stats_refresh
    if stats_scope is not None:
        body["stats_scope"] = stats_scope
    if stats_uri is not None:
        body["stats_uri"] = stats_uri
    if stats_username is not None:
        body["stats_username"] = stats_username
    if strict_transport_security is not None:
        body["strict_transport_security"] = strict_transport_security
    if transparent_clientip is not None:
        body["transparent_clientip"] = transparent_clientip
    if transparent_interface is not None:
        body["transparent_interface"] = transparent_interface
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/backend",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_backend(
    id: str | int,
    confirm: bool = False,
    acls: list[dict[str, Any]] | None = None,
    actions: list[dict[str, Any]] | None = None,
    advanced: str | None = None,
    advanced_backend: str | None = None,
    agent_checks: bool | None = None,
    agent_inter: int | None = None,
    agent_port: str | None = None,
    balance: str | None = None,
    balance_uridepth: int | None = None,
    balance_urilen: int | None = None,
    balance_uriwhole: bool | None = None,
    check_type: str | None = None,
    checkinter: int | None = None,
    connection_timeout: int | None = None,
    cookie_attribute_secure: bool | None = None,
    email_level: str | None = None,
    email_to: str | None = None,
    errorfiles: list[dict[str, Any]] | None = None,
    haproxy_cookie_domains: list[str] | None = None,
    haproxy_cookie_dynamic_cookie_key: str | None = None,
    haproxy_cookie_maxidle: int | None = None,
    haproxy_cookie_maxlife: int | None = None,
    httpcheck_method: str | None = None,
    log_health_checks: bool | None = None,
    monitor_domain: str | None = None,
    monitor_httpversion: str | None = None,
    monitor_uri: str | None = None,
    monitor_username: str | None = None,
    name: str | None = None,
    persist_cookie_cachable: bool | None = None,
    persist_cookie_enabled: bool | None = None,
    persist_cookie_httponly: bool | None = None,
    persist_cookie_mode: str | None = None,
    persist_cookie_name: str | None = None,
    persist_cookie_postonly: bool | None = None,
    persist_cookie_secure: bool | None = None,
    persist_stick_cookiename: str | None = None,
    persist_stick_expire: str | None = None,
    persist_stick_length: int | None = None,
    persist_stick_tablesize: str | None = None,
    persist_sticky_type: str | None = None,
    retries: int | None = None,
    server_timeout: int | None = None,
    servers: list[dict[str, Any]] | None = None,
    stats_admin: str | None = None,
    stats_desc: str | None = None,
    stats_enabled: bool | None = None,
    stats_node: str | None = None,
    stats_password: str | None = None,
    stats_realm: str | None = None,
    stats_refresh: int | None = None,
    stats_scope: list[str] | None = None,
    stats_uri: str | None = None,
    stats_username: str | None = None,
    strict_transport_security: int | None = None,
    transparent_clientip: bool | None = None,
    transparent_interface: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/backend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    acls: The ACLs to apply to this backend.
    actions: The actions to apply to this backend.
    advanced: The per server pass thru to apply to each server line.
    advanced_backend: The backend pass thru to apply to the backend section.
    agent_checks: Enables or disables using a TCP connection to read an ASCII string of the form.
    agent_inter: The interval (in milliseconds) between agent checks.This field is only available when the following conditions are met:- `agent_checks` must be equal to `true`
    agent_port: Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `agent_checks` must be equal to `true`
    balance: The load balancing option to use for servers assigned to this backend. Valid values: ['', 'roundrobin', 'static-rr', 'leastconn', 'source', 'uri']
    balance_uridepth: The maximum directory depth to be used to compute the hash. One level is counted for each slash in the request.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    balance_urilen: The number of URI characters the algorithm should consider when hashing.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    balance_uriwhole: Enables or disables allowing the use of whole URIs, including URL parameters.This field is only available when the following conditions are met:- `balance` must be equal to `'uri'`
    check_type: The health check method to use when checking the health of backend servers. Valid values: ['none', 'Basic', 'HTTP', 'LDAP', 'MySQL', 'PostgreSQL', 'Redis', 'SMTP', 'ESMTP', 'SSL']
    checkinter: The interval (in milliseconds) in which health checks will be performed.This field is only available when the following conditions are met:- `check_type` must not be equal to `'none'`
    connection_timeout: The amount of time (in milliseconds) to wait before giving up on connections.
    cookie_attribute_secure: Enables or disables assigning the secure attributes on cookies for this backend.
    email_level: The maximum log level to send emails for. Leave empty to disable sending email alerts. If left empty, the value set in the global settings will be used. Valid values: ['', 'dontlog', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']
    email_to: The email address to send emails to. If left empty, the value set in the global settings will be used.
    errorfiles: The HAProxy error file mappings to use for this backend.
    haproxy_cookie_domains: The domains to set the cookies for.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_dynamic_cookie_key: The dynamic cookie secret key. This is will be used to generate dynamic cookies for this backend.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_maxidle: The max-idle time to allow. This option only applies to insert mode cookies.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    haproxy_cookie_maxlife: The max-life time to allow. This option only applies to insert mode cookies.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    httpcheck_method: The HTTP method to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'` Valid values: ['OPTIONS', 'HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'TRACE']
    log_health_checks: Enables or disables logging changes to the health check statusThis field is only available when the following conditions are met:- `check_type` must not be equal to `'none'`
    monitor_domain: The domain to use for SMTP or ESMTP health checks.This field is only available when the following conditions are met:- `check_type` must be one of [ SMTP, ESMTP ]
    monitor_httpversion: The HTTP version to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'`
    monitor_uri: The URL to use for HTTP health checks.This field is only available when the following conditions are met:- `check_type` must be equal to `'HTTP'`
    monitor_username: The username to use for MySQL or PostgreSQL health checks.This field is only available when the following conditions are met:- `check_type` must be one of [ MySQL, PostgreSQL ]
    name: The unique name for this backend.
    persist_cookie_cachable: Enables or disables allowing shared caches to cache the server response.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_enabled: Enables or disables cookie based persistence.
    persist_cookie_httponly: Enables or disables preventing the use of cookies with non-HTTP components.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_mode: The mode HAProxy uses to insert/prefix/replace or examine cookie and set-cookie headers.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true` Valid values: ['passive', 'passive-silent', 'reset', 'set', 'set-silent', 'insert-only', 'insert-only-silent', 'session-prefix', 'passive-session-prefix']
    persist_cookie_name: The string name to track in Set-Cookie and Cookie HTTP headers.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_postonly: Enables or disables only inserting cookies on POST requests.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_cookie_secure: Enables or disables prevention of cookie usage over non-secure channels.This field is only available when the following conditions are met:- `persist_cookie_enabled` must be equal to `true`
    persist_stick_cookiename: The cookie name to use for stick table.This field is only available when the following conditions are met:- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]
    persist_stick_expire: The maximum duration of an entry in the stick-table since it was last created, refreshed or matched.This field is only available when the following conditions are met:- `persist_sticky_type` must not be equal to `'none'`
    persist_stick_length: The maximum number of characters allowed in a string type stick tableThis field is only available when the following conditions are met:- `persist_sticky_type` must be one of [ stick_cookie_value, stick_rdp_cookie ]
    persist_stick_tablesize: The maximum number of entries allowed in the table. This value directly impacts memory usage.This field is only available when the following conditions are met:- `persist_sticky_type` must not be equal to `'none'`
    persist_sticky_type: The sticky table mode to use for this backend. These options are used to make sure subsequent requests from a single client go to the same backend. Valid values: ['none', 'stick_sslsessionid', 'stick_sourceipv4', 'stick_sourceipv6', 'stick_cookie_value', 'stick_rdp_cookie']
    retries: The number of retry attempts to allow after a connection failure to the server.
    server_timeout: The amount of time (in milliseconds) to wait for data transferred to or from the server.
    servers: The pool of servers this backend will use.
    stats_admin: The admin to make use of the options disable/enable/softstop/softstart/killsessions from the stats page.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_desc: The verbose description for this node.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_enabled: Enables or disables the HAProxy statistics page for this backend.
    stats_node: The short name displayed in stats and helps differentiate which server in the cluster is actually serving clients.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_password: The stats page password.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_realm: The realm that is shown when authentication is requested by HAProxy.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_refresh: The interval (in seconds) in which the stats page is refreshed.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_scope: The frontends and backends stats to be shown, leave empty to show all.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_uri: The statistics URL for this backend.This field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    stats_username: The stats page usernameThis field is only available when the following conditions are met:- `stats_enabled` must be equal to `true`
    strict_transport_security: The HSTS validity period for this backend. Leave empty to disable HSTS.
    transparent_clientip: Enables or disables using the client-IP to connect to backend servers.
    transparent_interface: The interface that will connect to the backend server.This field is only available when the following conditions are met:- `transparent_clientip` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/backend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if acls is not None:
        body["acls"] = acls
    if actions is not None:
        body["actions"] = actions
    if advanced is not None:
        body["advanced"] = advanced
    if advanced_backend is not None:
        body["advanced_backend"] = advanced_backend
    if agent_checks is not None:
        body["agent_checks"] = agent_checks
    if agent_inter is not None:
        body["agent_inter"] = agent_inter
    if agent_port is not None:
        body["agent_port"] = agent_port
    if balance is not None:
        body["balance"] = balance
    if balance_uridepth is not None:
        body["balance_uridepth"] = balance_uridepth
    if balance_urilen is not None:
        body["balance_urilen"] = balance_urilen
    if balance_uriwhole is not None:
        body["balance_uriwhole"] = balance_uriwhole
    if check_type is not None:
        body["check_type"] = check_type
    if checkinter is not None:
        body["checkinter"] = checkinter
    if connection_timeout is not None:
        body["connection_timeout"] = connection_timeout
    if cookie_attribute_secure is not None:
        body["cookie_attribute_secure"] = cookie_attribute_secure
    if email_level is not None:
        body["email_level"] = email_level
    if email_to is not None:
        body["email_to"] = email_to
    if errorfiles is not None:
        body["errorfiles"] = errorfiles
    if haproxy_cookie_domains is not None:
        body["haproxy_cookie_domains"] = haproxy_cookie_domains
    if haproxy_cookie_dynamic_cookie_key is not None:
        body["haproxy_cookie_dynamic_cookie_key"] = haproxy_cookie_dynamic_cookie_key
    if haproxy_cookie_maxidle is not None:
        body["haproxy_cookie_maxidle"] = haproxy_cookie_maxidle
    if haproxy_cookie_maxlife is not None:
        body["haproxy_cookie_maxlife"] = haproxy_cookie_maxlife
    if httpcheck_method is not None:
        body["httpcheck_method"] = httpcheck_method
    if log_health_checks is not None:
        body["log_health_checks"] = log_health_checks
    if monitor_domain is not None:
        body["monitor_domain"] = monitor_domain
    if monitor_httpversion is not None:
        body["monitor_httpversion"] = monitor_httpversion
    if monitor_uri is not None:
        body["monitor_uri"] = monitor_uri
    if monitor_username is not None:
        body["monitor_username"] = monitor_username
    if name is not None:
        body["name"] = name
    if persist_cookie_cachable is not None:
        body["persist_cookie_cachable"] = persist_cookie_cachable
    if persist_cookie_enabled is not None:
        body["persist_cookie_enabled"] = persist_cookie_enabled
    if persist_cookie_httponly is not None:
        body["persist_cookie_httponly"] = persist_cookie_httponly
    if persist_cookie_mode is not None:
        body["persist_cookie_mode"] = persist_cookie_mode
    if persist_cookie_name is not None:
        body["persist_cookie_name"] = persist_cookie_name
    if persist_cookie_postonly is not None:
        body["persist_cookie_postonly"] = persist_cookie_postonly
    if persist_cookie_secure is not None:
        body["persist_cookie_secure"] = persist_cookie_secure
    if persist_stick_cookiename is not None:
        body["persist_stick_cookiename"] = persist_stick_cookiename
    if persist_stick_expire is not None:
        body["persist_stick_expire"] = persist_stick_expire
    if persist_stick_length is not None:
        body["persist_stick_length"] = persist_stick_length
    if persist_stick_tablesize is not None:
        body["persist_stick_tablesize"] = persist_stick_tablesize
    if persist_sticky_type is not None:
        body["persist_sticky_type"] = persist_sticky_type
    if retries is not None:
        body["retries"] = retries
    if server_timeout is not None:
        body["server_timeout"] = server_timeout
    if servers is not None:
        body["servers"] = servers
    if stats_admin is not None:
        body["stats_admin"] = stats_admin
    if stats_desc is not None:
        body["stats_desc"] = stats_desc
    if stats_enabled is not None:
        body["stats_enabled"] = stats_enabled
    if stats_node is not None:
        body["stats_node"] = stats_node
    if stats_password is not None:
        body["stats_password"] = stats_password
    if stats_realm is not None:
        body["stats_realm"] = stats_realm
    if stats_refresh is not None:
        body["stats_refresh"] = stats_refresh
    if stats_scope is not None:
        body["stats_scope"] = stats_scope
    if stats_uri is not None:
        body["stats_uri"] = stats_uri
    if stats_username is not None:
        body["stats_username"] = stats_username
    if strict_transport_security is not None:
        body["strict_transport_security"] = strict_transport_security
    if transparent_clientip is not None:
        body["transparent_clientip"] = transparent_clientip
    if transparent_interface is not None:
        body["transparent_interface"] = transparent_interface
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/backend",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_backend_error_file(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/error_file

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/error_file",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_backend_error_file(
    errorcode: int,
    errorfile: str,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/backend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    errorcode: The HTTP status code that will trigger this error file to be used.
    errorfile: The HAProxy error file object that should be used for the assigned HTTP status code.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/backend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if errorcode is not None:
        body["errorcode"] = errorcode
    if errorfile is not None:
        body["errorfile"] = errorfile
    if parent_id is not None:
        body["parent_id"] = parent_id
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/backend/error_file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_backend_error_file(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    errorcode: int | None = None,
    errorfile: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/backend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    errorcode: The HTTP status code that will trigger this error file to be used.
    errorfile: The HAProxy error file object that should be used for the assigned HTTP status code.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/backend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if errorcode is not None:
        body["errorcode"] = errorcode
    if errorfile is not None:
        body["errorfile"] = errorfile
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/backend/error_file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_error_file(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/error_file",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_backend_error_files(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/errorfiles

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/errorfiles",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_error_files(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/errorfiles

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/errorfiles. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/errorfiles",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_backend_server(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/server

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/server",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_backend_server(
    address: str,
    name: str,
    parent_id: str | int,
    port: str,
    confirm: bool = False,
    advanced: str | None = None,
    ssl: bool | None = None,
    sslserververify: bool | None = None,
    status: str | None = 'active',
    weight: int | None = 1,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/backend/server

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    address: The hostname or IP address of this backend server. Hostname values are only resolved at service startup.
    name: The unique name for this backend server.
    parent_id: The ID of the parent this object is nested under.
    port: The port to forward to for this backend server. Valid options are: a TCP/UDP port number
    advanced: Allows adding custom HAProxy server settings to the server.
    ssl: Enables or disables using SSL/TLS when forwarding to this backend server.
    sslserververify: Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.
    status: The eligibility status for this backend server. Valid values: ['active', 'backup', 'disabled', 'inactive']
    weight: The weight of this backend server when load balancing.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/backend/server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if address is not None:
        body["address"] = address
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if port is not None:
        body["port"] = port
    if advanced is not None:
        body["advanced"] = advanced
    if ssl is not None:
        body["ssl"] = ssl
    if sslserververify is not None:
        body["sslserververify"] = sslserververify
    if status is not None:
        body["status"] = status
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/backend/server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_backend_server(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    address: str | None = None,
    advanced: str | None = None,
    name: str | None = None,
    port: str | None = None,
    ssl: bool | None = None,
    sslserververify: bool | None = None,
    status: str | None = None,
    weight: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/backend/server

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    address: The hostname or IP address of this backend server. Hostname values are only resolved at service startup.
    advanced: Allows adding custom HAProxy server settings to the server.
    name: The unique name for this backend server.
    port: The port to forward to for this backend server. Valid options are: a TCP/UDP port number
    ssl: Enables or disables using SSL/TLS when forwarding to this backend server.
    sslserververify: Enables or disables verifying the SSL/TLS certificate when forwarding to this backend server.
    status: The eligibility status for this backend server. Valid values: ['active', 'backup', 'disabled', 'inactive']
    weight: The weight of this backend server when load balancing.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/backend/server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if address is not None:
        body["address"] = address
    if advanced is not None:
        body["advanced"] = advanced
    if name is not None:
        body["name"] = name
    if port is not None:
        body["port"] = port
    if ssl is not None:
        body["ssl"] = ssl
    if sslserververify is not None:
        body["sslserververify"] = sslserververify
    if status is not None:
        body["status"] = status
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/backend/server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_server(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/server

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/server. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/server",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_backend_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backend/servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backend/servers",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backend_servers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backend/servers

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backend/servers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backend/servers",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_backends(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/backends

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/backends",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_ha_proxy_backends(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/haproxy/backends

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/haproxy/backends. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/haproxy/backends",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_backends(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/backends

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/backends. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/backends",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_file(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/file

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/file",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_file(
    content: str,
    name: str,
    confirm: bool = False,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    content: The content of this file.
    name: The unique name for this file.
    type_: The type of file. Use `null` to assume an Errorfile. Valid values: ['luascript', 'writetodisk']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if content is not None:
        body["content"] = content
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_file(
    id: str | int,
    confirm: bool = False,
    content: str | None = None,
    name: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    content: The content of this file.
    name: The unique name for this file.
    type_: The type of file. Use `null` to assume an Errorfile. Valid values: ['luascript', 'writetodisk']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if content is not None:
        body["content"] = content
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_file(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/file",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_files(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/files

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/files",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_ha_proxy_files(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/haproxy/files

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/haproxy/files. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/haproxy/files",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_files(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/files

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/files. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/files",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend_acl(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/acl

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/acl",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend_acl(
    expression: str,
    name: str,
    parent_id: str | int,
    value: str,
    confirm: bool = False,
    casesensitive: bool | None = None,
    not_: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    expression: The expression to use to determine the match for this ACL. Valid values: ['host_starts_with', 'host_ends_with', 'host_matches', 'host_regex', 'host_contains', 'path_starts_with', 'path_ends_with', 'path_matches', 'path_regex', 'path_contains', 'path_dir', 'url_parameter', 'ssl_c_verify_code', 'ssl_c_verify', 'ssl_c_ca_commonname', 'source_ip', 'backendservercount', 'traffic_is_http', 'traffic_is_ssl', 'ssl_sni_matches', 'ssl_sni_contains', 'ssl_sni_starts_with', 'ssl_sni_ends_with', 'ssl_sni_regex', 'custom']
    name: The unique name for this frontend ACL.
    parent_id: The ID of the parent this object is nested under.
    value: The value which indicates a match for this ACL.
    casesensitive: Enables or disables case-sensitive matching for this ACL.
    not_: Enables or disables inverting the context of this ACL.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if expression is not None:
        body["expression"] = expression
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if value is not None:
        body["value"] = value
    if casesensitive is not None:
        body["casesensitive"] = casesensitive
    if not_ is not None:
        body["not"] = not_
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend/acl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend_acl(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    casesensitive: bool | None = None,
    expression: str | None = None,
    name: str | None = None,
    not_: bool | None = None,
    value: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    casesensitive: Enables or disables case-sensitive matching for this ACL.
    expression: The expression to use to determine the match for this ACL. Valid values: ['host_starts_with', 'host_ends_with', 'host_matches', 'host_regex', 'host_contains', 'path_starts_with', 'path_ends_with', 'path_matches', 'path_regex', 'path_contains', 'path_dir', 'url_parameter', 'ssl_c_verify_code', 'ssl_c_verify', 'ssl_c_ca_commonname', 'source_ip', 'backendservercount', 'traffic_is_http', 'traffic_is_ssl', 'ssl_sni_matches', 'ssl_sni_contains', 'ssl_sni_starts_with', 'ssl_sni_ends_with', 'ssl_sni_regex', 'custom']
    name: The unique name for this frontend ACL.
    not_: Enables or disables inverting the context of this ACL.
    value: The value which indicates a match for this ACL.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if casesensitive is not None:
        body["casesensitive"] = casesensitive
    if expression is not None:
        body["expression"] = expression
    if name is not None:
        body["name"] = name
    if not_ is not None:
        body["not"] = not_
    if value is not None:
        body["value"] = value
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend/acl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_acl(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/acl

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/acl. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/acl",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontend_ac_ls(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/acls

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/acls",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_ac_ls(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/acls

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/acls. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/acls",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend_action(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/action

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/action",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend_action(
    acl: str,
    action: str,
    parent_id: str | int,
    confirm: bool = False,
    backend: str | None = None,
    customaction: str | None = None,
    deny_status: str | None = None,
    find: str | None = None,
    fmt: str | None = None,
    lua_function: str | None = None,
    name: str | None = None,
    path: str | None = None,
    realm: str | None = None,
    reason: str | None = None,
    replace: str | None = None,
    rule: str | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    acl: The name of the frontend ACL this action is associated with. For unconditional actions, use the name of any existing ACL (the action will apply regardless). Cannot be empty.
    action: The action to take when an ACL match is found. Valid values: ['use_backend', 'custom', 'http-request_allow', 'http-request_deny', 'http-request_tarpit', 'http-request_auth', 'http-request_redirect', 'http-request_lua', 'http-request_use-service', 'http-request_add-header', 'http-request_set-header', 'http-request_del-header', 'http-request_replace-header', 'http-request_replace-path', 'http-request_replace-value', 'http-request_set-method', 'http-request_set-path', 'http-request_set-query', 'http-request_set-uri', 'http-response_allow', 'http-response_deny', 'http-response_lua', 'http-response_add-header', 'http-response_set-header', 'http-response_del-header', 'http-response_replace-header', 'http-response_replace-value', 'http-response_set-status', 'http-after-response_add-header', 'http-after-response_set-header', 'http-after-response_del-header', 'http-after-response_replace-header', 'http-after-response_replace-value', 'http-after-response_set-status', 'tcp-request_connection_accept', 'tcp-request_connection_reject', 'tcp-request_content_accept', 'tcp-request_content_reject', 'tcp-request_content_lua', 'tcp-request_content_use-service', 'tcp-response_content_accept', 'tcp-response_content_close', 'tcp-response_content_reject', 'tcp-response_content_lua']
    parent_id: The ID of the parent this object is nested under.
    backend: The backend to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'use_backend'`
    customaction: The custom action to take when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'custom'`
    deny_status: The deny status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_deny, http-request_tarpit ]
    find: The value to find when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    fmt: The fmt value to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]
    lua_function: The Lua function to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]
    name: The name to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]
    path: The path to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_replace-path'`
    realm: The authentication realm to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_auth'`
    reason: The status reason to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    replace: The value to replace with when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    rule: The redirect rule to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_redirect'`
    status: The status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if acl is not None:
        body["acl"] = acl
    if action is not None:
        body["action"] = action
    if parent_id is not None:
        body["parent_id"] = parent_id
    if backend is not None:
        body["backend"] = backend
    if customaction is not None:
        body["customaction"] = customaction
    if deny_status is not None:
        body["deny_status"] = deny_status
    if find is not None:
        body["find"] = find
    if fmt is not None:
        body["fmt"] = fmt
    if lua_function is not None:
        body["lua_function"] = lua_function
    if name is not None:
        body["name"] = name
    if path is not None:
        body["path"] = path
    if realm is not None:
        body["realm"] = realm
    if reason is not None:
        body["reason"] = reason
    if replace is not None:
        body["replace"] = replace
    if rule is not None:
        body["rule"] = rule
    if status is not None:
        body["status"] = status
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    acl: str | None = None,
    action: str | None = None,
    backend: str | None = None,
    customaction: str | None = None,
    deny_status: str | None = None,
    find: str | None = None,
    fmt: str | None = None,
    lua_function: str | None = None,
    name: str | None = None,
    path: str | None = None,
    realm: str | None = None,
    reason: str | None = None,
    replace: str | None = None,
    rule: str | None = None,
    status: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    acl: The name of the frontend ACL this action is associated with.
    action: The action to take when an ACL match is found. Valid values: ['use_backend', 'custom', 'http-request_allow', 'http-request_deny', 'http-request_tarpit', 'http-request_auth', 'http-request_redirect', 'http-request_lua', 'http-request_use-service', 'http-request_add-header', 'http-request_set-header', 'http-request_del-header', 'http-request_replace-header', 'http-request_replace-path', 'http-request_replace-value', 'http-request_set-method', 'http-request_set-path', 'http-request_set-query', 'http-request_set-uri', 'http-response_allow', 'http-response_deny', 'http-response_lua', 'http-response_add-header', 'http-response_set-header', 'http-response_del-header', 'http-response_replace-header', 'http-response_replace-value', 'http-response_set-status', 'http-after-response_add-header', 'http-after-response_set-header', 'http-after-response_del-header', 'http-after-response_replace-header', 'http-after-response_replace-value', 'http-after-response_set-status', 'tcp-request_connection_accept', 'tcp-request_connection_reject', 'tcp-request_content_accept', 'tcp-request_content_reject', 'tcp-request_content_lua', 'tcp-request_content_use-service', 'tcp-response_content_accept', 'tcp-response_content_close', 'tcp-response_content_reject', 'tcp-response_content_lua']
    backend: The backend to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'use_backend'`
    customaction: The custom action to take when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'custom'`
    deny_status: The deny status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_deny, http-request_tarpit ]
    find: The value to find when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-response_replace-header, http-request_replace-path, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    fmt: The fmt value to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_set-method, http-request_set-path, http-request_set-query, http-request_set-uri, http-response_add-header, http-response_set-header, http-after-response_add-header, http-after-response_set-header ]
    lua_function: The Lua function to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_lua, http-request_use-service, http-response_lua, tcp-request_content_lua, tcp-request_content_use-service, tcp-response_content_lua ]
    name: The name to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_add-header, http-request_set-header, http-request_del-header, http-request_replace-header, http-request_replace-value, http-response_add-header, http-response_set-header, http-response_del-header, http-response_replace-header, http-response_replace-value, http-after-response_add-header, http-after-response_set-header, http-after-response_del-header, http-after-response_replace-header, http-after-response_replace-value ]
    path: The path to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_replace-path'`
    realm: The authentication realm to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_auth'`
    reason: The status reason to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    replace: The value to replace with when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-request_replace-header, http-request_replace-value, http-request_replace-path, http-response_replace-header, http-response_replace-value, http-after-response_replace-header, http-after-response_replace-value ]
    rule: The redirect rule to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be equal to `'http-request_redirect'`
    status: The status to use when an ACL match is found.This field is only available when the following conditions are met:- `action` must be one of [ http-response_set-status, http-after-response_set-status ]
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if acl is not None:
        body["acl"] = acl
    if action is not None:
        body["action"] = action
    if backend is not None:
        body["backend"] = backend
    if customaction is not None:
        body["customaction"] = customaction
    if deny_status is not None:
        body["deny_status"] = deny_status
    if find is not None:
        body["find"] = find
    if fmt is not None:
        body["fmt"] = fmt
    if lua_function is not None:
        body["lua_function"] = lua_function
    if name is not None:
        body["name"] = name
    if path is not None:
        body["path"] = path
    if realm is not None:
        body["realm"] = realm
    if reason is not None:
        body["reason"] = reason
    if replace is not None:
        body["replace"] = replace
    if rule is not None:
        body["rule"] = rule
    if status is not None:
        body["status"] = status
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend/action",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_action(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/action

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/action. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/action",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontend_actions(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/actions

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/actions",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_actions(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/actions

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/actions. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/actions",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend_address(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/address

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/address",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend_address(
    extaddr: str,
    parent_id: str | int,
    confirm: bool = False,
    exaddr_advanced: str | None = None,
    extaddr_custom: str | None = None,
    extaddr_port: str | None = None,
    extaddr_ssl: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend/address

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    extaddr: The external address to use. Valid values: ['custom', 'any_ipv4', 'any_ipv6', 'localhost_ipv4', 'localhost_ipv6']
    parent_id: The ID of the parent this object is nested under.
    exaddr_advanced: The advanced configuration to apply to this address.
    extaddr_custom: The custom IPv4 or IPv6 address to use as the external address.This field is only available when the following conditions are met:- `extaddr` must be equal to `'custom'`
    extaddr_port: The port to bind to for this address. Valid options are: a TCP/UDP port number
    extaddr_ssl: Enables or disables using SSL/TLS for this address.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if extaddr is not None:
        body["extaddr"] = extaddr
    if parent_id is not None:
        body["parent_id"] = parent_id
    if exaddr_advanced is not None:
        body["exaddr_advanced"] = exaddr_advanced
    if extaddr_custom is not None:
        body["extaddr_custom"] = extaddr_custom
    if extaddr_port is not None:
        body["extaddr_port"] = extaddr_port
    if extaddr_ssl is not None:
        body["extaddr_ssl"] = extaddr_ssl
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend/address",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend_address(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    exaddr_advanced: str | None = None,
    extaddr: str | None = None,
    extaddr_custom: str | None = None,
    extaddr_port: str | None = None,
    extaddr_ssl: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend/address

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    exaddr_advanced: The advanced configuration to apply to this address.
    extaddr: The external address to use. Valid values: ['custom', 'any_ipv4', 'any_ipv6', 'localhost_ipv4', 'localhost_ipv6']
    extaddr_custom: The custom IPv4 or IPv6 address to use as the external address.This field is only available when the following conditions are met:- `extaddr` must be equal to `'custom'`
    extaddr_port: The port to bind to for this address. Valid options are: a TCP/UDP port number
    extaddr_ssl: Enables or disables using SSL/TLS for this address.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if exaddr_advanced is not None:
        body["exaddr_advanced"] = exaddr_advanced
    if extaddr is not None:
        body["extaddr"] = extaddr
    if extaddr_custom is not None:
        body["extaddr_custom"] = extaddr_custom
    if extaddr_port is not None:
        body["extaddr_port"] = extaddr_port
    if extaddr_ssl is not None:
        body["extaddr_ssl"] = extaddr_ssl
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend/address",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_address(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/address

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/address",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontend_addresses(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/addresses

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/addresses",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_addresses(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/addresses

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/addresses. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/addresses",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend_certificate(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/certificate

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend_certificate(
    parent_id: str | int,
    confirm: bool = False,
    ssl_certificate: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend/certificate

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    parent_id: The ID of the parent this object is nested under.
    ssl_certificate: The SSL/TLS certificate refid to add to this frontend.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend/certificate. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if parent_id is not None:
        body["parent_id"] = parent_id
    if ssl_certificate is not None:
        body["ssl_certificate"] = ssl_certificate
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend_certificate(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    ssl_certificate: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend/certificate

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    ssl_certificate: The SSL/TLS certificate refid to add to this frontend.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend/certificate. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if ssl_certificate is not None:
        body["ssl_certificate"] = ssl_certificate
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_certificate(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/certificate

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/certificate. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontend_certificates(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/certificates

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_certificates(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/certificates

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/certificates. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend(
    name: str,
    type_: str,
    confirm: bool = False,
    a_actionitems: list[dict[str, Any]] | None = None,
    a_errorfiles: list[dict[str, Any]] | None = None,
    a_extaddr: list[dict[str, Any]] | None = None,
    advanced: str | None = None,
    advanced_bind: str | None = None,
    backend_serverpool: str | None = None,
    client_timeout: int | None = 30000,
    descr: str | None = None,
    dontlog_normal: bool | None = None,
    dontlognull: bool | None = None,
    forwardfor: bool | None = None,
    ha_acls: list[dict[str, Any]] | None = None,
    ha_certificates: list[dict[str, Any]] | None = None,
    httpclose: str | None = 'http-keep-alive',
    log_detailed: bool | None = None,
    log_separate_errors: bool | None = None,
    max_connections: int | None = None,
    socket_stats: bool | None = None,
    ssloffloadcert: str | None = None,
    status: str | None = 'active',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    name: The unique name for this HAProxy frontend.
    type_: The processing type for this frontend. Valid values: ['http', 'https', 'tcp']
    a_actionitems: The actions to take when an ACL match is found.
    a_errorfiles: The custom error files to use for this frontend.
    a_extaddr: The external addresses assigned to this frontend.
    advanced: Custom configuration to pass to this frontend.
    advanced_bind: Custom value to pass behind each bind option.
    backend_serverpool: The default backend to use for this frontend.
    client_timeout: The amount of time (in milliseconds) to wait for data from the client.
    descr: The description for this HAProxy frontend.
    dontlog_normal: Enables or disables only logging anomalous (not normal) connection.
    dontlognull: Enables or disables logging connections with no data transferred.
    forwardfor: Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.This field is only available when the following conditions are met:- `type` must be equal to `'http'`
    ha_acls: The ACLs to apply to this frontend.
    ha_certificates: The additional SSL/TLS certificates to use on this frontend.
    httpclose: The `httpclose` option this frontend will operate. Valid values: ['http-keep-alive', 'http-tunnel', 'httpclose', 'http-server-close', 'forceclose']
    log_detailed: Enables or disables more detailed logging.
    log_separate_errors: Enables or disables changing the log level from info to err on potentially interesting info.
    max_connections: The maximum number of connections allowed by this frontend.
    socket_stats: Enables or disables collecting and providing separate statistics for each socket.
    ssloffloadcert: The default SSL/TLS certificate refid to use for this frontend.
    status: The activation status for this HAProxy frontend. Valid values: ['active', 'disabled']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    if a_actionitems is not None:
        body["a_actionitems"] = a_actionitems
    if a_errorfiles is not None:
        body["a_errorfiles"] = a_errorfiles
    if a_extaddr is not None:
        body["a_extaddr"] = a_extaddr
    if advanced is not None:
        body["advanced"] = advanced
    if advanced_bind is not None:
        body["advanced_bind"] = advanced_bind
    if backend_serverpool is not None:
        body["backend_serverpool"] = backend_serverpool
    if client_timeout is not None:
        body["client_timeout"] = client_timeout
    if descr is not None:
        body["descr"] = descr
    if dontlog_normal is not None:
        body["dontlog_normal"] = dontlog_normal
    if dontlognull is not None:
        body["dontlognull"] = dontlognull
    if forwardfor is not None:
        body["forwardfor"] = forwardfor
    if ha_acls is not None:
        body["ha_acls"] = ha_acls
    if ha_certificates is not None:
        body["ha_certificates"] = ha_certificates
    if httpclose is not None:
        body["httpclose"] = httpclose
    if log_detailed is not None:
        body["log_detailed"] = log_detailed
    if log_separate_errors is not None:
        body["log_separate_errors"] = log_separate_errors
    if max_connections is not None:
        body["max_connections"] = max_connections
    if socket_stats is not None:
        body["socket_stats"] = socket_stats
    if ssloffloadcert is not None:
        body["ssloffloadcert"] = ssloffloadcert
    if status is not None:
        body["status"] = status
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend(
    id: str | int,
    confirm: bool = False,
    a_actionitems: list[dict[str, Any]] | None = None,
    a_errorfiles: list[dict[str, Any]] | None = None,
    a_extaddr: list[dict[str, Any]] | None = None,
    advanced: str | None = None,
    advanced_bind: str | None = None,
    backend_serverpool: str | None = None,
    client_timeout: int | None = None,
    descr: str | None = None,
    dontlog_normal: bool | None = None,
    dontlognull: bool | None = None,
    forwardfor: bool | None = None,
    ha_acls: list[dict[str, Any]] | None = None,
    ha_certificates: list[dict[str, Any]] | None = None,
    httpclose: str | None = None,
    log_detailed: bool | None = None,
    log_separate_errors: bool | None = None,
    max_connections: int | None = None,
    name: str | None = None,
    socket_stats: bool | None = None,
    ssloffloadcert: str | None = None,
    status: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    a_actionitems: The actions to take when an ACL match is found.
    a_errorfiles: The custom error files to use for this frontend.
    a_extaddr: The external addresses assigned to this frontend.
    advanced: Custom configuration to pass to this frontend.
    advanced_bind: Custom value to pass behind each bind option.
    backend_serverpool: The default backend to use for this frontend.
    client_timeout: The amount of time (in milliseconds) to wait for data from the client.
    descr: The description for this HAProxy frontend.
    dontlog_normal: Enables or disables only logging anomalous (not normal) connection.
    dontlognull: Enables or disables logging connections with no data transferred.
    forwardfor: Enables or disables the HTTP X-Forwarded-For header which contains the client's IP address.This field is only available when the following conditions are met:- `type` must be equal to `'http'`
    ha_acls: The ACLs to apply to this frontend.
    ha_certificates: The additional SSL/TLS certificates to use on this frontend.
    httpclose: The `httpclose` option this frontend will operate. Valid values: ['http-keep-alive', 'http-tunnel', 'httpclose', 'http-server-close', 'forceclose']
    log_detailed: Enables or disables more detailed logging.
    log_separate_errors: Enables or disables changing the log level from info to err on potentially interesting info.
    max_connections: The maximum number of connections allowed by this frontend.
    name: The unique name for this HAProxy frontend.
    socket_stats: Enables or disables collecting and providing separate statistics for each socket.
    ssloffloadcert: The default SSL/TLS certificate refid to use for this frontend.
    status: The activation status for this HAProxy frontend. Valid values: ['active', 'disabled']
    type_: The processing type for this frontend. Valid values: ['http', 'https', 'tcp']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if a_actionitems is not None:
        body["a_actionitems"] = a_actionitems
    if a_errorfiles is not None:
        body["a_errorfiles"] = a_errorfiles
    if a_extaddr is not None:
        body["a_extaddr"] = a_extaddr
    if advanced is not None:
        body["advanced"] = advanced
    if advanced_bind is not None:
        body["advanced_bind"] = advanced_bind
    if backend_serverpool is not None:
        body["backend_serverpool"] = backend_serverpool
    if client_timeout is not None:
        body["client_timeout"] = client_timeout
    if descr is not None:
        body["descr"] = descr
    if dontlog_normal is not None:
        body["dontlog_normal"] = dontlog_normal
    if dontlognull is not None:
        body["dontlognull"] = dontlognull
    if forwardfor is not None:
        body["forwardfor"] = forwardfor
    if ha_acls is not None:
        body["ha_acls"] = ha_acls
    if ha_certificates is not None:
        body["ha_certificates"] = ha_certificates
    if httpclose is not None:
        body["httpclose"] = httpclose
    if log_detailed is not None:
        body["log_detailed"] = log_detailed
    if log_separate_errors is not None:
        body["log_separate_errors"] = log_separate_errors
    if max_connections is not None:
        body["max_connections"] = max_connections
    if name is not None:
        body["name"] = name
    if socket_stats is not None:
        body["socket_stats"] = socket_stats
    if ssloffloadcert is not None:
        body["ssloffloadcert"] = ssloffloadcert
    if status is not None:
        body["status"] = status
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_frontend_error_file(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/error_file

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/error_file",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_frontend_error_file(
    errorcode: int,
    errorfile: str,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/frontend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    errorcode: The HTTP status code that will trigger this error file to be used.
    errorfile: The HAProxy error file object that should be used for the assigned HTTP status code.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/frontend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if errorcode is not None:
        body["errorcode"] = errorcode
    if errorfile is not None:
        body["errorfile"] = errorfile
    if parent_id is not None:
        body["parent_id"] = parent_id
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/frontend/error_file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_frontend_error_file(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    errorcode: int | None = None,
    errorfile: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/frontend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    errorcode: The HTTP status code that will trigger this error file to be used.
    errorfile: The HAProxy error file object that should be used for the assigned HTTP status code.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/frontend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if errorcode is not None:
        body["errorcode"] = errorcode
    if errorfile is not None:
        body["errorfile"] = errorfile
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/frontend/error_file",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_error_file(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/error_file

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/error_file. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/error_file",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontend_error_files(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontend/error_files

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontend/error_files",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontend_error_files(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontend/error_files

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontend/error_files. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontend/error_files",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_frontends(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/frontends

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/frontends",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_ha_proxy_frontends(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/haproxy/frontends

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/haproxy/frontends. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/haproxy/frontends",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_frontends(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/frontends

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/frontends. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/frontends",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_settings_dns_resolver(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/settings/dns_resolver

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/settings/dns_resolver",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_settings_dns_resolver(
    name: str,
    server: str,
    confirm: bool = False,
    port: str | None = '53',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/settings/dns_resolver

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    name: The descriptive name for this DNS server.
    server: The IP or hostname of the DNS server.
    port: The port used by this DNS server. Valid options are: a TCP/UDP port number
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/settings/dns_resolver. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if server is not None:
        body["server"] = server
    if port is not None:
        body["port"] = port
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/settings/dns_resolver",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_settings_dns_resolver(
    id: str | int,
    confirm: bool = False,
    name: str | None = None,
    port: str | None = None,
    server: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/settings/dns_resolver

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    name: The descriptive name for this DNS server.
    port: The port used by this DNS server. Valid options are: a TCP/UDP port number
    server: The IP or hostname of the DNS server.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/settings/dns_resolver. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if name is not None:
        body["name"] = name
    if port is not None:
        body["port"] = port
    if server is not None:
        body["server"] = server
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/settings/dns_resolver",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_settings_dns_resolver(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/settings/dns_resolver

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/settings/dns_resolver. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/settings/dns_resolver",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_settings_dns_resolvers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/settings/dns_resolvers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/settings/dns_resolvers",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_settings_dns_resolvers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/settings/dns_resolvers

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/settings/dns_resolvers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/settings/dns_resolvers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_settings_email_mailer(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/settings/email_mailer

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/settings/email_mailer",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ha_proxy_settings_email_mailer(
    mailserver: str,
    name: str,
    confirm: bool = False,
    mailserverport: str | None = '53',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/haproxy/settings/email_mailer

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    mailserver: The IP or hostname of the mail server.
    name: The descriptive name for this mail server.
    mailserverport: The port used by this mail server. Valid options are: a TCP/UDP port number
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/haproxy/settings/email_mailer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if mailserver is not None:
        body["mailserver"] = mailserver
    if name is not None:
        body["name"] = name
    if mailserverport is not None:
        body["mailserverport"] = mailserverport
    return await _client.request(
        "POST",
        "/api/v2/services/haproxy/settings/email_mailer",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_settings_email_mailer(
    id: str | int,
    confirm: bool = False,
    mailserver: str | None = None,
    mailserverport: str | None = None,
    name: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/settings/email_mailer

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    mailserver: The IP or hostname of the mail server.
    mailserverport: The port used by this mail server. Valid options are: a TCP/UDP port number
    name: The descriptive name for this mail server.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/settings/email_mailer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if mailserver is not None:
        body["mailserver"] = mailserver
    if mailserverport is not None:
        body["mailserverport"] = mailserverport
    if name is not None:
        body["name"] = name
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/settings/email_mailer",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_settings_email_mailer(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/settings/email_mailer

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/settings/email_mailer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/settings/email_mailer",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ha_proxy_settings_email_mailers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/settings/email_mailers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/settings/email_mailers",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_services_ha_proxy_settings_email_mailers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/haproxy/settings/email_mailers

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/haproxy/settings/email_mailers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/haproxy/settings/email_mailers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ha_proxy_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/haproxy/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/haproxy/settings",
    )


@mcp.tool()
async def pfsense_update_services_ha_proxy_settings(
    confirm: bool = False,
    advanced: str | None = None,
    carpdev: str | None = None,
    dns_resolvers: list[dict[str, Any]] | None = None,
    email_from: str | None = None,
    email_level: str | None = None,
    email_mailers: list[dict[str, Any]] | None = None,
    email_myhostname: str | None = None,
    email_to: str | None = None,
    enable: bool | None = None,
    enablesync: bool | None = None,
    hard_stop_after: str | None = None,
    localstats_refreshtime: int | None = None,
    localstats_sticktable_refreshtime: int | None = None,
    localstatsport: str | None = None,
    log_send_hostname: str | None = None,
    logfacility: str | None = None,
    loglevel: str | None = None,
    maxconn: int | None = None,
    nbthread: int | None = None,
    remotesyslog: str | None = None,
    resolver_holdvalid: str | None = None,
    resolver_retries: int | None = None,
    resolver_timeoutretry: str | None = None,
    sslcompatibilitymode: str | None = None,
    ssldefaultdhparam: int | None = None,
    terminate_on_reload: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/haproxy/settings

    Note: Call pfsense_services_haproxy_apply after this to apply changes.

    advanced: Additional HAProxy options to include in the global settings area.
    carpdev: The CARP interface IP to monitor. HAProxy will only run on the firewall whose interface is MASTER.
    dns_resolvers: The DNS resolvers HAProxy will use for DNS queries.
    email_from: The email address to be used as the sender of the emails.
    email_level: The maximum log level to send emails for. Leave empty to disable sending email alerts. Valid values: ['', 'emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']
    email_mailers: The email servers HAProxy will use to send SMTP alerts.
    email_myhostname: The hostname to use as the origin of the email.
    email_to: The email address to send emails to.
    enable: Enables or disable HAProxy on the system.
    enablesync: Enables or disables including HAProxy configurations in HA sync if configured.
    hard_stop_after: The maximum time allowed to perform a clean soft-stop. This can be represented as different time values such as 30s, 15m, 3h or 1d.
    localstats_refreshtime: The internal (in seconds) in which local stats will be refreshed.
    localstats_sticktable_refreshtime: The internal (in seconds) in which the sticktable stats will be refreshed.
    localstatsport: The internal port to be used for the stats tab. Set to null to disable local stats. Valid options are: a TCP/UDP port number
    log_send_hostname: The hostname field to include in the syslog header. Leave empty to use the system hostname.
    logfacility: The logging facility to log to. Valid values: ['kern', 'user', 'mail', 'daemon', 'auth', 'syslog', 'lpr', 'news', 'uucp', 'cron', 'auth2', 'ftp', 'ntp', 'audit', 'cron2', 'local0', 'local1', 'local2', 'local3', 'local4', 'local5', 'local6', 'local7']
    loglevel: The log level to begin logging events. Only events of this level or higher will be logged. Valid values: ['emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug']
    maxconn: The maximum per-process number of concurrent connections
    nbthread: The number of threads to start per process. This setting is experimental.
    remotesyslog: The IP address or hostname of the remote syslog server to send logs to. Use `/var/run/log` to to log to the local pfSense system log.
    resolver_holdvalid: The interval between two successive name resolution when the last answer was valid.
    resolver_retries: The number of queries to send to resolve a server name before giving up.
    resolver_timeoutretry: The time between two DNS queries, when no response have been received.
    sslcompatibilitymode: The SSL/TLS compatibility mode which determines the cipher suites and TLS versions supported. Valid values: ['auto', 'modern', 'intermediate', 'old']
    ssldefaultdhparam: The maximum size of the Diffie-Hellman parameters used for generating the ephemeral/temporary Diffie-Hellman key in case of DHE key exchange
    terminate_on_reload: Enables or disables an immediate stop of old process on reload. (closes existing connections)
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/haproxy/settings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_services_haproxy_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if advanced is not None:
        body["advanced"] = advanced
    if carpdev is not None:
        body["carpdev"] = carpdev
    if dns_resolvers is not None:
        body["dns_resolvers"] = dns_resolvers
    if email_from is not None:
        body["email_from"] = email_from
    if email_level is not None:
        body["email_level"] = email_level
    if email_mailers is not None:
        body["email_mailers"] = email_mailers
    if email_myhostname is not None:
        body["email_myhostname"] = email_myhostname
    if email_to is not None:
        body["email_to"] = email_to
    if enable is not None:
        body["enable"] = enable
    if enablesync is not None:
        body["enablesync"] = enablesync
    if hard_stop_after is not None:
        body["hard_stop_after"] = hard_stop_after
    if localstats_refreshtime is not None:
        body["localstats_refreshtime"] = localstats_refreshtime
    if localstats_sticktable_refreshtime is not None:
        body["localstats_sticktable_refreshtime"] = localstats_sticktable_refreshtime
    if localstatsport is not None:
        body["localstatsport"] = localstatsport
    if log_send_hostname is not None:
        body["log_send_hostname"] = log_send_hostname
    if logfacility is not None:
        body["logfacility"] = logfacility
    if loglevel is not None:
        body["loglevel"] = loglevel
    if maxconn is not None:
        body["maxconn"] = maxconn
    if nbthread is not None:
        body["nbthread"] = nbthread
    if remotesyslog is not None:
        body["remotesyslog"] = remotesyslog
    if resolver_holdvalid is not None:
        body["resolver_holdvalid"] = resolver_holdvalid
    if resolver_retries is not None:
        body["resolver_retries"] = resolver_retries
    if resolver_timeoutretry is not None:
        body["resolver_timeoutretry"] = resolver_timeoutretry
    if sslcompatibilitymode is not None:
        body["sslcompatibilitymode"] = sslcompatibilitymode
    if ssldefaultdhparam is not None:
        body["ssldefaultdhparam"] = ssldefaultdhparam
    if terminate_on_reload is not None:
        body["terminate_on_reload"] = terminate_on_reload
    return await _client.request(
        "PATCH",
        "/api/v2/services/haproxy/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_ntp_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/ntp/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/services/ntp/settings",
    )


@mcp.tool()
async def pfsense_update_services_ntp_settings(
    confirm: bool = False,
    clockstats: bool | None = None,
    dnsresolv: str | None = None,
    enable: bool | None = None,
    interface: list[str] | None = None,
    leapsec: str | None = None,
    logpeer: bool | None = None,
    logsys: bool | None = None,
    loopstats: bool | None = None,
    ntpmaxpeers: int | None = None,
    ntpmaxpoll: str | None = None,
    ntpminpoll: str | None = None,
    orphan: int | None = None,
    peerstats: bool | None = None,
    serverauth: bool | None = None,
    serverauthalgo: str | None = None,
    serverauthkey: str | None = None,
    statsgraph: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/ntp/settings

    clockstats: Enable or disable logging reference clock statistics.
    dnsresolv: The IP protocol peers are forced to use for DNS resolution. Valid values: ['auto', 'inet', 'inet6']
    enable: Enables or disabled the NTP server.
    interface: The interfaces the NTP server will listen on.
    leapsec: The Leap second configuration as text.
    logpeer: Enable or disable logging peer messages.
    logsys: Enable or disable logging system messages.
    loopstats: Enable or disable logging clock discipline statistics.
    ntpmaxpeers: The maximum number of candidate peers in the NTP pool.
    ntpmaxpoll: The maximum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value. This value must be greater than the `ntpminpoll`. Valid values: ['', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', 'omit']
    ntpminpoll: The minimum poll interval for NTP messages. Use empty string to assume system default, and `omit` to not set this value. Valid values: ['', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', 'omit']
    orphan: The orphan mode stratum to set. Orphan mode allows the system clock to be used when no other clocks are available. The number here specifies the stratum reported during orphan mode and should normally be set to a number high enough to ensure that any other servers available to clients are preferred over this server
    peerstats: Enable or disable logging peer statistics.
    serverauth: Enable or disable NTPv3 server authentication. (RFC 1305)
    serverauthalgo: The digest algorithm for the server authentication key. Valid values: ['md5', 'sha1', 'sha256']
    serverauthkey: The NTP server authentication key.This field is only available when the following conditions are met:- `serverauth` must be equal to `true`
    statsgraph: Enable or disable RRD graphs for NTP statistics.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/ntp/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if clockstats is not None:
        body["clockstats"] = clockstats
    if dnsresolv is not None:
        body["dnsresolv"] = dnsresolv
    if enable is not None:
        body["enable"] = enable
    if interface is not None:
        body["interface"] = interface
    if leapsec is not None:
        body["leapsec"] = leapsec
    if logpeer is not None:
        body["logpeer"] = logpeer
    if logsys is not None:
        body["logsys"] = logsys
    if loopstats is not None:
        body["loopstats"] = loopstats
    if ntpmaxpeers is not None:
        body["ntpmaxpeers"] = ntpmaxpeers
    if ntpmaxpoll is not None:
        body["ntpmaxpoll"] = ntpmaxpoll
    if ntpminpoll is not None:
        body["ntpminpoll"] = ntpminpoll
    if orphan is not None:
        body["orphan"] = orphan
    if peerstats is not None:
        body["peerstats"] = peerstats
    if serverauth is not None:
        body["serverauth"] = serverauth
    if serverauthalgo is not None:
        body["serverauthalgo"] = serverauthalgo
    if serverauthkey is not None:
        body["serverauthkey"] = serverauthkey
    if statsgraph is not None:
        body["statsgraph"] = statsgraph
    return await _client.request(
        "PATCH",
        "/api/v2/services/ntp/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_ntp_time_server(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/ntp/time_server

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/ntp/time_server",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_ntp_time_server(
    timeserver: str,
    confirm: bool = False,
    noselect: bool | None = None,
    prefer: bool | None = None,
    type_: str | None = 'server',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/ntp/time_server

    timeserver: The IP or hostname of the remote NTP time server, pool or peer.
    noselect: Prevent NTP from using this timeserver, but continue collecting stats.This field is only available when the following conditions are met:- `type` must not be equal to `'pool'`
    prefer: Enable NTP favoring the use of this server more than all others.
    type_: The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`. Valid values: ['server', 'pool', 'peer']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/ntp/time_server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if timeserver is not None:
        body["timeserver"] = timeserver
    if noselect is not None:
        body["noselect"] = noselect
    if prefer is not None:
        body["prefer"] = prefer
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/services/ntp/time_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_ntp_time_server(
    id: str | int,
    confirm: bool = False,
    noselect: bool | None = None,
    prefer: bool | None = None,
    timeserver: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/ntp/time_server

    id: The ID of the object or resource to interact with.
    noselect: Prevent NTP from using this timeserver, but continue collecting stats.This field is only available when the following conditions are met:- `type` must not be equal to `'pool'`
    prefer: Enable NTP favoring the use of this server more than all others.
    timeserver: The IP or hostname of the remote NTP time server, pool or peer.
    type_: The type of this timeserver. Use `server` is `timeserver` is a standalone NTP server, use `pool` if `timeserver` represents an NTP pool, or `peer` if `timeserver` is an NTP peer. Note: If the `timeserver` value ends with the `pool.ntp.org` suffix, this field will be forced to use `pool`. Valid values: ['server', 'pool', 'peer']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/ntp/time_server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if noselect is not None:
        body["noselect"] = noselect
    if prefer is not None:
        body["prefer"] = prefer
    if timeserver is not None:
        body["timeserver"] = timeserver
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/services/ntp/time_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ntp_time_server(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/ntp/time_server

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/ntp/time_server. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/ntp/time_server",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_ntp_time_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/ntp/time_servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/ntp/time_servers",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_ntp_time_servers(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/ntp/time_servers

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/ntp/time_servers. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/ntp/time_servers",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_ntp_time_servers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/ntp/time_servers

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/ntp/time_servers. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/ntp/time_servers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_services_ssh(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/ssh
    """
    return await _client.request(
        "GET",
        "/api/v2/services/ssh",
    )


@mcp.tool()
async def pfsense_update_services_ssh(
    confirm: bool = False,
    enable: bool | None = None,
    port: str | None = None,
    sshdagentforwarding: bool | None = None,
    sshdkeyonly: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/ssh

    enable: Enable the SSH server on this system.
    port: The TCP port the SSH server will listen on. Valid options are: a TCP/UDP port number
    sshdagentforwarding: Enable support for ssh-agent forwarding.
    sshdkeyonly: The SSH authentication mode to use. Use `enabled` to require public key authentication, use both to require both a public key AND a password, or use `null` to allow a password OR a public key. Valid values: ['enabled', 'both']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/ssh. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if enable is not None:
        body["enable"] = enable
    if port is not None:
        body["port"] = port
    if sshdagentforwarding is not None:
        body["sshdagentforwarding"] = sshdagentforwarding
    if sshdkeyonly is not None:
        body["sshdkeyonly"] = sshdkeyonly
    return await _client.request(
        "PATCH",
        "/api/v2/services/ssh",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_services_service_watchdog(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/service_watchdog

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/services/service_watchdog",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_service_watchdog(
    name: str,
    confirm: bool = False,
    notify: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/service_watchdog

    name: The name of the service to be watched.
    notify: Enable or disable notifications being sent when Service Watchdogs finds this service stopped.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/service_watchdog. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if notify is not None:
        body["notify"] = notify
    return await _client.request(
        "POST",
        "/api/v2/services/service_watchdog",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_services_service_watchdog(
    id: str | int,
    confirm: bool = False,
    name: str | None = None,
    notify: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/services/service_watchdog

    id: The ID of the object or resource to interact with.
    name: The name of the service to be watched.
    notify: Enable or disable notifications being sent when Service Watchdogs finds this service stopped.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/services/service_watchdog. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if name is not None:
        body["name"] = name
    if notify is not None:
        body["notify"] = notify
    return await _client.request(
        "PATCH",
        "/api/v2/services/service_watchdog",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_service_watchdog(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/service_watchdog

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/service_watchdog. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/services/service_watchdog",
        params=params,
    )


@mcp.tool()
async def pfsense_list_services_service_watchdogs(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/services/service_watchdogs

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/services/service_watchdogs",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_services_service_watchdogs(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/services/service_watchdogs

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/services/service_watchdogs. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/services/service_watchdogs",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_services_service_watchdogs(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/services/service_watchdogs

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/services/service_watchdogs. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/services/service_watchdogs",
        params=params,
    )


@mcp.tool()
async def pfsense_create_services_wake_on_lan_send(
    interface: str,
    mac_addr: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/services/wake_on_lan/send

    interface: The interface the host to be woken up is connected to.
    mac_addr: The MAC address of the host to be awoken.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/services/wake_on_lan/send. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if interface is not None:
        body["interface"] = interface
    if mac_addr is not None:
        body["mac_addr"] = mac_addr
    return await _client.request(
        "POST",
        "/api/v2/services/wake_on_lan/send",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_status_carp(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/carp
    """
    return await _client.request(
        "GET",
        "/api/v2/status/carp",
    )


@mcp.tool()
async def pfsense_update_status_carp(
    enable: bool,
    maintenance_mode: bool,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/status/carp

    enable: Enables or disables CARP on this system.
    maintenance_mode: Enables or disables CARP maintenance mode on this system.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/status/carp. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if enable is not None:
        body["enable"] = enable
    if maintenance_mode is not None:
        body["maintenance_mode"] = maintenance_mode
    return await _client.request(
        "PATCH",
        "/api/v2/status/carp",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_status_dhcp_server_leases(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/dhcp_server/leases

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/dhcp_server/leases",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_status_dhcp_server_leases(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/status/dhcp_server/leases

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/status/dhcp_server/leases. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/status/dhcp_server/leases",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_gateways(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/gateways

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/gateways",
        params=params,
    )


@mcp.tool()
async def pfsense_get_status_i_psec_child_sa(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/ipsec/child_sa

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/status/ipsec/child_sa",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_i_psec_child_s_as(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/ipsec/child_sas

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/ipsec/child_sas",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_i_psec_s_as(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/ipsec/sas

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/ipsec/sas",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_interfaces(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/interfaces

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/interfaces",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_logs_auth(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/auth

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/auth",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_logs_dhcp(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/dhcp

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/dhcp",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_logs_firewall(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/firewall

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/firewall",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_logs_open_vpn(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/openvpn

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/openvpn",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_logs_packages_restapi(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/packages/restapi

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/packages/restapi",
        params=params,
    )


@mcp.tool()
async def pfsense_get_status_logs_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/status/logs/settings",
    )


@mcp.tool()
async def pfsense_update_status_logs_settings(
    confirm: bool = False,
    auth: bool | None = None,
    dhcp: bool | None = None,
    disablelocallogging: bool | None = None,
    dpinger: bool | None = None,
    enableremotelogging: bool | None = None,
    filter: bool | None = None,
    filterdescriptions: int | None = None,
    format: str | None = None,
    hostapd: bool | None = None,
    ipprotocol: str | None = None,
    logall: bool | None = None,
    logcompressiontype: str | None = None,
    logconfigchanges: bool | None = None,
    logfilesize: int | None = None,
    nentries: int | None = None,
    nologbogons: bool | None = None,
    nologdefaultblock: bool | None = None,
    nologdefaultpass: bool | None = None,
    nolognginx: bool | None = None,
    nologprivatenets: bool | None = None,
    ntpd: bool | None = None,
    portalauth: bool | None = None,
    ppp: bool | None = None,
    rawfilter: bool | None = None,
    remoteserver: str | None = None,
    remoteserver2: str | None = None,
    remoteserver3: str | None = None,
    resolver: bool | None = None,
    reverseorder: bool | None = None,
    rotatecount: int | None = None,
    routing: bool | None = None,
    sourceip: str | None = None,
    system: bool | None = None,
    vpn: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/status/logs/settings

    auth: Log authentication events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    dhcp: Log DHCP events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    disablelocallogging: Disable writing log entries to the local disk. WARNING: This will also disable Login Protection!
    dpinger: Log gateway monitoring events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    enableremotelogging: Enable remote logging.
    filter: Log filter events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    filterdescriptions: Display filter descriptions in the log entries Use `0` to not load descriptions, `1` to display descriptions in their own column, or `2` to display the description in a second row. Valid values: [0, 1, 2]
    format: The format of the log entries. Valid values: ['rfc3164', 'rfc5424']
    hostapd: Log wireless authentication events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    ipprotocol: The IP protocol to use for remote logging.This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true` Valid values: ['ipv4', 'ipv6']
    logall: Log everything to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`
    logcompressiontype: The type of compression to use for log files. Valid values: ['bzip2', 'gzip', 'xz', 'zstd', 'none']
    logconfigchanges: Log changes made to the pfSense configuration.
    logfilesize: The maximum size of the log file in kilobytes.
    nentries: The number of log entries to display in the UI.
    nologbogons: Log packets blocked by Block Bogon Networks rules.
    nologdefaultblock: Do not log packets that are blocked by the implicit default block rule.
    nologdefaultpass: Do not log packets that are allowed by the implicit default pass rule.
    nolognginx: Do not Log errors from the web server process.
    nologprivatenets: Log packets blocked by Block Private Networks rules.
    ntpd: Log NTP events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    portalauth: Log captive portal authentication events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    ppp: Log PPP events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    rawfilter: Display logs in the UI as they are generated by the packet filter, without any formatting.
    remoteserver: The first remote syslog server to send log entries to.This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`
    remoteserver2: The second remote syslog server to send log entries to.This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `remoteserver` must not be equal to `NULL`
    remoteserver3: The third remote syslog server to send log entries to.This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `remoteserver` must not be equal to `NULL`- `remoteserver2` must not be equal to `NULL`
    resolver: Log DNS resolver events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    reverseorder: Reverse the order of log entries.
    rotatecount: The number of log file rotations to keep.
    routing: Log routing events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    sourceip: The interface to use as the source IP address for remote logging.This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`
    system: Log system events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    vpn: Log VPN events to the remote syslog server(s).This field is only available when the following conditions are met:- `enableremotelogging` must be equal to `true`- `logall` must not be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/status/logs/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if auth is not None:
        body["auth"] = auth
    if dhcp is not None:
        body["dhcp"] = dhcp
    if disablelocallogging is not None:
        body["disablelocallogging"] = disablelocallogging
    if dpinger is not None:
        body["dpinger"] = dpinger
    if enableremotelogging is not None:
        body["enableremotelogging"] = enableremotelogging
    if filter is not None:
        body["filter"] = filter
    if filterdescriptions is not None:
        body["filterdescriptions"] = filterdescriptions
    if format is not None:
        body["format"] = format
    if hostapd is not None:
        body["hostapd"] = hostapd
    if ipprotocol is not None:
        body["ipprotocol"] = ipprotocol
    if logall is not None:
        body["logall"] = logall
    if logcompressiontype is not None:
        body["logcompressiontype"] = logcompressiontype
    if logconfigchanges is not None:
        body["logconfigchanges"] = logconfigchanges
    if logfilesize is not None:
        body["logfilesize"] = logfilesize
    if nentries is not None:
        body["nentries"] = nentries
    if nologbogons is not None:
        body["nologbogons"] = nologbogons
    if nologdefaultblock is not None:
        body["nologdefaultblock"] = nologdefaultblock
    if nologdefaultpass is not None:
        body["nologdefaultpass"] = nologdefaultpass
    if nolognginx is not None:
        body["nolognginx"] = nolognginx
    if nologprivatenets is not None:
        body["nologprivatenets"] = nologprivatenets
    if ntpd is not None:
        body["ntpd"] = ntpd
    if portalauth is not None:
        body["portalauth"] = portalauth
    if ppp is not None:
        body["ppp"] = ppp
    if rawfilter is not None:
        body["rawfilter"] = rawfilter
    if remoteserver is not None:
        body["remoteserver"] = remoteserver
    if remoteserver2 is not None:
        body["remoteserver2"] = remoteserver2
    if remoteserver3 is not None:
        body["remoteserver3"] = remoteserver3
    if resolver is not None:
        body["resolver"] = resolver
    if reverseorder is not None:
        body["reverseorder"] = reverseorder
    if rotatecount is not None:
        body["rotatecount"] = rotatecount
    if routing is not None:
        body["routing"] = routing
    if sourceip is not None:
        body["sourceip"] = sourceip
    if system is not None:
        body["system"] = system
    if vpn is not None:
        body["vpn"] = vpn
    return await _client.request(
        "PATCH",
        "/api/v2/status/logs/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_status_logs_system(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/logs/system

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/logs/system",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_open_vpn_clients(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/clients

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/clients",
        params=params,
    )


@mcp.tool()
async def pfsense_get_status_open_vpn_server_connection(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/server/connection

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/server/connection",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_status_open_vpn_server_connection(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/status/openvpn/server/connection

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/status/openvpn/server/connection. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/status/openvpn/server/connection",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_open_vpn_server_connections(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/server/connections

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/server/connections",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_status_open_vpn_server_connections(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/status/openvpn/server/connections

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/status/openvpn/server/connections. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/status/openvpn/server/connections",
        params=params,
    )


@mcp.tool()
async def pfsense_get_status_open_vpn_server_route(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/server/route

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/server/route",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_open_vpn_server_routes(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/server/routes

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/server/routes",
        params=params,
    )


@mcp.tool()
async def pfsense_list_status_open_vpn_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/openvpn/servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/openvpn/servers",
        params=params,
    )


@mcp.tool()
async def pfsense_create_status_service(
    id: str | int,
    confirm: bool = False,
    action: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/status/service

    id: The ID of the object or resource to interact with.
    action: The action to perform against this service. Valid values: ['start', 'stop', 'restart']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/status/service. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if action is not None:
        body["action"] = action
    return await _client.request(
        "POST",
        "/api/v2/status/service",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_status_services(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/services

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/status/services",
        params=params,
    )


@mcp.tool()
async def pfsense_get_status_system(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/status/system
    """
    return await _client.request(
        "GET",
        "/api/v2/status/system",
    )


@mcp.tool()
async def pfsense_get_system_crl(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/crl

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/crl",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_crl(
    caref: str,
    descr: str,
    method: str,
    confirm: bool = False,
    cert: list[dict[str, Any]] | None = None,
    lifetime: int | None = None,
    serial: int | None = None,
    text: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/crl

    caref: The unique ID of the CA that this CRL is associated with.
    descr: The unique name/description for this CRL.
    method: The method used to generate this CRL. Valid values: ['existing', 'internal']
    cert: The list of revoked certificates in this CRL.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    lifetime: The lifetime of this CRL in days.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    serial: The serial number of the CRL.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    text: The raw x509 CRL data.This field is only available when the following conditions are met:- `method` must be equal to `'existing'`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/crl. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if descr is not None:
        body["descr"] = descr
    if method is not None:
        body["method"] = method
    if cert is not None:
        body["cert"] = cert
    if lifetime is not None:
        body["lifetime"] = lifetime
    if serial is not None:
        body["serial"] = serial
    if text is not None:
        body["text"] = text
    return await _client.request(
        "POST",
        "/api/v2/system/crl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_crl(
    id: str | int,
    confirm: bool = False,
    caref: str | None = None,
    cert: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    lifetime: int | None = None,
    method: str | None = None,
    serial: int | None = None,
    text: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/crl

    id: The ID of the object or resource to interact with.
    caref: The unique ID of the CA that this CRL is associated with.
    cert: The list of revoked certificates in this CRL.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    descr: The unique name/description for this CRL.
    lifetime: The lifetime of this CRL in days.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    method: The method used to generate this CRL. Valid values: ['existing', 'internal']
    serial: The serial number of the CRL.This field is only available when the following conditions are met:- `method` must be equal to `'internal'`
    text: The raw x509 CRL data.This field is only available when the following conditions are met:- `method` must be equal to `'existing'`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/crl. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if caref is not None:
        body["caref"] = caref
    if cert is not None:
        body["cert"] = cert
    if descr is not None:
        body["descr"] = descr
    if lifetime is not None:
        body["lifetime"] = lifetime
    if method is not None:
        body["method"] = method
    if serial is not None:
        body["serial"] = serial
    if text is not None:
        body["text"] = text
    return await _client.request(
        "PATCH",
        "/api/v2/system/crl",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_crl(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/crl

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/crl. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/system/crl",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_crl_revoked_certificate(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/crl/revoked_certificate

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/system/crl/revoked_certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_crl_revoked_certificate(
    parent_id: str | int,
    revoke_time: int,
    confirm: bool = False,
    caref: str | None = None,
    certref: str | None = None,
    crt: str | None = None,
    descr: str | None = None,
    prv: str | None = None,
    reason: int | None = None,
    serial: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/crl/revoked_certificate

    parent_id: The ID of the parent this object is nested under.
    revoke_time: The unix timestamp of when the certificate was revoked.
    caref: The unique ID of the CA that signed the revoked certificate.
    certref: The reference ID of the certificate to be revokedThis field is only available when the following conditions are met:- `serial` must be equal to `NULL`
    crt: The X509 certificate string.
    descr: The unique name/description for this CRL.
    prv: The X509 private key string.
    reason: The CRL reason for revocation code. Valid values: [-1, 0, 1, 2, 3, 4, 5, 6, 9]
    serial: The serial number of the certificate to be revoked.
    type_: The type of the certificate to be revoked.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/crl/revoked_certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if parent_id is not None:
        body["parent_id"] = parent_id
    if revoke_time is not None:
        body["revoke_time"] = revoke_time
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if reason is not None:
        body["reason"] = reason
    if serial is not None:
        body["serial"] = serial
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/system/crl/revoked_certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_crl_revoked_certificate(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    caref: str | None = None,
    certref: str | None = None,
    crt: str | None = None,
    descr: str | None = None,
    prv: str | None = None,
    reason: int | None = None,
    revoke_time: int | None = None,
    serial: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/crl/revoked_certificate

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    caref: The unique ID of the CA that signed the revoked certificate.
    certref: The reference ID of the certificate to be revokedThis field is only available when the following conditions are met:- `serial` must be equal to `NULL`
    crt: The X509 certificate string.
    descr: The unique name/description for this CRL.
    prv: The X509 private key string.
    reason: The CRL reason for revocation code. Valid values: [-1, 0, 1, 2, 3, 4, 5, 6, 9]
    revoke_time: The unix timestamp of when the certificate was revoked.
    serial: The serial number of the certificate to be revoked.
    type_: The type of the certificate to be revoked.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/crl/revoked_certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if reason is not None:
        body["reason"] = reason
    if revoke_time is not None:
        body["revoke_time"] = revoke_time
    if serial is not None:
        body["serial"] = serial
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/system/crl/revoked_certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_crl_revoked_certificate(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/crl/revoked_certificate

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/crl/revoked_certificate. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/system/crl/revoked_certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_list_system_cr_ls(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/crls

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/crls",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_system_cr_ls(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/crls

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/crls. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/crls",
        params=params,
    )


@mcp.tool()
async def pfsense_list_system_certificate_authorities(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/certificate_authorities

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/certificate_authorities",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_system_certificate_authorities(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/certificate_authorities

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/certificate_authorities. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/certificate_authorities",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_certificate_authority(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/certificate_authority

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/certificate_authority",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_certificate_authority(
    crt: str,
    descr: str,
    confirm: bool = False,
    prv: str | None = None,
    randomserial: bool | None = None,
    serial: int | None = 1,
    trust: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate_authority

    crt: The X509 certificate string.
    descr: The descriptive name for this certificate authority.
    prv: The X509 private key string.
    randomserial: Enables or disables the randomization of serial numbers for certificates signed by this CA.
    serial: The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.
    trust: Adds or removes this certificate authority from the operating system's trust stored.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate_authority. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if randomserial is not None:
        body["randomserial"] = randomserial
    if serial is not None:
        body["serial"] = serial
    if trust is not None:
        body["trust"] = trust
    return await _client.request(
        "POST",
        "/api/v2/system/certificate_authority",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_certificate_authority(
    id: str | int,
    confirm: bool = False,
    crt: str | None = None,
    descr: str | None = None,
    prv: str | None = None,
    randomserial: bool | None = None,
    serial: int | None = None,
    trust: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/certificate_authority

    id: The ID of the object or resource to interact with.
    crt: The X509 certificate string.
    descr: The descriptive name for this certificate authority.
    prv: The X509 private key string.
    randomserial: Enables or disables the randomization of serial numbers for certificates signed by this CA.
    serial: The decimal number to be used as a sequential serial number for the next certificate to be signed by this CA. This value is ignored when Randomize Serial is checked.
    trust: Adds or removes this certificate authority from the operating system's trust stored.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/certificate_authority. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if randomserial is not None:
        body["randomserial"] = randomserial
    if serial is not None:
        body["serial"] = serial
    if trust is not None:
        body["trust"] = trust
    return await _client.request(
        "PATCH",
        "/api/v2/system/certificate_authority",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_certificate_authority(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/certificate_authority

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/certificate_authority. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/system/certificate_authority",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_certificate_authority_generate(
    descr: str,
    digest_alg: str,
    keytype: str,
    confirm: bool = False,
    caref: str | None = None,
    dn_city: str | None = None,
    dn_commonname: str | None = 'internal-ca',
    dn_country: str | None = None,
    dn_organization: str | None = None,
    dn_organizationalunit: str | None = None,
    dn_state: str | None = None,
    ecname: str | None = None,
    is_intermediate: bool | None = None,
    keylen: int | None = None,
    lifetime: int | None = 3650,
    randomserial: bool | None = None,
    trust: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate_authority/generate

    descr: The descriptive name for this certificate authority.
    digest_alg: The digest algorithm to use when signing certificates.
    keytype: The type of key pair to generate. Valid values: ['RSA', 'ECDSA']
    caref: The certificate authority to use as the parent for this intermediate certificate authority.This field is only available when the following conditions are met:- `is_intermediate` must be equal to `true`
    dn_city: The city for the certificate authority.
    dn_commonname: The common name for the certificate authority.
    dn_country: The country for the certificate authority.
    dn_organization: The organization for the certificate authority.
    dn_organizationalunit: The organizational unit for the certificate authority.
    dn_state: The state for the certificate authority.
    ecname: The name of the elliptic curve to use for the ECDSA key pair.This field is only available when the following conditions are met:- `keytype` must be equal to `'ECDSA'`
    is_intermediate: Indicates if this certificate authority is an intermediate certificate authority.
    keylen: The length of the RSA key pair to generate.This field is only available when the following conditions are met:- `keytype` must be equal to `'RSA'` Valid values: [1024, 2048, 3072, 4096, 6144, 7680, 8192, 15360, 16384]
    lifetime: The number of days the certificate authority is valid for.
    randomserial: Enables or disables the randomization of serial numbers for certificates signed by this CA.
    trust: Adds or removes this certificate authority from the operating system's trust stored.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate_authority/generate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if descr is not None:
        body["descr"] = descr
    if digest_alg is not None:
        body["digest_alg"] = digest_alg
    if keytype is not None:
        body["keytype"] = keytype
    if caref is not None:
        body["caref"] = caref
    if dn_city is not None:
        body["dn_city"] = dn_city
    if dn_commonname is not None:
        body["dn_commonname"] = dn_commonname
    if dn_country is not None:
        body["dn_country"] = dn_country
    if dn_organization is not None:
        body["dn_organization"] = dn_organization
    if dn_organizationalunit is not None:
        body["dn_organizationalunit"] = dn_organizationalunit
    if dn_state is not None:
        body["dn_state"] = dn_state
    if ecname is not None:
        body["ecname"] = ecname
    if is_intermediate is not None:
        body["is_intermediate"] = is_intermediate
    if keylen is not None:
        body["keylen"] = keylen
    if lifetime is not None:
        body["lifetime"] = lifetime
    if randomserial is not None:
        body["randomserial"] = randomserial
    if trust is not None:
        body["trust"] = trust
    return await _client.request(
        "POST",
        "/api/v2/system/certificate_authority/generate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_certificate_authority_renew(
    caref: str,
    confirm: bool = False,
    reusekey: bool | None = True,
    reuseserial: bool | None = True,
    strictsecurity: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate_authority/renew

    caref: The Certificate Authority to renew.
    reusekey: Reuses the existing private key when renewing the certificate authority.
    reuseserial: Reuses the existing serial number when renewing the certificate authority.
    strictsecurity: Enforces strict security measures when renewing the certificate authority.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate_authority/renew. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if reusekey is not None:
        body["reusekey"] = reusekey
    if reuseserial is not None:
        body["reuseserial"] = reuseserial
    if strictsecurity is not None:
        body["strictsecurity"] = strictsecurity
    return await _client.request(
        "POST",
        "/api/v2/system/certificate_authority/renew",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_certificate(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/certificate

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_certificate(
    crt: str,
    descr: str,
    prv: str,
    confirm: bool = False,
    type_: str | None = 'server',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate

    crt: The X509 certificate string.
    descr: The descriptive name for this certificate.
    prv: The X509 private key string.
    type_: The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes. Valid values: ['server', 'user']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/system/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_certificate(
    id: str | int,
    confirm: bool = False,
    crt: str | None = None,
    descr: str | None = None,
    prv: str | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/certificate

    id: The ID of the object or resource to interact with.
    crt: The X509 certificate string.
    descr: The descriptive name for this certificate.
    prv: The X509 private key string.
    type_: The certificate type. Use `server` when this certificate is to be used by one or more services on this system. Use `user` when this certificate is intended to be assigned to a user for authentication purposes. Valid values: ['server', 'user']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/certificate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if crt is not None:
        body["crt"] = crt
    if descr is not None:
        body["descr"] = descr
    if prv is not None:
        body["prv"] = prv
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/system/certificate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_certificate(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/certificate

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/certificate. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/system/certificate",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_certificate_generate(
    caref: str,
    descr: str,
    digest_alg: str,
    dn_commonname: str,
    keytype: str,
    confirm: bool = False,
    dn_city: str | None = None,
    dn_country: str | None = None,
    dn_dns_sans: list[str] | None = None,
    dn_email_sans: list[str] | None = None,
    dn_ip_sans: list[str] | None = None,
    dn_organization: str | None = None,
    dn_organizationalunit: str | None = None,
    dn_state: str | None = None,
    dn_uri_sans: list[str] | None = None,
    ecname: str | None = None,
    keylen: int | None = None,
    lifetime: int | None = 3650,
    prv: str | None = None,
    type_: str | None = 'user',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate/generate

    caref: The certificate authority to use as the parent for this certificate.
    descr: The descriptive name for this certificate.
    digest_alg: The digest method used when the certificate is signed.
    dn_commonname: The common name of the certificate.
    keytype: The type of key pair to generate. Valid values: ['RSA', 'ECDSA']
    dn_city: The city of the certificate.
    dn_country: The country of the certificate.
    dn_dns_sans: The DNS Subject Alternative Names (SANs) for the certificate.
    dn_email_sans: The Email Subject Alternative Names (SANs) for the certificate.
    dn_ip_sans: The IP Subject Alternative Names (SANs) for the certificate.
    dn_organization: The organization of the certificate.
    dn_organizationalunit: The organizational unit of the certificate.
    dn_state: The state/province of the certificate.
    dn_uri_sans: The URI Subject Alternative Names (SANs) for the certificate.
    ecname: The name of the elliptic curve to use for the ECDSA key pair.This field is only available when the following conditions are met:- `keytype` must be equal to `'ECDSA'`
    keylen: The length of the RSA key pair to generate.This field is only available when the following conditions are met:- `keytype` must be equal to `'RSA'` Valid values: [1024, 2048, 3072, 4096, 6144, 7680, 8192, 15360, 16384]
    lifetime: The number of days the certificate is valid for.
    prv: The X509 private key string.
    type_: The type of certificate to generate. Valid values: ['server', 'user']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate/generate. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if descr is not None:
        body["descr"] = descr
    if digest_alg is not None:
        body["digest_alg"] = digest_alg
    if dn_commonname is not None:
        body["dn_commonname"] = dn_commonname
    if keytype is not None:
        body["keytype"] = keytype
    if dn_city is not None:
        body["dn_city"] = dn_city
    if dn_country is not None:
        body["dn_country"] = dn_country
    if dn_dns_sans is not None:
        body["dn_dns_sans"] = dn_dns_sans
    if dn_email_sans is not None:
        body["dn_email_sans"] = dn_email_sans
    if dn_ip_sans is not None:
        body["dn_ip_sans"] = dn_ip_sans
    if dn_organization is not None:
        body["dn_organization"] = dn_organization
    if dn_organizationalunit is not None:
        body["dn_organizationalunit"] = dn_organizationalunit
    if dn_state is not None:
        body["dn_state"] = dn_state
    if dn_uri_sans is not None:
        body["dn_uri_sans"] = dn_uri_sans
    if ecname is not None:
        body["ecname"] = ecname
    if keylen is not None:
        body["keylen"] = keylen
    if lifetime is not None:
        body["lifetime"] = lifetime
    if prv is not None:
        body["prv"] = prv
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/system/certificate/generate",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_certificate_pkcs12_export(
    certref: str,
    confirm: bool = False,
    encryption: str | None = 'high',
    passphrase: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate/pkcs12/export

    certref: The Certificate to export as a PKCS12 file.
    encryption: The level of encryption to use when exporting the PKCS#12 archive. Valid values: ['high', 'low', 'legacy']
    passphrase: The passphrase to use when exporting the PKCS#12 archive. Leave empty for no passphrase.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate/pkcs12/export. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if certref is not None:
        body["certref"] = certref
    if encryption is not None:
        body["encryption"] = encryption
    if passphrase is not None:
        body["passphrase"] = passphrase
    return await _client.request(
        "POST",
        "/api/v2/system/certificate/pkcs12/export",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_certificate_renew(
    certref: str,
    confirm: bool = False,
    reusekey: bool | None = True,
    reuseserial: bool | None = True,
    strictsecurity: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate/renew

    certref: The `refid` of the Certificate to renew.
    reusekey: Reuses the existing private key when renewing the certificate.
    reuseserial: Reuses the existing serial number when renewing the certificate.
    strictsecurity: Enforces strict security measures when renewing the certificate.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate/renew. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if certref is not None:
        body["certref"] = certref
    if reusekey is not None:
        body["reusekey"] = reusekey
    if reuseserial is not None:
        body["reuseserial"] = reuseserial
    if strictsecurity is not None:
        body["strictsecurity"] = strictsecurity
    return await _client.request(
        "POST",
        "/api/v2/system/certificate/renew",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_certificate_signing_request(
    descr: str,
    digest_alg: str,
    dn_commonname: str,
    keytype: str,
    confirm: bool = False,
    dn_city: str | None = None,
    dn_country: str | None = None,
    dn_dns_sans: list[str] | None = None,
    dn_email_sans: list[str] | None = None,
    dn_ip_sans: list[str] | None = None,
    dn_organization: str | None = None,
    dn_organizationalunit: str | None = None,
    dn_state: str | None = None,
    dn_uri_sans: list[str] | None = None,
    ecname: str | None = None,
    keylen: int | None = None,
    lifetime: int | None = 3650,
    type_: str | None = 'user',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate/signing_request

    descr: The descriptive name for this certificate.
    digest_alg: The digest method used when the certificate is signed.
    dn_commonname: The common name of the certificate.
    keytype: The type of key pair to generate. Valid values: ['RSA', 'ECDSA']
    dn_city: The city of the certificate.
    dn_country: The country of the certificate.
    dn_dns_sans: The DNS Subject Alternative Names (SANs) for the certificate.
    dn_email_sans: The Email Subject Alternative Names (SANs) for the certificate.
    dn_ip_sans: The IP Subject Alternative Names (SANs) for the certificate.
    dn_organization: The organization of the certificate.
    dn_organizationalunit: The organizational unit of the certificate.
    dn_state: The state/province of the certificate.
    dn_uri_sans: The URI Subject Alternative Names (SANs) for the certificate.
    ecname: The name of the elliptic curve to use for the ECDSA key pair.This field is only available when the following conditions are met:- `keytype` must be equal to `'ECDSA'`
    keylen: The length of the RSA key pair to generate.This field is only available when the following conditions are met:- `keytype` must be equal to `'RSA'` Valid values: [1024, 2048, 3072, 4096, 6144, 7680, 8192, 15360, 16384]
    lifetime: The number of days the certificate is valid for.
    type_: The type of certificate to generate. Valid values: ['server', 'user']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate/signing_request. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if descr is not None:
        body["descr"] = descr
    if digest_alg is not None:
        body["digest_alg"] = digest_alg
    if dn_commonname is not None:
        body["dn_commonname"] = dn_commonname
    if keytype is not None:
        body["keytype"] = keytype
    if dn_city is not None:
        body["dn_city"] = dn_city
    if dn_country is not None:
        body["dn_country"] = dn_country
    if dn_dns_sans is not None:
        body["dn_dns_sans"] = dn_dns_sans
    if dn_email_sans is not None:
        body["dn_email_sans"] = dn_email_sans
    if dn_ip_sans is not None:
        body["dn_ip_sans"] = dn_ip_sans
    if dn_organization is not None:
        body["dn_organization"] = dn_organization
    if dn_organizationalunit is not None:
        body["dn_organizationalunit"] = dn_organizationalunit
    if dn_state is not None:
        body["dn_state"] = dn_state
    if dn_uri_sans is not None:
        body["dn_uri_sans"] = dn_uri_sans
    if ecname is not None:
        body["ecname"] = ecname
    if keylen is not None:
        body["keylen"] = keylen
    if lifetime is not None:
        body["lifetime"] = lifetime
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/system/certificate/signing_request",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_certificate_signing_request_sign(
    caref: str,
    csr: str,
    descr: str,
    digest_alg: str,
    confirm: bool = False,
    dn_dns_sans: list[str] | None = None,
    dn_email_sans: list[str] | None = None,
    dn_ip_sans: list[str] | None = None,
    dn_uri_sans: list[str] | None = None,
    lifetime: int | None = 3650,
    prv: str | None = None,
    type_: str | None = 'user',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/certificate/signing_request/sign

    caref: The certificate authority to sign the certificate with.
    csr: The X509 certificate signing request to sign.
    descr: The descriptive name for this certificate.
    digest_alg: The digest method used when the certificate is signed.
    dn_dns_sans: The DNS Subject Alternative Names (SANs) for the certificate.
    dn_email_sans: The Email Subject Alternative Names (SANs) for the certificate.
    dn_ip_sans: The IP Subject Alternative Names (SANs) for the certificate.
    dn_uri_sans: The URI Subject Alternative Names (SANs) for the certificate.
    lifetime: The number of days the certificate is valid for.
    prv: The X509 private key string.
    type_: The type of certificate to generate. Valid values: ['server', 'user']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/certificate/signing_request/sign. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if csr is not None:
        body["csr"] = csr
    if descr is not None:
        body["descr"] = descr
    if digest_alg is not None:
        body["digest_alg"] = digest_alg
    if dn_dns_sans is not None:
        body["dn_dns_sans"] = dn_dns_sans
    if dn_email_sans is not None:
        body["dn_email_sans"] = dn_email_sans
    if dn_ip_sans is not None:
        body["dn_ip_sans"] = dn_ip_sans
    if dn_uri_sans is not None:
        body["dn_uri_sans"] = dn_uri_sans
    if lifetime is not None:
        body["lifetime"] = lifetime
    if prv is not None:
        body["prv"] = prv
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "POST",
        "/api/v2/system/certificate/signing_request/sign",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_system_certificates(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/certificates

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_system_certificates(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/certificates

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/certificates. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/certificates",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_console(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/console
    """
    return await _client.request(
        "GET",
        "/api/v2/system/console",
    )


@mcp.tool()
async def pfsense_update_system_console(
    confirm: bool = False,
    passwd_protect_console: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/console

    passwd_protect_console: Enables or disables password protecting the console.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/console. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if passwd_protect_console is not None:
        body["passwd_protect_console"] = passwd_protect_console
    return await _client.request(
        "PATCH",
        "/api/v2/system/console",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_dns(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/dns
    """
    return await _client.request(
        "GET",
        "/api/v2/system/dns",
    )


@mcp.tool()
async def pfsense_update_system_dns(
    confirm: bool = False,
    dnsallowoverride: bool | None = None,
    dnslocalhost: str | None = None,
    dnsserver: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/dns

    dnsallowoverride: Allow DNS servers to be overwritten by DHCP on WAN interfaces.
    dnslocalhost: Use local DNS server (DNS Resover or DNS Forwarder) as the primary DNS, or use only remote DNS servers specified in `dnsserver`. Set to `null` to use local DNS server as the primary and remote DNS servers as backup. Valid values: ['local', 'remote']
    dnsserver: The remote DNS server IPv4 or IPv6 addresses.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/dns. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if dnsallowoverride is not None:
        body["dnsallowoverride"] = dnsallowoverride
    if dnslocalhost is not None:
        body["dnslocalhost"] = dnslocalhost
    if dnsserver is not None:
        body["dnsserver"] = dnsserver
    return await _client.request(
        "PATCH",
        "/api/v2/system/dns",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_hostname(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/hostname
    """
    return await _client.request(
        "GET",
        "/api/v2/system/hostname",
    )


@mcp.tool()
async def pfsense_update_system_hostname(
    domain: str,
    hostname: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/hostname

    domain: The domain portion of the FQDN to assign to this system.
    hostname: The hostname portion of the FQDN to assign to this system.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/hostname. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if domain is not None:
        body["domain"] = domain
    if hostname is not None:
        body["hostname"] = hostname
    return await _client.request(
        "PATCH",
        "/api/v2/system/hostname",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_system_notifications_email_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/notifications/email_settings
    """
    return await _client.request(
        "GET",
        "/api/v2/system/notifications/email_settings",
    )


@mcp.tool()
async def pfsense_update_system_notifications_email_settings(
    confirm: bool = False,
    authentication_mechanism: str | None = None,
    disable: bool | None = None,
    fromaddress: str | None = None,
    ipaddress: str | None = None,
    notifyemailaddress: str | None = None,
    password: str | None = None,
    port: str | None = None,
    ssl: bool | None = None,
    sslvalidate: bool | None = None,
    timeout: int | None = None,
    username: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/notifications/email_settings

    authentication_mechanism: The authentication mechanism to use for the SMTP connection. Valid values: ['PLAIN', 'LOGIN']
    disable: Disables SMTP notifications.
    fromaddress: The email address to use as the "From" address in notifications.
    ipaddress: The IP address or hostname of the SMTP server.
    notifyemailaddress: The email address to send notifications to.
    password: The password to use for SMTP authentication.This field is only available when the following conditions are met:- `authentication_mechanism` must be equal to `'LOGIN'`
    port: The port number of the SMTP server. Valid options are: a TCP/UDP port number
    ssl: Enables or disables SSL/TLS for the SMTP connection.
    sslvalidate: Enables or disables SSL/TLS certificate validation for the SMTP connection.
    timeout: The timeout (in seconds) for the SMTP connection.
    username: The username to use for SMTP authentication.This field is only available when the following conditions are met:- `authentication_mechanism` must be equal to `'LOGIN'`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/notifications/email_settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if authentication_mechanism is not None:
        body["authentication_mechanism"] = authentication_mechanism
    if disable is not None:
        body["disable"] = disable
    if fromaddress is not None:
        body["fromaddress"] = fromaddress
    if ipaddress is not None:
        body["ipaddress"] = ipaddress
    if notifyemailaddress is not None:
        body["notifyemailaddress"] = notifyemailaddress
    if password is not None:
        body["password"] = password
    if port is not None:
        body["port"] = port
    if ssl is not None:
        body["ssl"] = ssl
    if sslvalidate is not None:
        body["sslvalidate"] = sslvalidate
    if timeout is not None:
        body["timeout"] = timeout
    if username is not None:
        body["username"] = username
    return await _client.request(
        "PATCH",
        "/api/v2/system/notifications/email_settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_system_package_available(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/package/available

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/package/available",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_package(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/package

    id: The ID of the object to target. NOTE: The id is an integer array index (0, 1, 2, ...), not a package name string.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/package",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_package(
    name: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/package

    name: The name of the pfSense package.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/package. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    return await _client.request(
        "POST",
        "/api/v2/system/package",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_package(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/package

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/package. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/system/package",
        params=params,
    )


@mcp.tool()
async def pfsense_list_system_packages(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/packages

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/packages",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_system_packages(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/packages

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/packages. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/packages",
        params=params,
    )


@mcp.tool()
async def pfsense_list_system_restapi_access_list(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/restapi/access_list

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/restapi/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_system_restapi_access_list(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/system/restapi/access_list

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/system/restapi/access_list. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/system/restapi/access_list",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_restapi_access_list(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/restapi/access_list

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/restapi/access_list. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/restapi/access_list",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_restapi_access_list_entry(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/restapi/access_list/entry

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/restapi/access_list/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_restapi_access_list_entry(
    network: str,
    confirm: bool = False,
    descr: str | None = None,
    sched: str | None = None,
    type_: str | None = 'allow',
    users: list[str] | None = None,
    weight: int | None = 1,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/restapi/access_list/entry

    network: The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.
    descr: A description of this access list entry. This field is optional.
    sched: The firewall schedule that this entry will use. This entry will only be active during the times specified in the schedule. Leave empty to apply this entry at all times.
    type_: The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks. Valid values: ['allow', 'deny']
    users: The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.
    weight: The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/restapi/access_list/entry. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if network is not None:
        body["network"] = network
    if descr is not None:
        body["descr"] = descr
    if sched is not None:
        body["sched"] = sched
    if type_ is not None:
        body["type"] = type_
    if users is not None:
        body["users"] = users
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "POST",
        "/api/v2/system/restapi/access_list/entry",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_restapi_access_list_entry(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    network: str | None = None,
    sched: str | None = None,
    type_: str | None = None,
    users: list[str] | None = None,
    weight: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/restapi/access_list/entry

    id: The ID of the object or resource to interact with.
    descr: A description of this access list entry. This field is optional.
    network: The network (in CIDR notation) that this entry applies to. Clients interacting with the REST API from this network will be affected by this entry.
    sched: The firewall schedule that this entry will use. This entry will only be active during the times specified in the schedule. Leave empty to apply this entry at all times.
    type_: The type of access this entry provides. "allow" entries permit access to the REST API from the specified networks. "deny" entries block access to the REST API from the specified networks. Valid values: ['allow', 'deny']
    users: The users that this entry applies to. Only users in this list will be affected by this entry. Leave empty if this entry should apply to all users.
    weight: The weight of this entry. Entries with lower weights are evaluated first. If multiple entries match a request, the entry with the lowest weight will be applied.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/restapi/access_list/entry. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if network is not None:
        body["network"] = network
    if sched is not None:
        body["sched"] = sched
    if type_ is not None:
        body["type"] = type_
    if users is not None:
        body["users"] = users
    if weight is not None:
        body["weight"] = weight
    return await _client.request(
        "PATCH",
        "/api/v2/system/restapi/access_list/entry",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_restapi_access_list_entry(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/restapi/access_list/entry

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/restapi/access_list/entry. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/system/restapi/access_list/entry",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_restapi_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/restapi/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/system/restapi/settings",
    )


@mcp.tool()
async def pfsense_update_system_restapi_settings(
    confirm: bool = False,
    allow_pre_releases: bool | None = None,
    allowed_interfaces: list[str] | None = None,
    auth_methods: list[str] | None = None,
    enabled: bool | None = None,
    expose_sensitive_fields: bool | None = None,
    ha_sync: bool | None = None,
    ha_sync_hosts: list[str] | None = None,
    ha_sync_password: str | None = None,
    ha_sync_username: str | None = None,
    ha_sync_validate_certs: bool | None = None,
    hateoas: bool | None = None,
    jwt_exp: int | None = None,
    keep_backup: bool | None = None,
    log_level: str | None = None,
    log_successful_auth: bool | None = None,
    login_protection: bool | None = None,
    override_sensitive_fields: list[str] | None = None,
    read_only: bool | None = None,
    represent_interfaces_as: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/restapi/settings

    allow_pre_releases: Enables or disables displaying pre-releases in available API updates. Pre-releases contain fixes and features that are currently under development and may not be fully stable. Use of pre-release versions is at your own risk.
    allowed_interfaces: Sets the interfaces allowed to accept incoming API calls.
    auth_methods: Sets the API authentication methods allowed to authenticate API calls.
    enabled: Enables or disables the API. If set to `false`, the API will no longer respond to API requests and can only be re-enabled via webConfigurator.
    expose_sensitive_fields: Enables or disables exposing sensitive fields in API responses. When enabled, sensitive fields such as passwords, private keys, and other sensitive data will be included in API responses.
    ha_sync: Enables or disables syncing API settings to HA peers. When enabled, API settings from this host will automatically be synced to any hosts defined in `ha_sync_hosts`.
    ha_sync_hosts: Set a list of IP addresses or hostnames to sync API settings to.
    ha_sync_password: Sets the password to use when authenticating for HA sync processes. This must be the password for the user defined in `ha_sync_username` and must be the same on all hosts defined in `ha_sync_hosts`.
    ha_sync_username: Sets the username to use when authenticating for HA sync processes. This user must be the present on all hosts defined in `ha_sync_hosts`.
    ha_sync_validate_certs: Enables or disables certificate validation when syncing API configurations to HA sync peers. If enabled, all hosts defined in `ha_sync_hosts` must have their webConfigurator configured with a certificate trusted by this system. It is strongly recommended this be enabled at all times to help mitigate Man-in-the-Middle attacks.
    hateoas: Enables or disables HATEOAS. Enabling HATEOAS will allow the API to include links to related resources in API responses. This is primarily useful for frontend web applications and self-navigating client scripts that integrate with HAL standards. Enabling HATEOAS may increase API response times, especially on systems with large configurations.
    jwt_exp: Sets the amount of time (in seconds) JWTs are valid for.
    keep_backup: Enables or disables keeping a persistent backup of the API configuration that can be used to restore the API configuration after package and systems updates.
    log_level: Sets the log level for API logging. The log level determines the minimum severity of messages that should be logged. Valid values: ['LOG_DEBUG', 'LOG_INFO', 'LOG_NOTICE', 'LOG_WARNING', 'LOG_ERR', 'LOG_CRIT', 'LOG_ALERT', 'LOG_EMERG']
    log_successful_auth: Enables or disables logging of API authentication attempts that are successful. By default, only failed API authentication attempts are logged to prevent flooding the authentication logs. This field is only applicable when the API `login_protection` setting is enabled.
    login_protection: Enables or disables Login Protection for API authentication. When enabled, Login Protection will monitor API attempts and temporarily block clients who fail API authentication too many times within a period of time. When disabled, Login Protection will not monitor API authentication but will continue to monitor webConfigurator and SSH logins (if configured). Login Protection can be configured globally in System > Advanced.
    override_sensitive_fields: Specifies a list of fields (formatted as ModelName:FieldName) that should have their sensitive attribute overridden. Fields selected here will not be considered sensitive and will be included in API responses regardless of the `expose_sensitive_fields` setting.This field is only available when the following conditions are met:- `expose_sensitive_fields` must be equal to `false`
    read_only: Enables or disables read-only API access. If enabled, the API will only respond to GET requests and can only be disabled via webConfigurator.
    represent_interfaces_as: Specifies how the API should represent interface names. Use `descr` to represent interface objects by their description name, use `id` to represent interface objects by their internal pfSense ID (e.g. wan, lan, opt1), or use `if` to represent interface objects by their real interface name (e.g. em0, igb1, bxe3). Valid values: ['descr', 'id', 'if']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/restapi/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if allow_pre_releases is not None:
        body["allow_pre_releases"] = allow_pre_releases
    if allowed_interfaces is not None:
        body["allowed_interfaces"] = allowed_interfaces
    if auth_methods is not None:
        body["auth_methods"] = auth_methods
    if enabled is not None:
        body["enabled"] = enabled
    if expose_sensitive_fields is not None:
        body["expose_sensitive_fields"] = expose_sensitive_fields
    if ha_sync is not None:
        body["ha_sync"] = ha_sync
    if ha_sync_hosts is not None:
        body["ha_sync_hosts"] = ha_sync_hosts
    if ha_sync_password is not None:
        body["ha_sync_password"] = ha_sync_password
    if ha_sync_username is not None:
        body["ha_sync_username"] = ha_sync_username
    if ha_sync_validate_certs is not None:
        body["ha_sync_validate_certs"] = ha_sync_validate_certs
    if hateoas is not None:
        body["hateoas"] = hateoas
    if jwt_exp is not None:
        body["jwt_exp"] = jwt_exp
    if keep_backup is not None:
        body["keep_backup"] = keep_backup
    if log_level is not None:
        body["log_level"] = log_level
    if log_successful_auth is not None:
        body["log_successful_auth"] = log_successful_auth
    if login_protection is not None:
        body["login_protection"] = login_protection
    if override_sensitive_fields is not None:
        body["override_sensitive_fields"] = override_sensitive_fields
    if read_only is not None:
        body["read_only"] = read_only
    if represent_interfaces_as is not None:
        body["represent_interfaces_as"] = represent_interfaces_as
    return await _client.request(
        "PATCH",
        "/api/v2/system/restapi/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_create_system_restapi_settings_sync(
    sync_data: str,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/restapi/settings/sync

    WARNING: This endpoint requires HTTP BasicAuth (username:password).
    It does NOT accept API key or JWT auth. Will return 401 via MCP.

    sync_data: The serialized REST API settings data to be synced.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/restapi/settings/sync. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if sync_data is not None:
        body["sync_data"] = sync_data
    return await _client.request(
        "POST",
        "/api/v2/system/restapi/settings/sync",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_restapi_version(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/restapi/version
    """
    return await _client.request(
        "GET",
        "/api/v2/system/restapi/version",
    )


@mcp.tool()
async def pfsense_update_system_restapi_version(
    confirm: bool = False,
    install_version: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/restapi/version

    install_version: Set the API version to update or rollback to.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/restapi/version. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if install_version is not None:
        body["install_version"] = install_version
    return await _client.request(
        "PATCH",
        "/api/v2/system/restapi/version",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_timezone(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/timezone
    """
    return await _client.request(
        "GET",
        "/api/v2/system/timezone",
    )


@mcp.tool()
async def pfsense_update_system_timezone(
    confirm: bool = False,
    timezone: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/timezone

    timezone: Set geographic region name (Continent/Location) to determine the timezone for the firewall.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/timezone. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if timezone is not None:
        body["timezone"] = timezone
    return await _client.request(
        "PATCH",
        "/api/v2/system/timezone",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_system_tunable(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/tunable

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/system/tunable",
        params=params,
    )


@mcp.tool()
async def pfsense_create_system_tunable(
    tunable: str,
    value: str,
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/system/tunable

    tunable: The name of the tunable to set.
    value: The value to assign this tunable.
    descr: A description for this tunable.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/system/tunable. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if tunable is not None:
        body["tunable"] = tunable
    if value is not None:
        body["value"] = value
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/system/tunable",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_system_tunable(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    tunable: str | None = None,
    value: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/tunable

    id: The ID of the object or resource to interact with.
    descr: A description for this tunable.
    tunable: The name of the tunable to set.
    value: The value to assign this tunable.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/tunable. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if tunable is not None:
        body["tunable"] = tunable
    if value is not None:
        body["value"] = value
    return await _client.request(
        "PATCH",
        "/api/v2/system/tunable",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_tunable(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/tunable

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/tunable. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/system/tunable",
        params=params,
    )


@mcp.tool()
async def pfsense_list_system_tunables(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/tunables

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/system/tunables",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_system_tunables(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/system/tunables

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/system/tunables. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/system/tunables",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_system_tunables(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/system/tunables

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/system/tunables. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/system/tunables",
        params=params,
    )


@mcp.tool()
async def pfsense_get_system_version(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/version
    """
    return await _client.request(
        "GET",
        "/api/v2/system/version",
    )


@mcp.tool()
async def pfsense_get_system_web_gui_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/system/webgui/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/system/webgui/settings",
    )


@mcp.tool()
async def pfsense_update_system_web_gui_settings(
    sslcertref: str,
    confirm: bool = False,
    port: str | None = None,
    protocol: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/system/webgui/settings

    sslcertref: The SSL/TLS certificate to use for the web GUI.
    port: The port on which the web GUI listens. Valid options are: a TCP/UDP port number
    protocol: The protocol to use for the web GUI. Valid values: ['http', 'https']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/system/webgui/settings. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if sslcertref is not None:
        body["sslcertref"] = sslcertref
    if port is not None:
        body["port"] = port
    if protocol is not None:
        body["protocol"] = protocol
    return await _client.request(
        "PATCH",
        "/api/v2/system/webgui/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_user_auth_server(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/user/auth_server

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/user/auth_server",
        params=params,
    )


@mcp.tool()
async def pfsense_create_user_auth_server(
    host: str,
    name: str,
    type_: str,
    confirm: bool = False,
    ldap_allow_unauthenticated: bool | None = None,
    ldap_attr_group: str | None = None,
    ldap_attr_groupobj: str | None = None,
    ldap_attr_member: str | None = None,
    ldap_attr_user: str | None = None,
    ldap_authcn: str | None = None,
    ldap_basedn: str | None = None,
    ldap_binddn: str | None = None,
    ldap_bindpw: str | None = None,
    ldap_caref: str | None = None,
    ldap_extended_enabled: bool | None = None,
    ldap_extended_query: str | None = None,
    ldap_nostrip_at: bool | None = None,
    ldap_pam_groupdn: str | None = None,
    ldap_port: str | None = None,
    ldap_protver: int | None = None,
    ldap_rfc2307: bool | None = None,
    ldap_rfc2307_userdn: bool | None = None,
    ldap_scope: str | None = None,
    ldap_timeout: int | None = None,
    ldap_urltype: str | None = None,
    ldap_utf8: bool | None = None,
    radius_acct_port: str | None = None,
    radius_auth_port: str | None = None,
    radius_nasip_attribute: str | None = None,
    radius_protocol: str | None = None,
    radius_secret: str | None = None,
    radius_timeout: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/user/auth_server

    host: The remote IP address or hostname of the authentication server.
    name: The descriptive name for this authentication server.
    type_: The type of this authentication server. Valid values: ['ldap', 'radius']
    ldap_allow_unauthenticated: Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_group: The LDAP group attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_groupobj: The group object class for groups in RFC2307 mode.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_rfc2307` must be equal to `true`
    ldap_attr_member: The LDAP member attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_user: The LDAP user attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_authcn: The LDAP authentication container.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_basedn: The root for LDAP searches on this authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_binddn: The DN to use when binding to this authentication server. Set to `null` to bind anonymously.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_bindpw: The password to use when binding to this authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_binddn` must not be equal to `NULL`
    ldap_caref: The certificate authority used to validate the LDAP server certificate.This field is only available when the following conditions are met:- `ldap_urltype` must be one of [ starttls, encrypted ]
    ldap_extended_enabled: Enable LDAP extended queries.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_extended_query: The extended LDAP query to make during LDAP searches.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_extended_enabled` must be equal to `true`
    ldap_nostrip_at: Do not strip away parts of the username after the @ symbol.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_pam_groupdn: The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_port: The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_protver: The LDAP protocol version to use for connections to this LDAP authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: [2, 3]
    ldap_rfc2307: Enables or disable RFC2307 LDAP options.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_rfc2307_userdn: Enables or disable the use of DNs for username searches.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_rfc2307` must be equal to `true`
    ldap_scope: The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: ['one', 'subtree']
    ldap_timeout: The timeout (in seconds) for connections to the LDAP authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_urltype: The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: ['Standard TCP', 'STARTTLS Encrypt', 'SSL/TLS Encrypted']
    ldap_utf8: Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication serverThis field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    radius_acct_port: The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_auth_port: The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_nasip_attribute: The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_protocol: The RADIUS protocol to use when authenticating.This field is only available when the following conditions are met:- `type` must be equal to `'radius'` Valid values: ['MSCHAPv2', 'MSCHAPv1', 'CHAP_MD5', 'PAP']
    radius_secret: The shared secret to use when authenticating to this RADIUS server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_timeout: The timeout (in seconds) for connections to this RADIUS authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/user/auth_server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if host is not None:
        body["host"] = host
    if name is not None:
        body["name"] = name
    if type_ is not None:
        body["type"] = type_
    if ldap_allow_unauthenticated is not None:
        body["ldap_allow_unauthenticated"] = ldap_allow_unauthenticated
    if ldap_attr_group is not None:
        body["ldap_attr_group"] = ldap_attr_group
    if ldap_attr_groupobj is not None:
        body["ldap_attr_groupobj"] = ldap_attr_groupobj
    if ldap_attr_member is not None:
        body["ldap_attr_member"] = ldap_attr_member
    if ldap_attr_user is not None:
        body["ldap_attr_user"] = ldap_attr_user
    if ldap_authcn is not None:
        body["ldap_authcn"] = ldap_authcn
    if ldap_basedn is not None:
        body["ldap_basedn"] = ldap_basedn
    if ldap_binddn is not None:
        body["ldap_binddn"] = ldap_binddn
    if ldap_bindpw is not None:
        body["ldap_bindpw"] = ldap_bindpw
    if ldap_caref is not None:
        body["ldap_caref"] = ldap_caref
    if ldap_extended_enabled is not None:
        body["ldap_extended_enabled"] = ldap_extended_enabled
    if ldap_extended_query is not None:
        body["ldap_extended_query"] = ldap_extended_query
    if ldap_nostrip_at is not None:
        body["ldap_nostrip_at"] = ldap_nostrip_at
    if ldap_pam_groupdn is not None:
        body["ldap_pam_groupdn"] = ldap_pam_groupdn
    if ldap_port is not None:
        body["ldap_port"] = ldap_port
    if ldap_protver is not None:
        body["ldap_protver"] = ldap_protver
    if ldap_rfc2307 is not None:
        body["ldap_rfc2307"] = ldap_rfc2307
    if ldap_rfc2307_userdn is not None:
        body["ldap_rfc2307_userdn"] = ldap_rfc2307_userdn
    if ldap_scope is not None:
        body["ldap_scope"] = ldap_scope
    if ldap_timeout is not None:
        body["ldap_timeout"] = ldap_timeout
    if ldap_urltype is not None:
        body["ldap_urltype"] = ldap_urltype
    if ldap_utf8 is not None:
        body["ldap_utf8"] = ldap_utf8
    if radius_acct_port is not None:
        body["radius_acct_port"] = radius_acct_port
    if radius_auth_port is not None:
        body["radius_auth_port"] = radius_auth_port
    if radius_nasip_attribute is not None:
        body["radius_nasip_attribute"] = radius_nasip_attribute
    if radius_protocol is not None:
        body["radius_protocol"] = radius_protocol
    if radius_secret is not None:
        body["radius_secret"] = radius_secret
    if radius_timeout is not None:
        body["radius_timeout"] = radius_timeout
    return await _client.request(
        "POST",
        "/api/v2/user/auth_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_user_auth_server(
    id: str | int,
    confirm: bool = False,
    host: str | None = None,
    ldap_allow_unauthenticated: bool | None = None,
    ldap_attr_group: str | None = None,
    ldap_attr_groupobj: str | None = None,
    ldap_attr_member: str | None = None,
    ldap_attr_user: str | None = None,
    ldap_authcn: str | None = None,
    ldap_basedn: str | None = None,
    ldap_binddn: str | None = None,
    ldap_bindpw: str | None = None,
    ldap_caref: str | None = None,
    ldap_extended_enabled: bool | None = None,
    ldap_extended_query: str | None = None,
    ldap_nostrip_at: bool | None = None,
    ldap_pam_groupdn: str | None = None,
    ldap_port: str | None = None,
    ldap_protver: int | None = None,
    ldap_rfc2307: bool | None = None,
    ldap_rfc2307_userdn: bool | None = None,
    ldap_scope: str | None = None,
    ldap_timeout: int | None = None,
    ldap_urltype: str | None = None,
    ldap_utf8: bool | None = None,
    name: str | None = None,
    radius_acct_port: str | None = None,
    radius_auth_port: str | None = None,
    radius_nasip_attribute: str | None = None,
    radius_protocol: str | None = None,
    radius_secret: str | None = None,
    radius_timeout: int | None = None,
    type_: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/user/auth_server

    id: The ID of the object or resource to interact with.
    host: The remote IP address or hostname of the authentication server.
    ldap_allow_unauthenticated: Enables or disables unauthenticated binding. Unauthenticated binds are bind with an existing login but with an empty password. Some LDAP servers (Microsoft AD) allow this type of bind without any possibility to disable it.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_group: The LDAP group attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_groupobj: The group object class for groups in RFC2307 mode.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_rfc2307` must be equal to `true`
    ldap_attr_member: The LDAP member attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_attr_user: The LDAP user attribute.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_authcn: The LDAP authentication container.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_basedn: The root for LDAP searches on this authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_binddn: The DN to use when binding to this authentication server. Set to `null` to bind anonymously.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_bindpw: The password to use when binding to this authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_binddn` must not be equal to `NULL`
    ldap_caref: The certificate authority used to validate the LDAP server certificate.This field is only available when the following conditions are met:- `ldap_urltype` must be one of [ starttls, encrypted ]
    ldap_extended_enabled: Enable LDAP extended queries.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_extended_query: The extended LDAP query to make during LDAP searches.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_extended_enabled` must be equal to `true`
    ldap_nostrip_at: Do not strip away parts of the username after the @ symbol.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_pam_groupdn: The group DN to use for shell authentication. Users must be a member of this group and have valid posixAccount attributes to sign in.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_port: The LDAP port to connect to on this LDAP authentication server. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_protver: The LDAP protocol version to use for connections to this LDAP authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: [2, 3]
    ldap_rfc2307: Enables or disable RFC2307 LDAP options.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_rfc2307_userdn: Enables or disable the use of DNs for username searches.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`- `ldap_rfc2307` must be equal to `true`
    ldap_scope: The LDAP search scope. Use `one` to limit the scope to a single level, or `subtree` to allow the entire subtree to be searched.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: ['one', 'subtree']
    ldap_timeout: The timeout (in seconds) for connections to the LDAP authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    ldap_urltype: The encryption mode to use when connecting to this authentication server. Use `Standard TCP` for unencrypted LDAP connections, use `STARTTLS Encrypt` to start an encrypted connection via STARTTLS if it's available, or `SSL/TLS Encrypted` to only use LDAPS encrypted connections.This field is only available when the following conditions are met:- `type` must be equal to `'ldap'` Valid values: ['Standard TCP', 'STARTTLS Encrypt', 'SSL/TLS Encrypted']
    ldap_utf8: Enables or disables UTF-8 encoding LDAP parameters before sending them to this authentication serverThis field is only available when the following conditions are met:- `type` must be equal to `'ldap'`
    name: The descriptive name for this authentication server.
    radius_acct_port: The port used by RADIUS for accounting. Set to `null` to disable use of accounting services. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_auth_port: The port used by RADIUS for authentication. Set to `null` to disable use of authentication services. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_nasip_attribute: The interface whose IP will be used as the 'NAS-IP-Address' attribute during RADIUS Access-Requests. This choice will not change the interface used for contacting the RADIUS server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_protocol: The RADIUS protocol to use when authenticating.This field is only available when the following conditions are met:- `type` must be equal to `'radius'` Valid values: ['MSCHAPv2', 'MSCHAPv1', 'CHAP_MD5', 'PAP']
    radius_secret: The shared secret to use when authenticating to this RADIUS server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    radius_timeout: The timeout (in seconds) for connections to this RADIUS authentication server.This field is only available when the following conditions are met:- `type` must be equal to `'radius'`
    type_: The type of this authentication server. Valid values: ['ldap', 'radius']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/user/auth_server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if host is not None:
        body["host"] = host
    if ldap_allow_unauthenticated is not None:
        body["ldap_allow_unauthenticated"] = ldap_allow_unauthenticated
    if ldap_attr_group is not None:
        body["ldap_attr_group"] = ldap_attr_group
    if ldap_attr_groupobj is not None:
        body["ldap_attr_groupobj"] = ldap_attr_groupobj
    if ldap_attr_member is not None:
        body["ldap_attr_member"] = ldap_attr_member
    if ldap_attr_user is not None:
        body["ldap_attr_user"] = ldap_attr_user
    if ldap_authcn is not None:
        body["ldap_authcn"] = ldap_authcn
    if ldap_basedn is not None:
        body["ldap_basedn"] = ldap_basedn
    if ldap_binddn is not None:
        body["ldap_binddn"] = ldap_binddn
    if ldap_bindpw is not None:
        body["ldap_bindpw"] = ldap_bindpw
    if ldap_caref is not None:
        body["ldap_caref"] = ldap_caref
    if ldap_extended_enabled is not None:
        body["ldap_extended_enabled"] = ldap_extended_enabled
    if ldap_extended_query is not None:
        body["ldap_extended_query"] = ldap_extended_query
    if ldap_nostrip_at is not None:
        body["ldap_nostrip_at"] = ldap_nostrip_at
    if ldap_pam_groupdn is not None:
        body["ldap_pam_groupdn"] = ldap_pam_groupdn
    if ldap_port is not None:
        body["ldap_port"] = ldap_port
    if ldap_protver is not None:
        body["ldap_protver"] = ldap_protver
    if ldap_rfc2307 is not None:
        body["ldap_rfc2307"] = ldap_rfc2307
    if ldap_rfc2307_userdn is not None:
        body["ldap_rfc2307_userdn"] = ldap_rfc2307_userdn
    if ldap_scope is not None:
        body["ldap_scope"] = ldap_scope
    if ldap_timeout is not None:
        body["ldap_timeout"] = ldap_timeout
    if ldap_urltype is not None:
        body["ldap_urltype"] = ldap_urltype
    if ldap_utf8 is not None:
        body["ldap_utf8"] = ldap_utf8
    if name is not None:
        body["name"] = name
    if radius_acct_port is not None:
        body["radius_acct_port"] = radius_acct_port
    if radius_auth_port is not None:
        body["radius_auth_port"] = radius_auth_port
    if radius_nasip_attribute is not None:
        body["radius_nasip_attribute"] = radius_nasip_attribute
    if radius_protocol is not None:
        body["radius_protocol"] = radius_protocol
    if radius_secret is not None:
        body["radius_secret"] = radius_secret
    if radius_timeout is not None:
        body["radius_timeout"] = radius_timeout
    if type_ is not None:
        body["type"] = type_
    return await _client.request(
        "PATCH",
        "/api/v2/user/auth_server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_user_auth_server(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/user/auth_server

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/user/auth_server. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/user/auth_server",
        params=params,
    )


@mcp.tool()
async def pfsense_list_user_auth_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/user/auth_servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/user/auth_servers",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_user_auth_servers(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/user/auth_servers

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/user/auth_servers. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/user/auth_servers",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_user_auth_servers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/user/auth_servers

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/user/auth_servers. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/user/auth_servers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_user(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/user

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/user",
        params=params,
    )


@mcp.tool()
async def pfsense_create_user(
    name: str,
    password: str,
    confirm: bool = False,
    authorizedkeys: str | None = None,
    cert: list[str] | None = None,
    descr: str | None = None,
    disabled: bool | None = None,
    expires: str | None = None,
    ipsecpsk: str | None = None,
    priv: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/user

    name: The username of this local user.
    password: The password of this local user.
    authorizedkeys: The SSH authorized keys to assign this user.
    cert: The user certificates to assign this user. Items must be existing certificate `refid`s.
    descr: The full descriptive name for this local user.
    disabled: Disable this local user.
    expires: The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration
    ipsecpsk: The IPsec pre-shared key to assign this user.
    priv: The privileges assigned to this local user.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/user. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if password is not None:
        body["password"] = password
    if authorizedkeys is not None:
        body["authorizedkeys"] = authorizedkeys
    if cert is not None:
        body["cert"] = cert
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if expires is not None:
        body["expires"] = expires
    if ipsecpsk is not None:
        body["ipsecpsk"] = ipsecpsk
    if priv is not None:
        body["priv"] = priv
    return await _client.request(
        "POST",
        "/api/v2/user",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_user(
    id: str | int,
    confirm: bool = False,
    authorizedkeys: str | None = None,
    cert: list[str] | None = None,
    descr: str | None = None,
    disabled: bool | None = None,
    expires: str | None = None,
    ipsecpsk: str | None = None,
    name: str | None = None,
    password: str | None = None,
    priv: list[str] | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/user

    id: The ID of the object or resource to interact with.
    authorizedkeys: The SSH authorized keys to assign this user.
    cert: The user certificates to assign this user. Items must be existing certificate `refid`s.
    descr: The full descriptive name for this local user.
    disabled: Disable this local user.
    expires: The expiration date for this user in mm/dd/YYYY format. Use empty string for no expiration
    ipsecpsk: The IPsec pre-shared key to assign this user.
    name: The username of this local user.
    password: The password of this local user.
    priv: The privileges assigned to this local user.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/user. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if authorizedkeys is not None:
        body["authorizedkeys"] = authorizedkeys
    if cert is not None:
        body["cert"] = cert
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if expires is not None:
        body["expires"] = expires
    if ipsecpsk is not None:
        body["ipsecpsk"] = ipsecpsk
    if name is not None:
        body["name"] = name
    if password is not None:
        body["password"] = password
    if priv is not None:
        body["priv"] = priv
    return await _client.request(
        "PATCH",
        "/api/v2/user",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_user(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/user

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/user. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/user",
        params=params,
    )


@mcp.tool()
async def pfsense_get_user_group(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/user/group

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/user/group",
        params=params,
    )


@mcp.tool()
async def pfsense_create_user_group(
    name: str,
    confirm: bool = False,
    description: str | None = None,
    member: list[str] | None = None,
    priv: list[str] | None = None,
    scope: str | None = 'local',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/user/group

    name: The name for this user group.
    description: The description to assign to this user group.
    member: The local user names to assign to this user group.
    priv: The privileges to assign to this user group.
    scope: The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually. Valid values: ['local', 'remote', 'system']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/user/group. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if description is not None:
        body["description"] = description
    if member is not None:
        body["member"] = member
    if priv is not None:
        body["priv"] = priv
    if scope is not None:
        body["scope"] = scope
    return await _client.request(
        "POST",
        "/api/v2/user/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_user_group(
    id: str | int,
    confirm: bool = False,
    description: str | None = None,
    member: list[str] | None = None,
    name: str | None = None,
    priv: list[str] | None = None,
    scope: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/user/group

    id: The ID of the object or resource to interact with.
    description: The description to assign to this user group.
    member: The local user names to assign to this user group.
    name: The name for this user group.
    priv: The privileges to assign to this user group.
    scope: The scope of this user group. Use `local` for user groups that only apply to this system. use `remote` for groups that also apply to remote authentication servers. Please note the `system` scope is reserved for built-in, system-defined user groups and cannot be assigned manually. Valid values: ['local', 'remote', 'system']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/user/group. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if description is not None:
        body["description"] = description
    if member is not None:
        body["member"] = member
    if name is not None:
        body["name"] = name
    if priv is not None:
        body["priv"] = priv
    if scope is not None:
        body["scope"] = scope
    return await _client.request(
        "PATCH",
        "/api/v2/user/group",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_user_group(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/user/group

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/user/group. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/user/group",
        params=params,
    )


@mcp.tool()
async def pfsense_list_user_groups(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/user/groups

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/user/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_user_groups(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/user/groups

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/user/groups. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/user/groups",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_user_groups(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/user/groups

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/user/groups. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/user/groups",
        params=params,
    )


@mcp.tool()
async def pfsense_list_users(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/users

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/users",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_users(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/users

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/users. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/users",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpni_psec_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/apply",
    )


@mcp.tool()
async def pfsense_vpni_psec_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/ipsec/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/ipsec/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/vpn/ipsec/apply",
    )


@mcp.tool()
async def pfsense_get_vpni_psec_phase1_encryption(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase1/encryption

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase1/encryption",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpni_psec_phase1_encryption(
    dhgroup: int,
    encryption_algorithm_name: str,
    hash_algorithm: str,
    parent_id: str | int,
    confirm: bool = False,
    encryption_algorithm_keylen: int | None = None,
    prf_algorithm: str | None = 'sha256',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/ipsec/phase1/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    dhgroup: The Diffie-Hellman (DH) group to use for this P1 encryption item. Valid values: [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
    encryption_algorithm_name: The name of the encryption algorithm to use for this P1 encryption item. Valid values: ['aes', 'aes128gcm', 'aes192gcm', 'aes256gcm', 'chacha20poly1305']
    hash_algorithm: The hash algorithm to use for this P1 encryption item. Valid values: ['sha1', 'sha256', 'sha384', 'sha512', 'aesxcbc']
    parent_id: The ID of the parent this object is nested under.
    encryption_algorithm_keylen: The key length for the encryption algorithm.This field is only available when the following conditions are met:- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]
    prf_algorithm: The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled. Valid values: ['sha1', 'sha256', 'sha384', 'sha512', 'aesxcbc']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/ipsec/phase1/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if dhgroup is not None:
        body["dhgroup"] = dhgroup
    if encryption_algorithm_name is not None:
        body["encryption_algorithm_name"] = encryption_algorithm_name
    if hash_algorithm is not None:
        body["hash_algorithm"] = hash_algorithm
    if parent_id is not None:
        body["parent_id"] = parent_id
    if encryption_algorithm_keylen is not None:
        body["encryption_algorithm_keylen"] = encryption_algorithm_keylen
    if prf_algorithm is not None:
        body["prf_algorithm"] = prf_algorithm
    return await _client.request(
        "POST",
        "/api/v2/vpn/ipsec/phase1/encryption",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpni_psec_phase1_encryption(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    dhgroup: int | None = None,
    encryption_algorithm_keylen: int | None = None,
    encryption_algorithm_name: str | None = None,
    hash_algorithm: str | None = None,
    prf_algorithm: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/ipsec/phase1/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    dhgroup: The Diffie-Hellman (DH) group to use for this P1 encryption item. Valid values: [1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
    encryption_algorithm_keylen: The key length for the encryption algorithm.This field is only available when the following conditions are met:- `encryption_algorithm_name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]
    encryption_algorithm_name: The name of the encryption algorithm to use for this P1 encryption item. Valid values: ['aes', 'aes128gcm', 'aes192gcm', 'aes256gcm', 'chacha20poly1305']
    hash_algorithm: The hash algorithm to use for this P1 encryption item. Valid values: ['sha1', 'sha256', 'sha384', 'sha512', 'aesxcbc']
    prf_algorithm: The PRF algorithm to use for this P1 encryption item. This value has no affect unless the P1 entry has PRF enabled. Valid values: ['sha1', 'sha256', 'sha384', 'sha512', 'aesxcbc']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/ipsec/phase1/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if dhgroup is not None:
        body["dhgroup"] = dhgroup
    if encryption_algorithm_keylen is not None:
        body["encryption_algorithm_keylen"] = encryption_algorithm_keylen
    if encryption_algorithm_name is not None:
        body["encryption_algorithm_name"] = encryption_algorithm_name
    if hash_algorithm is not None:
        body["hash_algorithm"] = hash_algorithm
    if prf_algorithm is not None:
        body["prf_algorithm"] = prf_algorithm
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/ipsec/phase1/encryption",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase1_encryption(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase1/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase1/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase1/encryption",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpni_psec_phase1_encryptions(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase1/encryptions

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase1/encryptions",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase1_encryptions(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase1/encryptions

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase1/encryptions. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase1/encryptions",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpni_psec_phase1(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase1

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase1",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpni_psec_phase1(
    authentication_method: str,
    encryption: list[dict[str, Any]],
    iketype: str,
    interface: str,
    myid_type: str,
    peerid_type: str,
    protocol: str,
    remote_gateway: str,
    confirm: bool = False,
    caref: str | None = None,
    certref: str | None = None,
    closeaction: str | None = None,
    descr: str | None = None,
    disabled: bool | None = None,
    dpd_delay: int | None = 10,
    dpd_maxfail: int | None = 5,
    gw_duplicates: bool | None = None,
    ikeport: str | None = '500',
    lifetime: int | None = 28800,
    mobike: bool | None = None,
    mode: str | None = None,
    myid_data: str | None = None,
    nat_traversal: str | None = 'on',
    nattport: str | None = '4500',
    peerid_data: str | None = None,
    pre_shared_key: str | None = None,
    prfselect_enable: bool | None = None,
    rand_time: int | None = 2880,
    reauth_time: int | None = None,
    rekey_time: int | None = 25920,
    splitconn: bool | None = None,
    startaction: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/ipsec/phase1

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    authentication_method: The IPsec authentication method this tunnel will use. Valid values: ['pre_shared_key', 'cert']
    encryption: The encryption algorithms supported by this P1 encryption.
    iketype: The IKE protocol version this phase 1 entry will use. Valid values: ['ikev1', 'ikev2', 'auto']
    interface: The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.
    myid_type: The identifier type used by the local end of the tunnel. Valid values: ['myaddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']
    peerid_type: The identifier type used by the remote end of the tunnel. Valid values: ['any', 'peeraddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']
    protocol: The IP version this phase 1 entry will use. Valid values: ['inet', 'inet6', 'both']
    remote_gateway: The IP address or hostname of the remote gateway.
    caref: The certificate authority to use when validating the peer certificate.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'cert'`
    certref: The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'cert'`
    closeaction: The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2) Valid values: ['', 'none', 'start', 'trap']
    descr: A description for this IPsec phase 1 entry.
    disabled: Disables this IPsec phase 1 entry.
    dpd_delay: The delay (in seconds) between sending peer acknowledgement messages.
    dpd_maxfail: The number of consecutive failures allowed before disconnecting.
    gw_duplicates: Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.
    ikeport: The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number
    lifetime: The hard child SA lifetime (in seconds) after which the child SA will be expired.
    mobike: Enables or disables the use of MOBIKE for this tunnel.
    mode: The IKEv1 negotiation mode this phase 1 entry will use.This field is only available when the following conditions are met:- `iketype` must be one of [ ikev1, auto ] Valid values: ['main', 'aggressive']
    myid_data: The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.This field is only available when the following conditions are met:- `myid_type` must not be equal to `'myaddress'`
    nat_traversal: The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls. Valid values: ['on', 'force']
    nattport: The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number
    peerid_data: The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.This field is only available when the following conditions are met:- `peerid_type` must not be one of [ any, peeraddress ]
    pre_shared_key: The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'pre_shared_key'`
    prfselect_enable: Enables or disables manual Pseudo-Random Function (PRF) selection.
    rand_time: A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.
    reauth_time: The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.
    rekey_time: The amount of time (in seconds) before an child SA establishes new keys.
    splitconn: Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.
    startaction: The option used to force specific initiation/responder behavior for child SA (P2) entries. Valid values: ['', 'none', 'start', 'trap']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/ipsec/phase1. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if authentication_method is not None:
        body["authentication_method"] = authentication_method
    if encryption is not None:
        body["encryption"] = encryption
    if iketype is not None:
        body["iketype"] = iketype
    if interface is not None:
        body["interface"] = interface
    if myid_type is not None:
        body["myid_type"] = myid_type
    if peerid_type is not None:
        body["peerid_type"] = peerid_type
    if protocol is not None:
        body["protocol"] = protocol
    if remote_gateway is not None:
        body["remote_gateway"] = remote_gateway
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if closeaction is not None:
        body["closeaction"] = closeaction
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if dpd_delay is not None:
        body["dpd_delay"] = dpd_delay
    if dpd_maxfail is not None:
        body["dpd_maxfail"] = dpd_maxfail
    if gw_duplicates is not None:
        body["gw_duplicates"] = gw_duplicates
    if ikeport is not None:
        body["ikeport"] = ikeport
    if lifetime is not None:
        body["lifetime"] = lifetime
    if mobike is not None:
        body["mobike"] = mobike
    if mode is not None:
        body["mode"] = mode
    if myid_data is not None:
        body["myid_data"] = myid_data
    if nat_traversal is not None:
        body["nat_traversal"] = nat_traversal
    if nattport is not None:
        body["nattport"] = nattport
    if peerid_data is not None:
        body["peerid_data"] = peerid_data
    if pre_shared_key is not None:
        body["pre_shared_key"] = pre_shared_key
    if prfselect_enable is not None:
        body["prfselect_enable"] = prfselect_enable
    if rand_time is not None:
        body["rand_time"] = rand_time
    if reauth_time is not None:
        body["reauth_time"] = reauth_time
    if rekey_time is not None:
        body["rekey_time"] = rekey_time
    if splitconn is not None:
        body["splitconn"] = splitconn
    if startaction is not None:
        body["startaction"] = startaction
    return await _client.request(
        "POST",
        "/api/v2/vpn/ipsec/phase1",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpni_psec_phase1(
    id: str | int,
    confirm: bool = False,
    authentication_method: str | None = None,
    caref: str | None = None,
    certref: str | None = None,
    closeaction: str | None = None,
    descr: str | None = None,
    disabled: bool | None = None,
    dpd_delay: int | None = None,
    dpd_maxfail: int | None = None,
    encryption: list[dict[str, Any]] | None = None,
    gw_duplicates: bool | None = None,
    ikeport: str | None = None,
    iketype: str | None = None,
    interface: str | None = None,
    lifetime: int | None = None,
    mobike: bool | None = None,
    mode: str | None = None,
    myid_data: str | None = None,
    myid_type: str | None = None,
    nat_traversal: str | None = None,
    nattport: str | None = None,
    peerid_data: str | None = None,
    peerid_type: str | None = None,
    pre_shared_key: str | None = None,
    prfselect_enable: bool | None = None,
    protocol: str | None = None,
    rand_time: int | None = None,
    reauth_time: int | None = None,
    rekey_time: int | None = None,
    remote_gateway: str | None = None,
    splitconn: bool | None = None,
    startaction: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/ipsec/phase1

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    authentication_method: The IPsec authentication method this tunnel will use. Valid values: ['pre_shared_key', 'cert']
    caref: The certificate authority to use when validating the peer certificate.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'cert'`
    certref: The certificate which identifies this system. The certificate must have at least one non-wildcard SAN.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'cert'`
    closeaction: The option used to control the behavior when the remote peer unexpectedly closes a child SA (P2) Valid values: ['', 'none', 'start', 'trap']
    descr: A description for this IPsec phase 1 entry.
    disabled: Disables this IPsec phase 1 entry.
    dpd_delay: The delay (in seconds) between sending peer acknowledgement messages.
    dpd_maxfail: The number of consecutive failures allowed before disconnecting.
    encryption: The encryption algorithms supported by this P1 encryption.
    gw_duplicates: Enables or disables the allowance of multiple phase 1 configurations with the same remote gateway endpoint.
    ikeport: The UDP port for IKE on the remote gateway. Valid options are: a TCP/UDP port number
    iketype: The IKE protocol version this phase 1 entry will use. Valid values: ['ikev1', 'ikev2', 'auto']
    interface: The interface for the local endpoint of this phase 1 entry. This should be an interface that is reachable by the remote peer.
    lifetime: The hard child SA lifetime (in seconds) after which the child SA will be expired.
    mobike: Enables or disables the use of MOBIKE for this tunnel.
    mode: The IKEv1 negotiation mode this phase 1 entry will use.This field is only available when the following conditions are met:- `iketype` must be one of [ ikev1, auto ] Valid values: ['main', 'aggressive']
    myid_data: The identifier value used by the local end of the tunnel. This must be a value that corresponds with the current `myid_type` value.This field is only available when the following conditions are met:- `myid_type` must not be equal to `'myaddress'`
    myid_type: The identifier type used by the local end of the tunnel. Valid values: ['myaddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']
    nat_traversal: The option used to enable the use of NAT-T (i.e. the encapsulation of ESP in UDP packets) if needed, which can help with clients that are behind restrictive firewalls. Valid values: ['on', 'force']
    nattport: The UDP port for NAT-T on the remote gateway. Valid options are: a TCP/UDP port number
    peerid_data: The identifier value used by the remote end of the tunnel. This must be a value that corresponds with the current `peerid_type` value.This field is only available when the following conditions are met:- `peerid_type` must not be one of [ any, peeraddress ]
    peerid_type: The identifier type used by the remote end of the tunnel. Valid values: ['any', 'peeraddress', 'address', 'fqdn', 'user_fqdn', 'asn1dn', 'keyid tag', 'dyn_dns', 'auto']
    pre_shared_key: The Pre-Shared Key (PSK) value. This key must match on both peers and should be long and random to protect the tunnel and its contents. A weak Pre-Shared Key can lead to a tunnel compromise.This field is only available when the following conditions are met:- `authentication_method` must be equal to `'pre_shared_key'`
    prfselect_enable: Enables or disables manual Pseudo-Random Function (PRF) selection.
    protocol: The IP version this phase 1 entry will use. Valid values: ['inet', 'inet6', 'both']
    rand_time: A random value up to this amount will be subtracted from the `rekey_time` to avoid simultaneous renegotiation.
    reauth_time: The amount of time (in seconds) before an child SA is torn down and recreated from scratch, including authentication.
    rekey_time: The amount of time (in seconds) before an child SA establishes new keys.
    remote_gateway: The IP address or hostname of the remote gateway.
    splitconn: Enables or disables the use split connection entries with multiple phase 2 configurations. Required for remote endpoints that support only a single traffic selector per child SA.
    startaction: The option used to force specific initiation/responder behavior for child SA (P2) entries. Valid values: ['', 'none', 'start', 'trap']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/ipsec/phase1. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if authentication_method is not None:
        body["authentication_method"] = authentication_method
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if closeaction is not None:
        body["closeaction"] = closeaction
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if dpd_delay is not None:
        body["dpd_delay"] = dpd_delay
    if dpd_maxfail is not None:
        body["dpd_maxfail"] = dpd_maxfail
    if encryption is not None:
        body["encryption"] = encryption
    if gw_duplicates is not None:
        body["gw_duplicates"] = gw_duplicates
    if ikeport is not None:
        body["ikeport"] = ikeport
    if iketype is not None:
        body["iketype"] = iketype
    if interface is not None:
        body["interface"] = interface
    if lifetime is not None:
        body["lifetime"] = lifetime
    if mobike is not None:
        body["mobike"] = mobike
    if mode is not None:
        body["mode"] = mode
    if myid_data is not None:
        body["myid_data"] = myid_data
    if myid_type is not None:
        body["myid_type"] = myid_type
    if nat_traversal is not None:
        body["nat_traversal"] = nat_traversal
    if nattport is not None:
        body["nattport"] = nattport
    if peerid_data is not None:
        body["peerid_data"] = peerid_data
    if peerid_type is not None:
        body["peerid_type"] = peerid_type
    if pre_shared_key is not None:
        body["pre_shared_key"] = pre_shared_key
    if prfselect_enable is not None:
        body["prfselect_enable"] = prfselect_enable
    if protocol is not None:
        body["protocol"] = protocol
    if rand_time is not None:
        body["rand_time"] = rand_time
    if reauth_time is not None:
        body["reauth_time"] = reauth_time
    if rekey_time is not None:
        body["rekey_time"] = rekey_time
    if remote_gateway is not None:
        body["remote_gateway"] = remote_gateway
    if splitconn is not None:
        body["splitconn"] = splitconn
    if startaction is not None:
        body["startaction"] = startaction
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/ipsec/phase1",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase1(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase1

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase1. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase1",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpni_psec_phase1s(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase1s

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase1s",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_vpni_psec_phase1s(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/vpn/ipsec/phase1s

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/vpn/ipsec/phase1s. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/vpn/ipsec/phase1s",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase1s(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase1s

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase1s. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase1s",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpni_psec_phase2_encryption(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase2/encryption

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase2/encryption",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpni_psec_phase2_encryption(
    name: str,
    parent_id: str | int,
    confirm: bool = False,
    keylen: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/ipsec/phase2/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    name: The name of the encryption algorithm to use for this P2 encryption item. Valid values: ['aes', 'aes128gcm', 'aes192gcm', 'aes256gcm', 'chacha20poly1305']
    parent_id: The ID of the parent this object is nested under.
    keylen: The key length for the encryption algorithm.This field is only available when the following conditions are met:- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/ipsec/phase2/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if name is not None:
        body["name"] = name
    if parent_id is not None:
        body["parent_id"] = parent_id
    if keylen is not None:
        body["keylen"] = keylen
    return await _client.request(
        "POST",
        "/api/v2/vpn/ipsec/phase2/encryption",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpni_psec_phase2_encryption(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    keylen: int | None = None,
    name: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/ipsec/phase2/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    keylen: The key length for the encryption algorithm.This field is only available when the following conditions are met:- `name` must be one of [ aes, aes128gcm, aes192gcm, aes256gcm ]
    name: The name of the encryption algorithm to use for this P2 encryption item. Valid values: ['aes', 'aes128gcm', 'aes192gcm', 'aes256gcm', 'chacha20poly1305']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/ipsec/phase2/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if keylen is not None:
        body["keylen"] = keylen
    if name is not None:
        body["name"] = name
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/ipsec/phase2/encryption",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase2_encryption(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase2/encryption

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase2/encryption. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase2/encryption",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpni_psec_phase2_encryptions(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase2/encryptions

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase2/encryptions",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase2_encryptions(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase2/encryptions

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase2/encryptions. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase2/encryptions",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpni_psec_phase2(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase2

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase2",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpni_psec_phase2(
    hash_algorithm_option: list[str],
    ikeid: int,
    mode: str,
    confirm: bool = False,
    descr: str | None = None,
    disabled: bool | None = None,
    encryption_algorithm_option: list[dict[str, Any]] | None = None,
    keepalive: bool | None = None,
    lifetime: int | None = 3600,
    localid_address: str | None = None,
    localid_netbits: int | None = None,
    localid_type: str | None = None,
    natlocalid_address: str | None = None,
    natlocalid_netbits: int | None = None,
    natlocalid_type: str | None = None,
    pfsgroup: int | None = 14,
    pinghost: str | None = None,
    protocol: str | None = 'esp',
    rand_time: int | None = 360,
    rekey_time: int | None = 3240,
    remoteid_address: str | None = None,
    remoteid_netbits: int | None = None,
    remoteid_type: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/ipsec/phase2

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    hash_algorithm_option: The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided. Valid values: ['hmac_sha1', 'hmac_sha256', 'hmac_sha384', 'hmac_sha512', 'aesxcbc']. Note: use hmac_ prefix (not plain sha256).
    ikeid: The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.
    mode: The IPsec phase 2 mode this entry will use. Valid values: ['tunnel', 'tunnel6', 'transport', 'vti']
    descr: A description for this IPsec phase 2 entry.
    disabled: Disables this IPsec phase 2 entry.
    encryption_algorithm_option: The encryption algorithms to be used by this phase 2 entry.This field is only available when the following conditions are met:- `protocol` must be equal to `'esp'`
    keepalive: Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.
    lifetime: The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.
    localid_address: The local network IP component of this IPsec security association.This field is only available when the following conditions are met:- `localid_type` must be one of [ address, network ]
    localid_netbits: The subnet bits of the `localid_address` network.This field is only available when the following conditions are met:- `localid_type` must be equal to `'network'`
    localid_type: The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be equal to `'transport'`
    natlocalid_address: The NAT/BINAT local network IP component of this IPsec security association.This field is only available when the following conditions are met:- `natlocalid_type` must be one of [ address, network ]
    natlocalid_netbits: The subnet bits of the `natlocalid_address` network.This field is only available when the following conditions are met:- `natlocalid_type` must be equal to `'network'`
    natlocalid_type: The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be one of [ transport, vti ]
    pfsgroup: The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided. Valid values: [0, 1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
    pinghost: The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.
    protocol: the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only. Valid values: ['esp', 'ah']
    rand_time: A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.
    rekey_time: The amount of time (in seconds) before an IKE SA establishes new keys.
    remoteid_address: The remote network IP component of this IPsec security association.This field is only available when the following conditions are met:- `remoteid_type` must be one of [ address, network ]
    remoteid_netbits: The subnet bits of the `remoteid_address` network.This field is only available when the following conditions are met:- `remoteid_type` must be equal to `'network'`
    remoteid_type: The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be equal to `'transport'`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/ipsec/phase2. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if hash_algorithm_option is not None:
        body["hash_algorithm_option"] = hash_algorithm_option
    if ikeid is not None:
        body["ikeid"] = ikeid
    if mode is not None:
        body["mode"] = mode
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if encryption_algorithm_option is not None:
        body["encryption_algorithm_option"] = encryption_algorithm_option
    if keepalive is not None:
        body["keepalive"] = keepalive
    if lifetime is not None:
        body["lifetime"] = lifetime
    if localid_address is not None:
        body["localid_address"] = localid_address
    if localid_netbits is not None:
        body["localid_netbits"] = localid_netbits
    if localid_type is not None:
        body["localid_type"] = localid_type
    if natlocalid_address is not None:
        body["natlocalid_address"] = natlocalid_address
    if natlocalid_netbits is not None:
        body["natlocalid_netbits"] = natlocalid_netbits
    if natlocalid_type is not None:
        body["natlocalid_type"] = natlocalid_type
    if pfsgroup is not None:
        body["pfsgroup"] = pfsgroup
    if pinghost is not None:
        body["pinghost"] = pinghost
    if protocol is not None:
        body["protocol"] = protocol
    if rand_time is not None:
        body["rand_time"] = rand_time
    if rekey_time is not None:
        body["rekey_time"] = rekey_time
    if remoteid_address is not None:
        body["remoteid_address"] = remoteid_address
    if remoteid_netbits is not None:
        body["remoteid_netbits"] = remoteid_netbits
    if remoteid_type is not None:
        body["remoteid_type"] = remoteid_type
    return await _client.request(
        "POST",
        "/api/v2/vpn/ipsec/phase2",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpni_psec_phase2(
    id: str | int,
    confirm: bool = False,
    descr: str | None = None,
    disabled: bool | None = None,
    encryption_algorithm_option: list[dict[str, Any]] | None = None,
    hash_algorithm_option: list[str] | None = None,
    ikeid: int | None = None,
    keepalive: bool | None = None,
    lifetime: int | None = None,
    localid_address: str | None = None,
    localid_netbits: int | None = None,
    localid_type: str | None = None,
    mode: str | None = None,
    natlocalid_address: str | None = None,
    natlocalid_netbits: int | None = None,
    natlocalid_type: str | None = None,
    pfsgroup: int | None = None,
    pinghost: str | None = None,
    protocol: str | None = None,
    rand_time: int | None = None,
    rekey_time: int | None = None,
    remoteid_address: str | None = None,
    remoteid_netbits: int | None = None,
    remoteid_type: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/ipsec/phase2

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    descr: A description for this IPsec phase 2 entry.
    disabled: Disables this IPsec phase 2 entry.
    encryption_algorithm_option: The encryption algorithms to be used by this phase 2 entry.This field is only available when the following conditions are met:- `protocol` must be equal to `'esp'`
    hash_algorithm_option: The hashing algorithms used by this IPsec phase 2 entry. Note: Hash is ignored with GCM algorithms. SHA1 provides weak security and should be avoided. Valid values: ['hmac_sha1', 'hmac_sha256', 'hmac_sha384', 'hmac_sha512', 'aesxcbc']. Note: use hmac_ prefix (not plain sha256).
    ikeid: The `ikeid` of the parent IPsec phase 1 entry this IPsec phase 2 entry belongs to.
    keepalive: Enables or disables checking this P2 and initiating if disconnected; does not send traffic inside the tunnel. This check ignores the P1 option 'Child SA Start Action' and works for both VTI and tunnel mode P2s. For IKEv2 without split connections, this only needs to be enabled on one P2.
    lifetime: The hard IKE SA lifetime (in seconds) after which the IKE SA will be expired.
    localid_address: The local network IP component of this IPsec security association.This field is only available when the following conditions are met:- `localid_type` must be one of [ address, network ]
    localid_netbits: The subnet bits of the `localid_address` network.This field is only available when the following conditions are met:- `localid_type` must be equal to `'network'`
    localid_type: The local ID type to use for this phase 2 entry. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be equal to `'transport'`
    mode: The IPsec phase 2 mode this entry will use. Valid values: ['tunnel', 'tunnel6', 'transport', 'vti']
    natlocalid_address: The NAT/BINAT local network IP component of this IPsec security association.This field is only available when the following conditions are met:- `natlocalid_type` must be one of [ address, network ]
    natlocalid_netbits: The subnet bits of the `natlocalid_address` network.This field is only available when the following conditions are met:- `natlocalid_type` must be equal to `'network'`
    natlocalid_type: The NAT/BINAT translation type for this IPsec phase 2 entry. Leave as `null` if NAT/BINAT is not needed. Valid value options are: an existing interface, `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be one of [ transport, vti ]
    pfsgroup: The PFS key group this IPsec phase 2 entry should use. Note: Groups 1, 2, 5, 22, 23, and 24 provide weak security and should be avoided. Valid values: [0, 1, 2, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]
    pinghost: The IP address to send an ICMP echo request to inside the tunnel. Can trigger initiation of a tunnel mode P2, but does not trigger initiation of a VTI mode P2.
    protocol: the IPsec phase 2 proposal protocol for this entry. Encapsulating Security Payload (`esp`) performs encryption and authentication, Authentication Header (`ah`) is authentication only. Valid values: ['esp', 'ah']
    rand_time: A random value up to this amount will be subtracted from the `rekey_time` and `reauth_time` to avoid simultaneous renegotiation.
    rekey_time: The amount of time (in seconds) before an IKE SA establishes new keys.
    remoteid_address: The remote network IP component of this IPsec security association.This field is only available when the following conditions are met:- `remoteid_type` must be one of [ address, network ]
    remoteid_netbits: The subnet bits of the `remoteid_address` network.This field is only available when the following conditions are met:- `remoteid_type` must be equal to `'network'`
    remoteid_type: The remote ID type to use for this phase 2 entry. Valid value options are: `address`, `network`. For interface values, the `:ip` modifier can be appended to the value to use the interface's IP address instead of its entire subnet.This field is only available when the following conditions are met:- `mode` must not be equal to `'transport'`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/ipsec/phase2. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if descr is not None:
        body["descr"] = descr
    if disabled is not None:
        body["disabled"] = disabled
    if encryption_algorithm_option is not None:
        body["encryption_algorithm_option"] = encryption_algorithm_option
    if hash_algorithm_option is not None:
        body["hash_algorithm_option"] = hash_algorithm_option
    if ikeid is not None:
        body["ikeid"] = ikeid
    if keepalive is not None:
        body["keepalive"] = keepalive
    if lifetime is not None:
        body["lifetime"] = lifetime
    if localid_address is not None:
        body["localid_address"] = localid_address
    if localid_netbits is not None:
        body["localid_netbits"] = localid_netbits
    if localid_type is not None:
        body["localid_type"] = localid_type
    if mode is not None:
        body["mode"] = mode
    if natlocalid_address is not None:
        body["natlocalid_address"] = natlocalid_address
    if natlocalid_netbits is not None:
        body["natlocalid_netbits"] = natlocalid_netbits
    if natlocalid_type is not None:
        body["natlocalid_type"] = natlocalid_type
    if pfsgroup is not None:
        body["pfsgroup"] = pfsgroup
    if pinghost is not None:
        body["pinghost"] = pinghost
    if protocol is not None:
        body["protocol"] = protocol
    if rand_time is not None:
        body["rand_time"] = rand_time
    if rekey_time is not None:
        body["rekey_time"] = rekey_time
    if remoteid_address is not None:
        body["remoteid_address"] = remoteid_address
    if remoteid_netbits is not None:
        body["remoteid_netbits"] = remoteid_netbits
    if remoteid_type is not None:
        body["remoteid_type"] = remoteid_type
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/ipsec/phase2",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase2(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase2

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase2. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase2",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpni_psec_phase2s(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/ipsec/phase2s

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/ipsec/phase2s",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_vpni_psec_phase2s(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/vpn/ipsec/phase2s

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/vpn/ipsec/phase2s. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/vpn/ipsec/phase2s",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpni_psec_phase2s(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/ipsec/phase2s

    Note: Call pfsense_vpn_ipsec_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/ipsec/phase2s. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_ipsec_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/ipsec/phase2s",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_open_vpncso(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/cso

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/cso",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_open_vpncso(
    common_name: str,
    confirm: bool = False,
    block: bool | None = None,
    custom_options: list[str] | None = None,
    description: str | None = None,
    disable: bool | None = None,
    dns_domain: str | None = None,
    dns_server1: str | None = None,
    dns_server2: str | None = None,
    dns_server3: str | None = None,
    dns_server4: str | None = None,
    gwredir: bool | None = None,
    local_network: list[str] | None = None,
    local_networkv6: list[str] | None = None,
    netbios_enable: bool | None = None,
    netbios_ntype: int | None = None,
    netbios_scope: str | None = None,
    ntp_server1: str | None = None,
    ntp_server2: str | None = None,
    push_reset: bool | None = None,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    remove_options: list[str] | None = None,
    server_list: list[str] | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    wins_server1: str | None = None,
    wins_server2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/openvpn/cso

    common_name: The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.
    block: Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.
    custom_options: Additional OpenVPN options to add for this client.
    description: The description for this client specific override.
    disable: Disables this client specific override.
    dns_domain: The default domain to provide to the client.
    dns_server1: The primary DNS server to provide to the client.
    dns_server2: The secondary DNS server to provide to the client.
    dns_server3: The tertiary DNS server to provide to the client.
    dns_server4: The quaternary DNS server to provide to the client.
    gwredir: Enable forcing all client-generated traffic through the tunnel.
    local_network: The IPv4 server-side networks that will be accessible from this particular client.
    local_networkv6: the IPv6 server-side networks that will be accessible from this particular client.
    netbios_enable: Enables or disables NetBIOS over TCP/IP.
    netbios_ntype: The NetBIOS node type.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true` Valid values: [0, 1, 2, 4, 8]
    netbios_scope: The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    ntp_server1: The primary NTP server to provide to the client.
    ntp_server2: The secondary NTP server to provide to the client.
    push_reset: Enables or disables preventing this client from receiving any server-defined client settings.
    remote_network: The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.
    remote_networkv6: The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.
    remove_options: Specifies the push-remove options to apply to the clientThis field is only available when the following conditions are met:- `push_reset` must be equal to `false`
    server_list: The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.
    tunnel_network: The IPv4 virtual network used for private communications between the server and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between the server and client hosts.
    wins_server1: The primary WINS server to provide to the client.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    wins_server2: The secondary WINS server to provide to the client.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/openvpn/cso. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if common_name is not None:
        body["common_name"] = common_name
    if block is not None:
        body["block"] = block
    if custom_options is not None:
        body["custom_options"] = custom_options
    if description is not None:
        body["description"] = description
    if disable is not None:
        body["disable"] = disable
    if dns_domain is not None:
        body["dns_domain"] = dns_domain
    if dns_server1 is not None:
        body["dns_server1"] = dns_server1
    if dns_server2 is not None:
        body["dns_server2"] = dns_server2
    if dns_server3 is not None:
        body["dns_server3"] = dns_server3
    if dns_server4 is not None:
        body["dns_server4"] = dns_server4
    if gwredir is not None:
        body["gwredir"] = gwredir
    if local_network is not None:
        body["local_network"] = local_network
    if local_networkv6 is not None:
        body["local_networkv6"] = local_networkv6
    if netbios_enable is not None:
        body["netbios_enable"] = netbios_enable
    if netbios_ntype is not None:
        body["netbios_ntype"] = netbios_ntype
    if netbios_scope is not None:
        body["netbios_scope"] = netbios_scope
    if ntp_server1 is not None:
        body["ntp_server1"] = ntp_server1
    if ntp_server2 is not None:
        body["ntp_server2"] = ntp_server2
    if push_reset is not None:
        body["push_reset"] = push_reset
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if remove_options is not None:
        body["remove_options"] = remove_options
    if server_list is not None:
        body["server_list"] = server_list
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if wins_server1 is not None:
        body["wins_server1"] = wins_server1
    if wins_server2 is not None:
        body["wins_server2"] = wins_server2
    return await _client.request(
        "POST",
        "/api/v2/vpn/openvpn/cso",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_open_vpncso(
    id: str | int,
    confirm: bool = False,
    block: bool | None = None,
    common_name: str | None = None,
    custom_options: list[str] | None = None,
    description: str | None = None,
    disable: bool | None = None,
    dns_domain: str | None = None,
    dns_server1: str | None = None,
    dns_server2: str | None = None,
    dns_server3: str | None = None,
    dns_server4: str | None = None,
    gwredir: bool | None = None,
    local_network: list[str] | None = None,
    local_networkv6: list[str] | None = None,
    netbios_enable: bool | None = None,
    netbios_ntype: int | None = None,
    netbios_scope: str | None = None,
    ntp_server1: str | None = None,
    ntp_server2: str | None = None,
    push_reset: bool | None = None,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    remove_options: list[str] | None = None,
    server_list: list[str] | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    wins_server1: str | None = None,
    wins_server2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/openvpn/cso

    id: The ID of the object or resource to interact with.
    block: Enables or disables the client from connecting to this server. Do not use this option to permanently disable a client due to a compromised key or password. Use a CRL instead.
    common_name: The X.509 common name for the client certificate, or the username for VPNs utilizing password authentication.
    custom_options: Additional OpenVPN options to add for this client.
    description: The description for this client specific override.
    disable: Disables this client specific override.
    dns_domain: The default domain to provide to the client.
    dns_server1: The primary DNS server to provide to the client.
    dns_server2: The secondary DNS server to provide to the client.
    dns_server3: The tertiary DNS server to provide to the client.
    dns_server4: The quaternary DNS server to provide to the client.
    gwredir: Enable forcing all client-generated traffic through the tunnel.
    local_network: The IPv4 server-side networks that will be accessible from this particular client.
    local_networkv6: the IPv6 server-side networks that will be accessible from this particular client.
    netbios_enable: Enables or disables NetBIOS over TCP/IP.
    netbios_ntype: The NetBIOS node type.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true` Valid values: [0, 1, 2, 4, 8]
    netbios_scope: The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    ntp_server1: The primary NTP server to provide to the client.
    ntp_server2: The secondary NTP server to provide to the client.
    push_reset: Enables or disables preventing this client from receiving any server-defined client settings.
    remote_network: The IPv4 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.
    remote_networkv6: The IPv6 client-side networks that will be routed to this client specifically using iroute, so that a site-to-site VPN can be established.
    remove_options: Specifies the push-remove options to apply to the clientThis field is only available when the following conditions are met:- `push_reset` must be equal to `false`
    server_list: The OpenVPN servers that will utilize this override. When no servers are specified, the override will apply to all servers.
    tunnel_network: The IPv4 virtual network used for private communications between the server and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between the server and client hosts.
    wins_server1: The primary WINS server to provide to the client.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    wins_server2: The secondary WINS server to provide to the client.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/openvpn/cso. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if block is not None:
        body["block"] = block
    if common_name is not None:
        body["common_name"] = common_name
    if custom_options is not None:
        body["custom_options"] = custom_options
    if description is not None:
        body["description"] = description
    if disable is not None:
        body["disable"] = disable
    if dns_domain is not None:
        body["dns_domain"] = dns_domain
    if dns_server1 is not None:
        body["dns_server1"] = dns_server1
    if dns_server2 is not None:
        body["dns_server2"] = dns_server2
    if dns_server3 is not None:
        body["dns_server3"] = dns_server3
    if dns_server4 is not None:
        body["dns_server4"] = dns_server4
    if gwredir is not None:
        body["gwredir"] = gwredir
    if local_network is not None:
        body["local_network"] = local_network
    if local_networkv6 is not None:
        body["local_networkv6"] = local_networkv6
    if netbios_enable is not None:
        body["netbios_enable"] = netbios_enable
    if netbios_ntype is not None:
        body["netbios_ntype"] = netbios_ntype
    if netbios_scope is not None:
        body["netbios_scope"] = netbios_scope
    if ntp_server1 is not None:
        body["ntp_server1"] = ntp_server1
    if ntp_server2 is not None:
        body["ntp_server2"] = ntp_server2
    if push_reset is not None:
        body["push_reset"] = push_reset
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if remove_options is not None:
        body["remove_options"] = remove_options
    if server_list is not None:
        body["server_list"] = server_list
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if wins_server1 is not None:
        body["wins_server1"] = wins_server1
    if wins_server2 is not None:
        body["wins_server2"] = wins_server2
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/openvpn/cso",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpncso(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/cso

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/cso. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/cso",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_open_vpncs_os(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/csos

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/csos",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpncs_os(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/csos

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/csos. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/csos",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_open_vpn_client(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/client

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/client",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_open_vpn_client(
    caref: str,
    data_ciphers: list[str],
    data_ciphers_fallback: str,
    dev_mode: str,
    digest: str,
    mode: str,
    protocol: str,
    server_addr: str,
    server_port: str,
    confirm: bool = False,
    allow_compression: str | None = 'no',
    auth_pass: str | None = None,
    auth_retry_none: bool | None = None,
    auth_user: str | None = None,
    certref: str | None = None,
    create_gw: str | None = 'both',
    custom_options: list[str] | None = None,
    description: str | None = None,
    disable: bool | None = None,
    dns_add: bool | None = None,
    exit_notify: str | None = 'none',
    inactive_seconds: int | None = 300,
    interface: str | None = None,
    keepalive_interval: int | None = None,
    keepalive_timeout: int | None = None,
    local_port: str | None = None,
    passtos: bool | None = None,
    ping_action: str | None = None,
    ping_action_seconds: int | None = None,
    ping_method: str | None = 'keepalive',
    ping_seconds: int | None = None,
    proxy_addr: str | None = None,
    proxy_authtype: str | None = 'none',
    proxy_passwd: str | None = None,
    proxy_port: str | None = None,
    proxy_user: str | None = None,
    remote_cert_tls: bool | None = True,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    route_no_exec: bool | None = None,
    route_no_pull: bool | None = None,
    sndrcvbuf: int | None = None,
    tls: str | None = None,
    tls_type: str | None = None,
    tlsauth_keydir: str | None = None,
    topology: str | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    udp_fast_io: bool | None = None,
    use_shaper: int | None = None,
    verbosity_level: int | None = 1,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/openvpn/client

    caref: The `refid` of the CA object to assume as the peer CA.
    data_ciphers: The encryption algorithms/ciphers allowed by this OpenVPN client.
    data_ciphers_fallback: The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).
    dev_mode: The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2). Valid values: ['tun', 'tap']
    digest: The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.
    mode: The OpenVPN client mode. Valid values: ['p2p_tls']
    protocol: The protocol used by this OpenVPN client. Valid values: ['UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP']
    server_addr: The IP address or hostname of the OpenVPN server this client will connect to.
    server_port: The port used by the server to receive client connections. Valid options are: a TCP/UDP port number
    allow_compression: The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP) Valid values: ['no', 'yes', 'asym']
    auth_pass: The password used to authenticate with the OpenVPN server.This field is only available when the following conditions are met:- `auth_user` must not be equal to `NULL`
    auth_retry_none: Disables retrying authentication if an authentication failed error is received from the server
    auth_user: The username used to authenticate with the OpenVPN server.
    certref: The `refid` of the certificate object to assume as the OpenVPN client certificate.
    create_gw: The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server Valid values: ['both', 'v4only', 'v6only']
    custom_options: Additional options to add to the OpenVPN client configuration.
    description: The description for this OpenVPN client.
    disable: Disables this OpenVPN client.
    dns_add: Enables or disables using the DNS server(s) provided by the OpenVPN server.
    exit_notify: The number of times this client will attempt to send an exit notifications. Valid values: ['1', '2', '3', '4', '5', 'none']
    inactive_seconds: The amount of time (in seconds) until a client connection is closed for inactivity.
    interface: The interface used by the firewall to originate this OpenVPN client connection.This field is only available when the following conditions are met:- `protocol` must not be one of [ UDP, TCP ]
    keepalive_interval: The keepalive interval parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    keepalive_timeout: The keepalive timeout parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    local_port: The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number
    passtos: Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.
    ping_action: The action to take after a ping to the remote peer times-out.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'` Valid values: ['ping_restart', 'ping_exit']
    ping_action_seconds: The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_method: The method used to define ping configuration. Valid values: ['keepalive', 'ping']
    ping_seconds: The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    proxy_addr: The address for an HTTP Proxy this client can use to connect to a remote server.
    proxy_authtype: The type of authentication used by the proxy server. Valid values: ['none', 'basic', 'ntlm']
    proxy_passwd: The username to use for authentication to the remote proxy.This field is only available when the following conditions are met:- `proxy_authtype` must not be equal to `'none'`
    proxy_port: The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number
    proxy_user: The username to use for authentication to the remote proxy.This field is only available when the following conditions are met:- `proxy_authtype` must not be equal to `'none'`
    remote_cert_tls: Enables or disables requiring hosts to have a client certificate to connect.
    remote_network: IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    remote_networkv6: IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    route_no_exec: Enables or disables adding/removing routes automatically.
    route_no_pull: Enables or disables the servers ability to add routes to the client's routing table.
    sndrcvbuf: The send and receive buffer size for OpenVPN. Set to null to use the system default. Valid values: [65536, 131072, 262144, 524288, 1048576, 2097152]
    tls: The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.
    tls_type: The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.This field is only available when the following conditions are met:- `tls` must not be equal to `NULL` Valid values: ['auth', 'crypt']
    tlsauth_keydir: The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.This field is only available when the following conditions are met:- `tls` must not be equal to `NULL` Valid values: ['default', '0', '1', '2']
    topology: The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tun'` Valid values: ['subnet', 'net30']
    tunnel_network: The IPv4 virtual network used for private communications between this client and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between this client and client hosts.
    udp_fast_io: Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).
    use_shaper: Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.
    verbosity_level: The OpenVPN logging verbosity level. Valid values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/openvpn/client. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if data_ciphers is not None:
        body["data_ciphers"] = data_ciphers
    if data_ciphers_fallback is not None:
        body["data_ciphers_fallback"] = data_ciphers_fallback
    if dev_mode is not None:
        body["dev_mode"] = dev_mode
    if digest is not None:
        body["digest"] = digest
    if mode is not None:
        body["mode"] = mode
    if protocol is not None:
        body["protocol"] = protocol
    if server_addr is not None:
        body["server_addr"] = server_addr
    if server_port is not None:
        body["server_port"] = server_port
    if allow_compression is not None:
        body["allow_compression"] = allow_compression
    if auth_pass is not None:
        body["auth_pass"] = auth_pass
    if auth_retry_none is not None:
        body["auth_retry_none"] = auth_retry_none
    if auth_user is not None:
        body["auth_user"] = auth_user
    if certref is not None:
        body["certref"] = certref
    if create_gw is not None:
        body["create_gw"] = create_gw
    if custom_options is not None:
        body["custom_options"] = custom_options
    if description is not None:
        body["description"] = description
    if disable is not None:
        body["disable"] = disable
    if dns_add is not None:
        body["dns_add"] = dns_add
    if exit_notify is not None:
        body["exit_notify"] = exit_notify
    if inactive_seconds is not None:
        body["inactive_seconds"] = inactive_seconds
    if interface is not None:
        body["interface"] = interface
    if keepalive_interval is not None:
        body["keepalive_interval"] = keepalive_interval
    if keepalive_timeout is not None:
        body["keepalive_timeout"] = keepalive_timeout
    if local_port is not None:
        body["local_port"] = local_port
    if passtos is not None:
        body["passtos"] = passtos
    if ping_action is not None:
        body["ping_action"] = ping_action
    if ping_action_seconds is not None:
        body["ping_action_seconds"] = ping_action_seconds
    if ping_method is not None:
        body["ping_method"] = ping_method
    if ping_seconds is not None:
        body["ping_seconds"] = ping_seconds
    if proxy_addr is not None:
        body["proxy_addr"] = proxy_addr
    if proxy_authtype is not None:
        body["proxy_authtype"] = proxy_authtype
    if proxy_passwd is not None:
        body["proxy_passwd"] = proxy_passwd
    if proxy_port is not None:
        body["proxy_port"] = proxy_port
    if proxy_user is not None:
        body["proxy_user"] = proxy_user
    if remote_cert_tls is not None:
        body["remote_cert_tls"] = remote_cert_tls
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if route_no_exec is not None:
        body["route_no_exec"] = route_no_exec
    if route_no_pull is not None:
        body["route_no_pull"] = route_no_pull
    if sndrcvbuf is not None:
        body["sndrcvbuf"] = sndrcvbuf
    if tls is not None:
        body["tls"] = tls
    if tls_type is not None:
        body["tls_type"] = tls_type
    if tlsauth_keydir is not None:
        body["tlsauth_keydir"] = tlsauth_keydir
    if topology is not None:
        body["topology"] = topology
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if udp_fast_io is not None:
        body["udp_fast_io"] = udp_fast_io
    if use_shaper is not None:
        body["use_shaper"] = use_shaper
    if verbosity_level is not None:
        body["verbosity_level"] = verbosity_level
    return await _client.request(
        "POST",
        "/api/v2/vpn/openvpn/client",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_open_vpn_client(
    id: str | int,
    confirm: bool = False,
    allow_compression: str | None = None,
    auth_pass: str | None = None,
    auth_retry_none: bool | None = None,
    auth_user: str | None = None,
    caref: str | None = None,
    certref: str | None = None,
    create_gw: str | None = None,
    custom_options: list[str] | None = None,
    data_ciphers: list[str] | None = None,
    data_ciphers_fallback: str | None = None,
    description: str | None = None,
    dev_mode: str | None = None,
    digest: str | None = None,
    disable: bool | None = None,
    dns_add: bool | None = None,
    exit_notify: str | None = None,
    inactive_seconds: int | None = None,
    interface: str | None = None,
    keepalive_interval: int | None = None,
    keepalive_timeout: int | None = None,
    local_port: str | None = None,
    mode: str | None = None,
    passtos: bool | None = None,
    ping_action: str | None = None,
    ping_action_seconds: int | None = None,
    ping_method: str | None = None,
    ping_seconds: int | None = None,
    protocol: str | None = None,
    proxy_addr: str | None = None,
    proxy_authtype: str | None = None,
    proxy_passwd: str | None = None,
    proxy_port: str | None = None,
    proxy_user: str | None = None,
    remote_cert_tls: bool | None = None,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    route_no_exec: bool | None = None,
    route_no_pull: bool | None = None,
    server_addr: str | None = None,
    server_port: str | None = None,
    sndrcvbuf: int | None = None,
    tls: str | None = None,
    tls_type: str | None = None,
    tlsauth_keydir: str | None = None,
    topology: str | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    udp_fast_io: bool | None = None,
    use_shaper: int | None = None,
    verbosity_level: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/openvpn/client

    id: The ID of the object or resource to interact with.
    allow_compression: The compression mode allowed by this OpenVPN client. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP) Valid values: ['no', 'yes', 'asym']
    auth_pass: The password used to authenticate with the OpenVPN server.This field is only available when the following conditions are met:- `auth_user` must not be equal to `NULL`
    auth_retry_none: Disables retrying authentication if an authentication failed error is received from the server
    auth_user: The username used to authenticate with the OpenVPN server.
    caref: The `refid` of the CA object to assume as the peer CA.
    certref: The `refid` of the certificate object to assume as the OpenVPN client certificate.
    create_gw: The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server Valid values: ['both', 'v4only', 'v6only']
    custom_options: Additional options to add to the OpenVPN client configuration.
    data_ciphers: The encryption algorithms/ciphers allowed by this OpenVPN client.
    data_ciphers_fallback: The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).
    description: The description for this OpenVPN client.
    dev_mode: The carrier mode for this OpenVPN client. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2). Valid values: ['tun', 'tap']
    digest: The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.
    disable: Disables this OpenVPN client.
    dns_add: Enables or disables using the DNS server(s) provided by the OpenVPN server.
    exit_notify: The number of times this client will attempt to send an exit notifications. Valid values: ['1', '2', '3', '4', '5', 'none']
    inactive_seconds: The amount of time (in seconds) until a client connection is closed for inactivity.
    interface: The interface used by the firewall to originate this OpenVPN client connection.This field is only available when the following conditions are met:- `protocol` must not be one of [ UDP, TCP ]
    keepalive_interval: The keepalive interval parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    keepalive_timeout: The keepalive timeout parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    local_port: The port binding used by OpenVPN for client connections. Valid options are: a TCP/UDP port number
    mode: The OpenVPN client mode. Valid values: ['p2p_tls']
    passtos: Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.
    ping_action: The action to take after a ping to the remote peer times-out.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'` Valid values: ['ping_restart', 'ping_exit']
    ping_action_seconds: The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_method: The method used to define ping configuration. Valid values: ['keepalive', 'ping']
    ping_seconds: The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    protocol: The protocol used by this OpenVPN client. Valid values: ['UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP']
    proxy_addr: The address for an HTTP Proxy this client can use to connect to a remote server.
    proxy_authtype: The type of authentication used by the proxy server. Valid values: ['none', 'basic', 'ntlm']
    proxy_passwd: The username to use for authentication to the remote proxy.This field is only available when the following conditions are met:- `proxy_authtype` must not be equal to `'none'`
    proxy_port: The port used by the HTTP Proxy. Valid options are: a TCP/UDP port number
    proxy_user: The username to use for authentication to the remote proxy.This field is only available when the following conditions are met:- `proxy_authtype` must not be equal to `'none'`
    remote_cert_tls: Enables or disables requiring hosts to have a client certificate to connect.
    remote_network: IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    remote_networkv6: IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    route_no_exec: Enables or disables adding/removing routes automatically.
    route_no_pull: Enables or disables the servers ability to add routes to the client's routing table.
    server_addr: The IP address or hostname of the OpenVPN server this client will connect to.
    server_port: The port used by the server to receive client connections. Valid options are: a TCP/UDP port number
    sndrcvbuf: The send and receive buffer size for OpenVPN. Set to null to use the system default. Valid values: [65536, 131072, 262144, 524288, 1048576, 2097152]
    tls: The TLS key this OpenVPN client will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.
    tls_type: The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.This field is only available when the following conditions are met:- `tls` must not be equal to `NULL` Valid values: ['auth', 'crypt']
    tlsauth_keydir: The TLS key direction. This must be set to complementary values on the client and client. For example, if the client is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.This field is only available when the following conditions are met:- `tls` must not be equal to `NULL` Valid values: ['default', '0', '1', '2']
    topology: The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tun'` Valid values: ['subnet', 'net30']
    tunnel_network: The IPv4 virtual network used for private communications between this client and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between this client and client hosts.
    udp_fast_io: Enables or disables fast I/O operations with UDP writes to tun/tap (Experimental).
    use_shaper: Maximum outgoing bandwidth (in bytes per second) for this tunnel. Use `null` no limit.
    verbosity_level: The OpenVPN logging verbosity level. Valid values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/openvpn/client. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if allow_compression is not None:
        body["allow_compression"] = allow_compression
    if auth_pass is not None:
        body["auth_pass"] = auth_pass
    if auth_retry_none is not None:
        body["auth_retry_none"] = auth_retry_none
    if auth_user is not None:
        body["auth_user"] = auth_user
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if create_gw is not None:
        body["create_gw"] = create_gw
    if custom_options is not None:
        body["custom_options"] = custom_options
    if data_ciphers is not None:
        body["data_ciphers"] = data_ciphers
    if data_ciphers_fallback is not None:
        body["data_ciphers_fallback"] = data_ciphers_fallback
    if description is not None:
        body["description"] = description
    if dev_mode is not None:
        body["dev_mode"] = dev_mode
    if digest is not None:
        body["digest"] = digest
    if disable is not None:
        body["disable"] = disable
    if dns_add is not None:
        body["dns_add"] = dns_add
    if exit_notify is not None:
        body["exit_notify"] = exit_notify
    if inactive_seconds is not None:
        body["inactive_seconds"] = inactive_seconds
    if interface is not None:
        body["interface"] = interface
    if keepalive_interval is not None:
        body["keepalive_interval"] = keepalive_interval
    if keepalive_timeout is not None:
        body["keepalive_timeout"] = keepalive_timeout
    if local_port is not None:
        body["local_port"] = local_port
    if mode is not None:
        body["mode"] = mode
    if passtos is not None:
        body["passtos"] = passtos
    if ping_action is not None:
        body["ping_action"] = ping_action
    if ping_action_seconds is not None:
        body["ping_action_seconds"] = ping_action_seconds
    if ping_method is not None:
        body["ping_method"] = ping_method
    if ping_seconds is not None:
        body["ping_seconds"] = ping_seconds
    if protocol is not None:
        body["protocol"] = protocol
    if proxy_addr is not None:
        body["proxy_addr"] = proxy_addr
    if proxy_authtype is not None:
        body["proxy_authtype"] = proxy_authtype
    if proxy_passwd is not None:
        body["proxy_passwd"] = proxy_passwd
    if proxy_port is not None:
        body["proxy_port"] = proxy_port
    if proxy_user is not None:
        body["proxy_user"] = proxy_user
    if remote_cert_tls is not None:
        body["remote_cert_tls"] = remote_cert_tls
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if route_no_exec is not None:
        body["route_no_exec"] = route_no_exec
    if route_no_pull is not None:
        body["route_no_pull"] = route_no_pull
    if server_addr is not None:
        body["server_addr"] = server_addr
    if server_port is not None:
        body["server_port"] = server_port
    if sndrcvbuf is not None:
        body["sndrcvbuf"] = sndrcvbuf
    if tls is not None:
        body["tls"] = tls
    if tls_type is not None:
        body["tls_type"] = tls_type
    if tlsauth_keydir is not None:
        body["tlsauth_keydir"] = tlsauth_keydir
    if topology is not None:
        body["topology"] = topology
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if udp_fast_io is not None:
        body["udp_fast_io"] = udp_fast_io
    if use_shaper is not None:
        body["use_shaper"] = use_shaper
    if verbosity_level is not None:
        body["verbosity_level"] = verbosity_level
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/openvpn/client",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_client(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/client

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/client. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/client",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_open_vpn_client_export_config(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/client_export/config

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/client_export/config",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_open_vpn_client_export_config(
    server: int,
    confirm: bool = False,
    advancedoptions: str | None = None,
    bindmode: str | None = 'nobind',
    blockoutsidedns: bool | None = None,
    legacy: bool | None = None,
    p12encryption: str | None = 'high',
    pass_: str | None = None,
    pkcs11id: str | None = None,
    pkcs11providers: list[str] | None = None,
    proxyaddr: str | None = None,
    proxypass: str | None = None,
    proxyport: str | None = None,
    proxyuser: str | None = None,
    silent: bool | None = None,
    useaddr: str | None = 'serveraddr',
    useaddr_hostname: str | None = None,
    usepass: bool | None = None,
    usepkcs11: bool | None = None,
    useproxy: bool | None = None,
    useproxypass: str | None = None,
    useproxytype: str | None = None,
    usetoken: bool | None = None,
    verifyservercn: str | None = 'auto',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/openvpn/client_export/config

    server: The VPN ID of the OpenVPN server this client export corresponds to.
    advancedoptions: Additional options to add to the OpenVPN client export configuration.
    bindmode: The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently. Valid values: ['nobind', 'lport0', 'bind']
    blockoutsidedns: Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.
    legacy: Do not include OpenVPN 2.5 and later settings in the client configuration.
    p12encryption: The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program Valid values: ['high', 'low', 'legacy']
    pass_: Password used to protect the certificate file contents.This field is only available when the following conditions are met:- `usepass` must be equal to `true`
    pkcs11id: The object's ID on the PKCS#11 device.This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    pkcs11providers: The client local path to the PKCS#11 provider(s) (DLL, module)This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    proxyaddr: The IP address or hostname of the proxy server to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxypass: The password to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    proxyport: The port where the proxy server is listening. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxyuser: The username to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    silent: Create Windows installer for unattended deploy.
    useaddr: The method to use for the OpenVPN server address listed in the config export. Valid values: ['serveraddr', 'servermagic', 'servermagichost', 'serverhostname', 'other']
    useaddr_hostname: The hostname to use for the OpenVPN server address.This field is only available when the following conditions are met:- `useaddr` must be equal to `'other'`
    usepass: Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.
    usepkcs11: Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.
    useproxy: Use proxy to communicate with the OpenVPN server.
    useproxypass: The type of authentication to use for the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['none', 'basic', 'ntlm']
    useproxytype: The proxy type to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['http', 'socks']
    usetoken: Use Microsoft Certificate Storage instead of local files.
    verifyservercn: Verify the server certificate Common Name (CN) when the client connects. Valid values: ['auto', 'none']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/openvpn/client_export/config. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if server is not None:
        body["server"] = server
    if advancedoptions is not None:
        body["advancedoptions"] = advancedoptions
    if bindmode is not None:
        body["bindmode"] = bindmode
    if blockoutsidedns is not None:
        body["blockoutsidedns"] = blockoutsidedns
    if legacy is not None:
        body["legacy"] = legacy
    if p12encryption is not None:
        body["p12encryption"] = p12encryption
    if pass_ is not None:
        body["pass"] = pass_
    if pkcs11id is not None:
        body["pkcs11id"] = pkcs11id
    if pkcs11providers is not None:
        body["pkcs11providers"] = pkcs11providers
    if proxyaddr is not None:
        body["proxyaddr"] = proxyaddr
    if proxypass is not None:
        body["proxypass"] = proxypass
    if proxyport is not None:
        body["proxyport"] = proxyport
    if proxyuser is not None:
        body["proxyuser"] = proxyuser
    if silent is not None:
        body["silent"] = silent
    if useaddr is not None:
        body["useaddr"] = useaddr
    if useaddr_hostname is not None:
        body["useaddr_hostname"] = useaddr_hostname
    if usepass is not None:
        body["usepass"] = usepass
    if usepkcs11 is not None:
        body["usepkcs11"] = usepkcs11
    if useproxy is not None:
        body["useproxy"] = useproxy
    if useproxypass is not None:
        body["useproxypass"] = useproxypass
    if useproxytype is not None:
        body["useproxytype"] = useproxytype
    if usetoken is not None:
        body["usetoken"] = usetoken
    if verifyservercn is not None:
        body["verifyservercn"] = verifyservercn
    return await _client.request(
        "POST",
        "/api/v2/vpn/openvpn/client_export/config",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_open_vpn_client_export_config(
    id: str | int,
    confirm: bool = False,
    advancedoptions: str | None = None,
    bindmode: str | None = None,
    blockoutsidedns: bool | None = None,
    legacy: bool | None = None,
    p12encryption: str | None = None,
    pass_: str | None = None,
    pkcs11id: str | None = None,
    pkcs11providers: list[str] | None = None,
    proxyaddr: str | None = None,
    proxypass: str | None = None,
    proxyport: str | None = None,
    proxyuser: str | None = None,
    server: int | None = None,
    silent: bool | None = None,
    useaddr: str | None = None,
    useaddr_hostname: str | None = None,
    usepass: bool | None = None,
    usepkcs11: bool | None = None,
    useproxy: bool | None = None,
    useproxypass: str | None = None,
    useproxytype: str | None = None,
    usetoken: bool | None = None,
    verifyservercn: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/openvpn/client_export/config

    id: The ID of the object or resource to interact with.
    advancedoptions: Additional options to add to the OpenVPN client export configuration.
    bindmode: The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently. Valid values: ['nobind', 'lport0', 'bind']
    blockoutsidedns: Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.
    legacy: Do not include OpenVPN 2.5 and later settings in the client configuration.
    p12encryption: The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program Valid values: ['high', 'low', 'legacy']
    pass_: Password used to protect the certificate file contents.This field is only available when the following conditions are met:- `usepass` must be equal to `true`
    pkcs11id: The object's ID on the PKCS#11 device.This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    pkcs11providers: The client local path to the PKCS#11 provider(s) (DLL, module)This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    proxyaddr: The IP address or hostname of the proxy server to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxypass: The password to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    proxyport: The port where the proxy server is listening. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxyuser: The username to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    server: The VPN ID of the OpenVPN server this client export corresponds to.
    silent: Create Windows installer for unattended deploy.
    useaddr: The method to use for the OpenVPN server address listed in the config export. Valid values: ['serveraddr', 'servermagic', 'servermagichost', 'serverhostname', 'other']
    useaddr_hostname: The hostname to use for the OpenVPN server address.This field is only available when the following conditions are met:- `useaddr` must be equal to `'other'`
    usepass: Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.
    usepkcs11: Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.
    useproxy: Use proxy to communicate with the OpenVPN server.
    useproxypass: The type of authentication to use for the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['none', 'basic', 'ntlm']
    useproxytype: The proxy type to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['http', 'socks']
    usetoken: Use Microsoft Certificate Storage instead of local files.
    verifyservercn: Verify the server certificate Common Name (CN) when the client connects. Valid values: ['auto', 'none']
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/openvpn/client_export/config. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if advancedoptions is not None:
        body["advancedoptions"] = advancedoptions
    if bindmode is not None:
        body["bindmode"] = bindmode
    if blockoutsidedns is not None:
        body["blockoutsidedns"] = blockoutsidedns
    if legacy is not None:
        body["legacy"] = legacy
    if p12encryption is not None:
        body["p12encryption"] = p12encryption
    if pass_ is not None:
        body["pass"] = pass_
    if pkcs11id is not None:
        body["pkcs11id"] = pkcs11id
    if pkcs11providers is not None:
        body["pkcs11providers"] = pkcs11providers
    if proxyaddr is not None:
        body["proxyaddr"] = proxyaddr
    if proxypass is not None:
        body["proxypass"] = proxypass
    if proxyport is not None:
        body["proxyport"] = proxyport
    if proxyuser is not None:
        body["proxyuser"] = proxyuser
    if server is not None:
        body["server"] = server
    if silent is not None:
        body["silent"] = silent
    if useaddr is not None:
        body["useaddr"] = useaddr
    if useaddr_hostname is not None:
        body["useaddr_hostname"] = useaddr_hostname
    if usepass is not None:
        body["usepass"] = usepass
    if usepkcs11 is not None:
        body["usepkcs11"] = usepkcs11
    if useproxy is not None:
        body["useproxy"] = useproxy
    if useproxypass is not None:
        body["useproxypass"] = useproxypass
    if useproxytype is not None:
        body["useproxytype"] = useproxytype
    if usetoken is not None:
        body["usetoken"] = usetoken
    if verifyservercn is not None:
        body["verifyservercn"] = verifyservercn
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/openvpn/client_export/config",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_client_export_config(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/client_export/config

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/client_export/config. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/client_export/config",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_open_vpn_client_export_configs(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/client_export/configs

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/client_export/configs",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_vpn_open_vpn_client_export_configs(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/vpn/openvpn/client_export/configs

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/vpn/openvpn/client_export/configs. "
            "Set confirm=True to execute."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/vpn/openvpn/client_export/configs",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_client_export_configs(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/client_export/configs

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/client_export/configs. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/client_export/configs",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_open_vpn_client_export(
    id: str | int,
    confirm: bool = False,
    advancedoptions: str | None = None,
    bindmode: str | None = 'nobind',
    blockoutsidedns: bool | None = None,
    certref: str | None = None,
    legacy: bool | None = None,
    p12encryption: str | None = 'high',
    pass_: str | None = None,
    pkcs11id: str | None = None,
    pkcs11providers: list[str] | None = None,
    proxyaddr: str | None = None,
    proxypass: str | None = None,
    proxyport: str | None = None,
    proxyuser: str | None = None,
    server: int | None = None,
    silent: bool | None = None,
    type_: str | None = None,
    useaddr: str | None = 'serveraddr',
    useaddr_hostname: str | None = None,
    usepass: bool | None = None,
    usepkcs11: bool | None = None,
    useproxy: bool | None = None,
    useproxypass: str | None = None,
    useproxytype: str | None = None,
    username: str | None = None,
    usetoken: bool | None = None,
    verifyservercn: str | None = 'auto',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/openvpn/client_export

    id: The ID of the object or resource to interact with.
    advancedoptions: Additional options to add to the OpenVPN client export configuration.
    bindmode: The port binding mode to use. If OpenVPN client binds to the default OpenVPN port (1194), two clients may not run concurrently. Valid values: ['nobind', 'lport0', 'bind']
    blockoutsidedns: Block access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.
    certref: The reference ID of the certificate to use for this OpenVPN client export. This is only applicable for OpenVPN servers that require client certificates.
    legacy: Do not include OpenVPN 2.5 and later settings in the client configuration.
    p12encryption: The level of encryption to use when exporting a PKCS#12 archive. Encryption support varies by Operating System and program Valid values: ['high', 'low', 'legacy']
    pass_: Password used to protect the certificate file contents.This field is only available when the following conditions are met:- `usepass` must be equal to `true`
    pkcs11id: The object's ID on the PKCS#11 device.This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    pkcs11providers: The client local path to the PKCS#11 provider(s) (DLL, module)This field is only available when the following conditions are met:- `usepkcs11` must be equal to `true`
    proxyaddr: The IP address or hostname of the proxy server to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxypass: The password to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    proxyport: The port where the proxy server is listening. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `useproxy` must be equal to `true`
    proxyuser: The username to use to authenticate with the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true`- `useproxypass` must be one of [ basic, ntlm ]
    server: The VPN ID of the OpenVPN server this client export corresponds to.
    silent: Create Windows installer for unattended deploy.
    type_: The type of OpenVPN client export to generate. This determines the format and content of the export file. Valid values: ['confzip', 'conf_yealink_t28', 'conf_yealink_t38g', 'conf_yealink_t38g2', 'conf_snom', 'confinline', 'confinlinedroid', 'confinlineconnect', 'confinlinevisc', 'inst-Win7', 'inst-Win10', 'inst-x86-previous', 'inst-x64-previous', 'inst-x86-current', 'inst-x64-current', 'visc']
    useaddr: The method to use for the OpenVPN server address listed in the config export. Valid values: ['serveraddr', 'servermagic', 'servermagichost', 'serverhostname', 'other']
    useaddr_hostname: The hostname to use for the OpenVPN server address.This field is only available when the following conditions are met:- `useaddr` must be equal to `'other'`
    usepass: Use a password to protect the PKCS#12 file contents or key in Viscosity bundles.
    usepkcs11: Use PKCS#11 storage device (cryptographic token, HSM, smart card) instead of local files.
    useproxy: Use proxy to communicate with the OpenVPN server.
    useproxypass: The type of authentication to use for the proxy server.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['none', 'basic', 'ntlm']
    useproxytype: The proxy type to use.This field is only available when the following conditions are met:- `useproxy` must be equal to `true` Valid values: ['http', 'socks']
    username: The username of the user this client export corresponds to. This is only applicable for OpenVPN servers that use the Local Database AND client certificates.
    usetoken: Use Microsoft Certificate Storage instead of local files.
    verifyservercn: Verify the server certificate Common Name (CN) when the client connects. Valid values: ['auto', 'none']
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/openvpn/client_export. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if advancedoptions is not None:
        body["advancedoptions"] = advancedoptions
    if bindmode is not None:
        body["bindmode"] = bindmode
    if blockoutsidedns is not None:
        body["blockoutsidedns"] = blockoutsidedns
    if certref is not None:
        body["certref"] = certref
    if legacy is not None:
        body["legacy"] = legacy
    if p12encryption is not None:
        body["p12encryption"] = p12encryption
    if pass_ is not None:
        body["pass"] = pass_
    if pkcs11id is not None:
        body["pkcs11id"] = pkcs11id
    if pkcs11providers is not None:
        body["pkcs11providers"] = pkcs11providers
    if proxyaddr is not None:
        body["proxyaddr"] = proxyaddr
    if proxypass is not None:
        body["proxypass"] = proxypass
    if proxyport is not None:
        body["proxyport"] = proxyport
    if proxyuser is not None:
        body["proxyuser"] = proxyuser
    if server is not None:
        body["server"] = server
    if silent is not None:
        body["silent"] = silent
    if type_ is not None:
        body["type"] = type_
    if useaddr is not None:
        body["useaddr"] = useaddr
    if useaddr_hostname is not None:
        body["useaddr_hostname"] = useaddr_hostname
    if usepass is not None:
        body["usepass"] = usepass
    if usepkcs11 is not None:
        body["usepkcs11"] = usepkcs11
    if useproxy is not None:
        body["useproxy"] = useproxy
    if useproxypass is not None:
        body["useproxypass"] = useproxypass
    if useproxytype is not None:
        body["useproxytype"] = useproxytype
    if username is not None:
        body["username"] = username
    if usetoken is not None:
        body["usetoken"] = usetoken
    if verifyservercn is not None:
        body["verifyservercn"] = verifyservercn
    return await _client.request(
        "POST",
        "/api/v2/vpn/openvpn/client_export",
        json_body=body,
    )


@mcp.tool()
async def pfsense_list_vpn_open_vpn_clients(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/clients

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/clients",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_clients(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/clients

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/clients. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/clients",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_open_vpn_server(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/server

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/server",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_open_vpn_server(
    caref: str,
    certref: str,
    data_ciphers: list[str],
    data_ciphers_fallback: str,
    dev_mode: str,
    dh_length: str,
    digest: str,
    ecdh_curve: str,
    mode: str,
    protocol: str,
    confirm: bool = False,
    allow_compression: str | None = 'no',
    authmode: list[str] | None = None,
    cert_depth: int | None = 1,
    client2client: bool | None = None,
    connlimit: int | None = None,
    create_gw: str | None = 'both',
    custom_options: list[str] | None = None,
    description: str | None = None,
    disable: bool | None = None,
    dns_domain: str | None = None,
    dns_server1: str | None = None,
    dns_server2: str | None = None,
    dns_server3: str | None = None,
    dns_server4: str | None = None,
    duplicate_cn: bool | None = None,
    dynamic_ip: bool | None = None,
    gwredir: bool | None = None,
    gwredir6: bool | None = None,
    inactive_seconds: int | None = 300,
    interface: str | None = None,
    keepalive_interval: int | None = None,
    keepalive_timeout: int | None = None,
    local_network: list[str] | None = None,
    local_networkv6: list[str] | None = None,
    local_port: str | None = '1194',
    maxclients: int | None = None,
    netbios_enable: bool | None = None,
    netbios_ntype: int | None = None,
    netbios_scope: str | None = None,
    ntp_server1: str | None = None,
    ntp_server2: str | None = None,
    passtos: bool | None = None,
    ping_action: str | None = None,
    ping_action_push: bool | None = None,
    ping_action_seconds: int | None = None,
    ping_method: str | None = 'keepalive',
    ping_push: bool | None = None,
    ping_seconds: int | None = None,
    push_blockoutsidedns: bool | None = None,
    push_register_dns: bool | None = None,
    remote_cert_tls: bool | None = True,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    serverbridge_dhcp: bool | None = None,
    serverbridge_dhcp_end: str | None = None,
    serverbridge_dhcp_start: str | None = None,
    serverbridge_interface: str | None = None,
    serverbridge_routegateway: bool | None = None,
    sndrcvbuf: int | None = None,
    strictusercn: bool | None = None,
    tls: str | None = None,
    tls_type: str | None = None,
    tlsauth_keydir: str | None = None,
    topology: str | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    use_tls: bool | None = None,
    username_as_common_name: bool | None = None,
    verbosity_level: int | None = 1,
    wins_server1: str | None = None,
    wins_server2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/openvpn/server

    caref: The `refid` of the CA object to assume as the peer CA.
    certref: The `refid` of the certificate object to assume as the OpenVPN server certificate.
    data_ciphers: The encryption algorithms/ciphers allowed by this OpenVPN server.
    data_ciphers_fallback: The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).
    dev_mode: The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2). Valid values: ['tun', 'tap']
    dh_length: The Diffie-Hellman (DH) parameter set used for key exchange.
    digest: The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.
    ecdh_curve: The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.
    mode: The OpenVPN server mode. Valid values: ['p2p_tls', 'server_tls', 'server_user', 'server_tls_user']
    protocol: The protocol used by this OpenVPN server. Valid values: ['UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP']
    allow_compression: The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP) Valid values: ['no', 'yes', 'asym']
    authmode: The name of the authentication server to use as the authentication backend for this OpenVPN serverThis field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    cert_depth: The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default. Valid values: [1, 2, 3, 4, 5]
    client2client: Enables or disables allowing communication between clients connected to this server.
    connlimit: The number of concurrent connections a single user can have.This field is only available when the following conditions are met:- `duplicate_cn` must be equal to `true`
    create_gw: The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server Valid values: ['both', 'v4only', 'v6only']
    custom_options: Additional options to add to the OpenVPN server configuration.
    description: The description for this OpenVPN server.
    disable: Disables this OpenVPN server.
    dns_domain: The default domain to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server1: The primary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server2: The secondary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server3: The tertiary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server4: The quaternary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    duplicate_cn: Enables or disable allowing the same user to connect multiple times.
    dynamic_ip: Enables or disables allowing connected clients to retain their connections if their IP address changes.
    gwredir: Enable forcing all client-generated IPv4 traffic through the tunnel.
    gwredir6: Enable forcing all client-generated IPv6 traffic through the tunnel.
    inactive_seconds: The amount of time (in seconds) until a client connection is closed for inactivity.
    interface: The interface or Virtual IP address where OpenVPN will receive client connections.This field is only available when the following conditions are met:- `protocol` must not be one of [ UDP, TCP ]
    keepalive_interval: The keepalive interval parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    keepalive_timeout: The keepalive timeout parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    local_network: The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.This field is only available when the following conditions are met:- `gwredir` must be equal to `false`
    local_networkv6: The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.This field is only available when the following conditions are met:- `gwredir6` must be equal to `false`
    local_port: The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number
    maxclients: The maximum number of clients allowed to concurrently connect to this server.
    netbios_enable: Enables or disables NetBIOS over TCP/IP.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    netbios_ntype: The NetBIOS node type.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true` Valid values: [0, 1, 2, 4, 8]
    netbios_scope: The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    ntp_server1: The primary NTP server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    ntp_server2: The secondary NTP server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    passtos: Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.
    ping_action: The action to take after a ping to the remote peer times-out.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'` Valid values: ['ping_restart', 'ping_exit']
    ping_action_push: Enables or disables pushing the ping action to the VPN client.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_action_seconds: The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_method: The method used to define ping configuration. Valid values: ['keepalive', 'ping']
    ping_push: Enables or disables push ping to the VPN client.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_seconds: The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    push_blockoutsidedns: Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    push_register_dns: Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    remote_cert_tls: Enables or disables requiring hosts to have a client certificate to connect.
    remote_network: IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    remote_networkv6: IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    serverbridge_dhcp: Enables or disables clients on the bridge to obtain DHCP.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tap'`
    serverbridge_dhcp_end: The bridge DHCP range's end address.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_dhcp_start: The bridge DHCP range's start address.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_interface: The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_routegateway: Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    sndrcvbuf: The send and receive buffer size for OpenVPN. Set to null to use the system default. Valid values: [65536, 131072, 262144, 524288, 1048576, 2097152]
    strictusercn: Enables or disables enforcing a match between the common name of the client certificate and the username given at login.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    tls: The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.This field is only available when the following conditions are met:- `use_tls` must be equal to `true`
    tls_type: The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.This field is only available when the following conditions are met:- `use_tls` must be equal to `true` Valid values: ['auth', 'crypt']
    tlsauth_keydir: The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.This field is only available when the following conditions are met:- `use_tls` must be equal to `true` Valid values: ['default', '0', '1', '2']
    topology: The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tun'` Valid values: ['subnet', 'net30']
    tunnel_network: The IPv4 virtual network used for private communications between this server and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between this server and client hosts.
    use_tls: Enables or disables the use of a TLS key for this OpenVPN server.
    username_as_common_name: Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    verbosity_level: The OpenVPN logging verbosity level. Valid values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    wins_server1: The primary WINS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    wins_server2: The secondary WINS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/openvpn/server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if caref is not None:
        body["caref"] = caref
    if certref is not None:
        body["certref"] = certref
    if data_ciphers is not None:
        body["data_ciphers"] = data_ciphers
    if data_ciphers_fallback is not None:
        body["data_ciphers_fallback"] = data_ciphers_fallback
    if dev_mode is not None:
        body["dev_mode"] = dev_mode
    if dh_length is not None:
        body["dh_length"] = dh_length
    if digest is not None:
        body["digest"] = digest
    if ecdh_curve is not None:
        body["ecdh_curve"] = ecdh_curve
    if mode is not None:
        body["mode"] = mode
    if protocol is not None:
        body["protocol"] = protocol
    if allow_compression is not None:
        body["allow_compression"] = allow_compression
    if authmode is not None:
        body["authmode"] = authmode
    if cert_depth is not None:
        body["cert_depth"] = cert_depth
    if client2client is not None:
        body["client2client"] = client2client
    if connlimit is not None:
        body["connlimit"] = connlimit
    if create_gw is not None:
        body["create_gw"] = create_gw
    if custom_options is not None:
        body["custom_options"] = custom_options
    if description is not None:
        body["description"] = description
    if disable is not None:
        body["disable"] = disable
    if dns_domain is not None:
        body["dns_domain"] = dns_domain
    if dns_server1 is not None:
        body["dns_server1"] = dns_server1
    if dns_server2 is not None:
        body["dns_server2"] = dns_server2
    if dns_server3 is not None:
        body["dns_server3"] = dns_server3
    if dns_server4 is not None:
        body["dns_server4"] = dns_server4
    if duplicate_cn is not None:
        body["duplicate_cn"] = duplicate_cn
    if dynamic_ip is not None:
        body["dynamic_ip"] = dynamic_ip
    if gwredir is not None:
        body["gwredir"] = gwredir
    if gwredir6 is not None:
        body["gwredir6"] = gwredir6
    if inactive_seconds is not None:
        body["inactive_seconds"] = inactive_seconds
    if interface is not None:
        body["interface"] = interface
    if keepalive_interval is not None:
        body["keepalive_interval"] = keepalive_interval
    if keepalive_timeout is not None:
        body["keepalive_timeout"] = keepalive_timeout
    if local_network is not None:
        body["local_network"] = local_network
    if local_networkv6 is not None:
        body["local_networkv6"] = local_networkv6
    if local_port is not None:
        body["local_port"] = local_port
    if maxclients is not None:
        body["maxclients"] = maxclients
    if netbios_enable is not None:
        body["netbios_enable"] = netbios_enable
    if netbios_ntype is not None:
        body["netbios_ntype"] = netbios_ntype
    if netbios_scope is not None:
        body["netbios_scope"] = netbios_scope
    if ntp_server1 is not None:
        body["ntp_server1"] = ntp_server1
    if ntp_server2 is not None:
        body["ntp_server2"] = ntp_server2
    if passtos is not None:
        body["passtos"] = passtos
    if ping_action is not None:
        body["ping_action"] = ping_action
    if ping_action_push is not None:
        body["ping_action_push"] = ping_action_push
    if ping_action_seconds is not None:
        body["ping_action_seconds"] = ping_action_seconds
    if ping_method is not None:
        body["ping_method"] = ping_method
    if ping_push is not None:
        body["ping_push"] = ping_push
    if ping_seconds is not None:
        body["ping_seconds"] = ping_seconds
    if push_blockoutsidedns is not None:
        body["push_blockoutsidedns"] = push_blockoutsidedns
    if push_register_dns is not None:
        body["push_register_dns"] = push_register_dns
    if remote_cert_tls is not None:
        body["remote_cert_tls"] = remote_cert_tls
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if serverbridge_dhcp is not None:
        body["serverbridge_dhcp"] = serverbridge_dhcp
    if serverbridge_dhcp_end is not None:
        body["serverbridge_dhcp_end"] = serverbridge_dhcp_end
    if serverbridge_dhcp_start is not None:
        body["serverbridge_dhcp_start"] = serverbridge_dhcp_start
    if serverbridge_interface is not None:
        body["serverbridge_interface"] = serverbridge_interface
    if serverbridge_routegateway is not None:
        body["serverbridge_routegateway"] = serverbridge_routegateway
    if sndrcvbuf is not None:
        body["sndrcvbuf"] = sndrcvbuf
    if strictusercn is not None:
        body["strictusercn"] = strictusercn
    if tls is not None:
        body["tls"] = tls
    if tls_type is not None:
        body["tls_type"] = tls_type
    if tlsauth_keydir is not None:
        body["tlsauth_keydir"] = tlsauth_keydir
    if topology is not None:
        body["topology"] = topology
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if use_tls is not None:
        body["use_tls"] = use_tls
    if username_as_common_name is not None:
        body["username_as_common_name"] = username_as_common_name
    if verbosity_level is not None:
        body["verbosity_level"] = verbosity_level
    if wins_server1 is not None:
        body["wins_server1"] = wins_server1
    if wins_server2 is not None:
        body["wins_server2"] = wins_server2
    return await _client.request(
        "POST",
        "/api/v2/vpn/openvpn/server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_open_vpn_server(
    id: str | int,
    confirm: bool = False,
    allow_compression: str | None = None,
    authmode: list[str] | None = None,
    caref: str | None = None,
    cert_depth: int | None = None,
    certref: str | None = None,
    client2client: bool | None = None,
    connlimit: int | None = None,
    create_gw: str | None = None,
    custom_options: list[str] | None = None,
    data_ciphers: list[str] | None = None,
    data_ciphers_fallback: str | None = None,
    description: str | None = None,
    dev_mode: str | None = None,
    dh_length: str | None = None,
    digest: str | None = None,
    disable: bool | None = None,
    dns_domain: str | None = None,
    dns_server1: str | None = None,
    dns_server2: str | None = None,
    dns_server3: str | None = None,
    dns_server4: str | None = None,
    duplicate_cn: bool | None = None,
    dynamic_ip: bool | None = None,
    ecdh_curve: str | None = None,
    gwredir: bool | None = None,
    gwredir6: bool | None = None,
    inactive_seconds: int | None = None,
    interface: str | None = None,
    keepalive_interval: int | None = None,
    keepalive_timeout: int | None = None,
    local_network: list[str] | None = None,
    local_networkv6: list[str] | None = None,
    local_port: str | None = None,
    maxclients: int | None = None,
    mode: str | None = None,
    netbios_enable: bool | None = None,
    netbios_ntype: int | None = None,
    netbios_scope: str | None = None,
    ntp_server1: str | None = None,
    ntp_server2: str | None = None,
    passtos: bool | None = None,
    ping_action: str | None = None,
    ping_action_push: bool | None = None,
    ping_action_seconds: int | None = None,
    ping_method: str | None = None,
    ping_push: bool | None = None,
    ping_seconds: int | None = None,
    protocol: str | None = None,
    push_blockoutsidedns: bool | None = None,
    push_register_dns: bool | None = None,
    remote_cert_tls: bool | None = None,
    remote_network: list[str] | None = None,
    remote_networkv6: list[str] | None = None,
    serverbridge_dhcp: bool | None = None,
    serverbridge_dhcp_end: str | None = None,
    serverbridge_dhcp_start: str | None = None,
    serverbridge_interface: str | None = None,
    serverbridge_routegateway: bool | None = None,
    sndrcvbuf: int | None = None,
    strictusercn: bool | None = None,
    tls: str | None = None,
    tls_type: str | None = None,
    tlsauth_keydir: str | None = None,
    topology: str | None = None,
    tunnel_network: str | None = None,
    tunnel_networkv6: str | None = None,
    use_tls: bool | None = None,
    username_as_common_name: bool | None = None,
    verbosity_level: int | None = None,
    wins_server1: str | None = None,
    wins_server2: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/openvpn/server

    id: The ID of the object or resource to interact with.
    allow_compression: The compression mode allowed by this OpenVPN server. Compression can potentially increase throughput but may allow an attacker to extract secrets if they can control compressed plaintext traversing the VPN (e.g. HTTP) Valid values: ['no', 'yes', 'asym']
    authmode: The name of the authentication server to use as the authentication backend for this OpenVPN serverThis field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    caref: The `refid` of the CA object to assume as the peer CA.
    cert_depth: The depth of the certificate chain to check when a certificate based client signs in. Certificates below this depth are not accepted. This is useful for denying certificates made with intermediate CAs generated from the same CA as the server. Set to null to use system default. Valid values: [1, 2, 3, 4, 5]
    certref: The `refid` of the certificate object to assume as the OpenVPN server certificate.
    client2client: Enables or disables allowing communication between clients connected to this server.
    connlimit: The number of concurrent connections a single user can have.This field is only available when the following conditions are met:- `duplicate_cn` must be equal to `true`
    create_gw: The gateway type(s) that will be created when a virtual interface is assigned to this OpenVPN server Valid values: ['both', 'v4only', 'v6only']
    custom_options: Additional options to add to the OpenVPN server configuration.
    data_ciphers: The encryption algorithms/ciphers allowed by this OpenVPN server.
    data_ciphers_fallback: The fallback encryption algorithm/cipher used for data channel packets when communicating with clients that do not support data encryption algorithm negotiation (e.g. Shared Key).
    description: The description for this OpenVPN server.
    dev_mode: The carrier mode for this OpenVPN server. `tun` mode carries IPv4 and IPv6 (layer 3) and is the most common and compatible mode across all platforms. `tap` mode is capable of carrying 802.3 (layer 2). Valid values: ['tun', 'tap']
    dh_length: The Diffie-Hellman (DH) parameter set used for key exchange.
    digest: The algorithm used to authenticate data channel packets, and control channel packets if a TLS Key is present.
    disable: Disables this OpenVPN server.
    dns_domain: The default domain to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server1: The primary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server2: The secondary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server3: The tertiary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    dns_server4: The quaternary DNS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    duplicate_cn: Enables or disable allowing the same user to connect multiple times.
    dynamic_ip: Enables or disables allowing connected clients to retain their connections if their IP address changes.
    ecdh_curve: The Elliptic Curve to use for key exchange. The curve from the server certificate is used by default when the server uses an ECDSA certificate. Otherwise, secp384r1 is used as a fallback.
    gwredir: Enable forcing all client-generated IPv4 traffic through the tunnel.
    gwredir6: Enable forcing all client-generated IPv6 traffic through the tunnel.
    inactive_seconds: The amount of time (in seconds) until a client connection is closed for inactivity.
    interface: The interface or Virtual IP address where OpenVPN will receive client connections.This field is only available when the following conditions are met:- `protocol` must not be one of [ UDP, TCP ]
    keepalive_interval: The keepalive interval parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    keepalive_timeout: The keepalive timeout parameter.This field is only available when the following conditions are met:- `ping_method` must be equal to `'keepalive'`
    local_network: The IPv4 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.This field is only available when the following conditions are met:- `gwredir` must be equal to `false`
    local_networkv6: The IPv6 networks that will be accessible from the remote endpoint. Expressed as a list of one or more CIDR ranges or host/network type aliases. This may be left blank if not adding a route to the local network through this tunnel on the remote machine. This is generally set to the LAN network.This field is only available when the following conditions are met:- `gwredir6` must be equal to `false`
    local_port: The port used by OpenVPN to receive client connections. Valid options are: a TCP/UDP port number
    maxclients: The maximum number of clients allowed to concurrently connect to this server.
    mode: The OpenVPN server mode. Valid values: ['p2p_tls', 'server_tls', 'server_user', 'server_tls_user']
    netbios_enable: Enables or disables NetBIOS over TCP/IP.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    netbios_ntype: The NetBIOS node type.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true` Valid values: [0, 1, 2, 4, 8]
    netbios_scope: The NetBIOS Scope ID. This provides an extended naming service for NetBIOS over TCP/IP. The NetBIOS scope ID isolates NetBIOS traffic on a single network to only those nodes with the same NetBIOS scope ID.This field is only available when the following conditions are met:- `netbios_enable` must be equal to `true`
    ntp_server1: The primary NTP server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    ntp_server2: The secondary NTP server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    passtos: Enables or disables setting the TOS IP header value of tunnel packets to match the encapsulated packet value.
    ping_action: The action to take after a ping to the remote peer times-out.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'` Valid values: ['ping_restart', 'ping_exit']
    ping_action_push: Enables or disables pushing the ping action to the VPN client.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_action_seconds: The number of seconds that must elapse before the ping is considered a timeout and the configured `ping_action` is performed.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_method: The method used to define ping configuration. Valid values: ['keepalive', 'ping']
    ping_push: Enables or disables push ping to the VPN client.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    ping_seconds: The number of seconds to accept no packets before sending a ping to the remote peer over the TCP/UDP control channel.This field is only available when the following conditions are met:- `ping_method` must be equal to `'ping'`
    protocol: The protocol used by this OpenVPN server. Valid values: ['UDP4', 'UDP6', 'UDP', 'TCP4', 'TCP6', 'TCP']
    push_blockoutsidedns: Enables or disables blocking Windows 10 clients' access to DNS servers except across OpenVPN while connected, forcing clients to use only VPN DNS servers.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    push_register_dns: Enables or disables running `net stop dnscache`, `net start dnscache`, `ipconfig /flushdns` and `ipconfig /registerdns` on connection initiation for Windows clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    remote_cert_tls: Enables or disables requiring hosts to have a client certificate to connect.
    remote_network: IPv4 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    remote_networkv6: IPv6 networks that will be routed through the tunnel, so that a site-to-site VPN can be established without manually changing the routing tables. Expressed as a list of one or more CIDR ranges or host/network type aliases. If this is a site-to-site VPN, enter the remote LAN/s here. May be left empty for non site-to-site VPN.
    serverbridge_dhcp: Enables or disables clients on the bridge to obtain DHCP.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tap'`
    serverbridge_dhcp_end: The bridge DHCP range's end address.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_dhcp_start: The bridge DHCP range's start address.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_interface: The interface to which this TAP instance will be bridged. This is not done automatically. This interface must be assigned and the bridge created separately. This setting controls which existing IP address and subnet mask are used by OpenVPN for the bridge.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    serverbridge_routegateway: Enables or disables pushing the bridge interface's IPv4 address to connecting clients as a route gateway.This field is only available when the following conditions are met:- `serverbridge_dhcp` must be equal to `true`
    sndrcvbuf: The send and receive buffer size for OpenVPN. Set to null to use the system default. Valid values: [65536, 131072, 262144, 524288, 1048576, 2097152]
    strictusercn: Enables or disables enforcing a match between the common name of the client certificate and the username given at login.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    tls: The TLS key this OpenVPN server will use to sign control channel packets with an HMAC signature for authentication when establishing the tunnel.This field is only available when the following conditions are met:- `use_tls` must be equal to `true`
    tls_type: The TLS key usage type. In `auth` mode, the TLS key is used only as HMAC authentication for the control channel, protecting the peers from unauthorized connections. The `crypt` mode encrypts the control channel communication in addition to providing authentication, providing more privacy and traffic control channel obfuscation.This field is only available when the following conditions are met:- `use_tls` must be equal to `true` Valid values: ['auth', 'crypt']
    tlsauth_keydir: The TLS key direction. This must be set to complementary values on the client and server. For example, if the server is set to 0, the client must be set to 1. Both may be set to omit the direction, in which case the TLS Key will be used bidirectionally.This field is only available when the following conditions are met:- `use_tls` must be equal to `true` Valid values: ['default', '0', '1', '2']
    topology: The method used to supply a virtual adapter IP address to clients when using TUN mode on IPv4.This field is only available when the following conditions are met:- `dev_mode` must be equal to `'tun'` Valid values: ['subnet', 'net30']
    tunnel_network: The IPv4 virtual network used for private communications between this server and client hosts.
    tunnel_networkv6: The IPv6 virtual network used for private communications between this server and client hosts.
    use_tls: Enables or disables the use of a TLS key for this OpenVPN server.
    username_as_common_name: Enables or disable the username of the client being used in place of the certificate common name for purposes such as determining Client Specific Overrides.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    verbosity_level: The OpenVPN logging verbosity level. Valid values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    wins_server1: The primary WINS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    wins_server2: The secondary WINS server to provide to clients.This field is only available when the following conditions are met:- `mode` must be one of [ server_user, server_tls_user ]
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/openvpn/server. "
            "Set confirm=True to execute."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if allow_compression is not None:
        body["allow_compression"] = allow_compression
    if authmode is not None:
        body["authmode"] = authmode
    if caref is not None:
        body["caref"] = caref
    if cert_depth is not None:
        body["cert_depth"] = cert_depth
    if certref is not None:
        body["certref"] = certref
    if client2client is not None:
        body["client2client"] = client2client
    if connlimit is not None:
        body["connlimit"] = connlimit
    if create_gw is not None:
        body["create_gw"] = create_gw
    if custom_options is not None:
        body["custom_options"] = custom_options
    if data_ciphers is not None:
        body["data_ciphers"] = data_ciphers
    if data_ciphers_fallback is not None:
        body["data_ciphers_fallback"] = data_ciphers_fallback
    if description is not None:
        body["description"] = description
    if dev_mode is not None:
        body["dev_mode"] = dev_mode
    if dh_length is not None:
        body["dh_length"] = dh_length
    if digest is not None:
        body["digest"] = digest
    if disable is not None:
        body["disable"] = disable
    if dns_domain is not None:
        body["dns_domain"] = dns_domain
    if dns_server1 is not None:
        body["dns_server1"] = dns_server1
    if dns_server2 is not None:
        body["dns_server2"] = dns_server2
    if dns_server3 is not None:
        body["dns_server3"] = dns_server3
    if dns_server4 is not None:
        body["dns_server4"] = dns_server4
    if duplicate_cn is not None:
        body["duplicate_cn"] = duplicate_cn
    if dynamic_ip is not None:
        body["dynamic_ip"] = dynamic_ip
    if ecdh_curve is not None:
        body["ecdh_curve"] = ecdh_curve
    if gwredir is not None:
        body["gwredir"] = gwredir
    if gwredir6 is not None:
        body["gwredir6"] = gwredir6
    if inactive_seconds is not None:
        body["inactive_seconds"] = inactive_seconds
    if interface is not None:
        body["interface"] = interface
    if keepalive_interval is not None:
        body["keepalive_interval"] = keepalive_interval
    if keepalive_timeout is not None:
        body["keepalive_timeout"] = keepalive_timeout
    if local_network is not None:
        body["local_network"] = local_network
    if local_networkv6 is not None:
        body["local_networkv6"] = local_networkv6
    if local_port is not None:
        body["local_port"] = local_port
    if maxclients is not None:
        body["maxclients"] = maxclients
    if mode is not None:
        body["mode"] = mode
    if netbios_enable is not None:
        body["netbios_enable"] = netbios_enable
    if netbios_ntype is not None:
        body["netbios_ntype"] = netbios_ntype
    if netbios_scope is not None:
        body["netbios_scope"] = netbios_scope
    if ntp_server1 is not None:
        body["ntp_server1"] = ntp_server1
    if ntp_server2 is not None:
        body["ntp_server2"] = ntp_server2
    if passtos is not None:
        body["passtos"] = passtos
    if ping_action is not None:
        body["ping_action"] = ping_action
    if ping_action_push is not None:
        body["ping_action_push"] = ping_action_push
    if ping_action_seconds is not None:
        body["ping_action_seconds"] = ping_action_seconds
    if ping_method is not None:
        body["ping_method"] = ping_method
    if ping_push is not None:
        body["ping_push"] = ping_push
    if ping_seconds is not None:
        body["ping_seconds"] = ping_seconds
    if protocol is not None:
        body["protocol"] = protocol
    if push_blockoutsidedns is not None:
        body["push_blockoutsidedns"] = push_blockoutsidedns
    if push_register_dns is not None:
        body["push_register_dns"] = push_register_dns
    if remote_cert_tls is not None:
        body["remote_cert_tls"] = remote_cert_tls
    if remote_network is not None:
        body["remote_network"] = remote_network
    if remote_networkv6 is not None:
        body["remote_networkv6"] = remote_networkv6
    if serverbridge_dhcp is not None:
        body["serverbridge_dhcp"] = serverbridge_dhcp
    if serverbridge_dhcp_end is not None:
        body["serverbridge_dhcp_end"] = serverbridge_dhcp_end
    if serverbridge_dhcp_start is not None:
        body["serverbridge_dhcp_start"] = serverbridge_dhcp_start
    if serverbridge_interface is not None:
        body["serverbridge_interface"] = serverbridge_interface
    if serverbridge_routegateway is not None:
        body["serverbridge_routegateway"] = serverbridge_routegateway
    if sndrcvbuf is not None:
        body["sndrcvbuf"] = sndrcvbuf
    if strictusercn is not None:
        body["strictusercn"] = strictusercn
    if tls is not None:
        body["tls"] = tls
    if tls_type is not None:
        body["tls_type"] = tls_type
    if tlsauth_keydir is not None:
        body["tlsauth_keydir"] = tlsauth_keydir
    if topology is not None:
        body["topology"] = topology
    if tunnel_network is not None:
        body["tunnel_network"] = tunnel_network
    if tunnel_networkv6 is not None:
        body["tunnel_networkv6"] = tunnel_networkv6
    if use_tls is not None:
        body["use_tls"] = use_tls
    if username_as_common_name is not None:
        body["username_as_common_name"] = username_as_common_name
    if verbosity_level is not None:
        body["verbosity_level"] = verbosity_level
    if wins_server1 is not None:
        body["wins_server1"] = wins_server1
    if wins_server2 is not None:
        body["wins_server2"] = wins_server2
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/openvpn/server",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_server(
    id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/server

    id: The ID of the object to target.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/server. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/server",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_open_vpn_servers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/openvpn/servers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/openvpn/servers",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpn_open_vpn_servers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/openvpn/servers

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/openvpn/servers. "
            "Set confirm=True to execute."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/openvpn/servers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_apply_status(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/apply
    """
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/apply",
    )


@mcp.tool()
async def pfsense_vpn_wire_guard_apply(
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/wireguard/apply
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/wireguard/apply. "
            "Set confirm=True to execute."
        )
    return await _client.request(
        "POST",
        "/api/v2/vpn/wireguard/apply",
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_peer_allowed_ip(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/peer/allowed_ip

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/peer/allowed_ip",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_wire_guard_peer_allowed_ip(
    address: str,
    mask: int,
    parent_id: str | int,
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/wireguard/peer/allowed_ip

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    address: The IPv4 or IPv6 address for this peer IP.
    mask: The subnet mask for this peer IP.
    parent_id: The ID of the parent this object is nested under.
    descr: A description for this allowed peer IP.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/wireguard/peer/allowed_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if address is not None:
        body["address"] = address
    if mask is not None:
        body["mask"] = mask
    if parent_id is not None:
        body["parent_id"] = parent_id
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/vpn/wireguard/peer/allowed_ip",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_wire_guard_peer_allowed_ip(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    address: str | None = None,
    descr: str | None = None,
    mask: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/wireguard/peer/allowed_ip

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    address: The IPv4 or IPv6 address for this peer IP.
    descr: A description for this allowed peer IP.
    mask: The subnet mask for this peer IP.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/wireguard/peer/allowed_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if address is not None:
        body["address"] = address
    if descr is not None:
        body["descr"] = descr
    if mask is not None:
        body["mask"] = mask
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/wireguard/peer/allowed_ip",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_peer_allowed_ip(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/peer/allowed_ip

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/peer/allowed_ip. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/peer/allowed_ip",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_wire_guard_peer_allowed_i_ps(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/peer/allowed_ips

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/peer/allowed_ips",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_peer_allowed_i_ps(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/peer/allowed_ips

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/peer/allowed_ips. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/peer/allowed_ips",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_peer(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/peer

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/peer",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_wire_guard_peer(
    publickey: str,
    confirm: bool = False,
    allowedips: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    enabled: bool | None = None,
    endpoint: str | None = None,
    persistentkeepalive: int | None = None,
    port: str | None = None,
    presharedkey: str | None = None,
    tun: str | None = 'unassigned',
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/wireguard/peer

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    publickey: The public key for this peer.
    allowedips: The allowed IP/subnets for this WireGuard peer.
    descr: The description for this peer.
    enabled: Enables or disables this WireGuard peer.
    endpoint: The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.
    persistentkeepalive: The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.
    port: The port used by the remote peer. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `endpoint` must not be equal to `NULL`
    presharedkey: The pre-shared key for this tunnel.
    tun: The WireGuard tunnel for this peer.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/wireguard/peer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if publickey is not None:
        body["publickey"] = publickey
    if allowedips is not None:
        body["allowedips"] = allowedips
    if descr is not None:
        body["descr"] = descr
    if enabled is not None:
        body["enabled"] = enabled
    if endpoint is not None:
        body["endpoint"] = endpoint
    if persistentkeepalive is not None:
        body["persistentkeepalive"] = persistentkeepalive
    if port is not None:
        body["port"] = port
    if presharedkey is not None:
        body["presharedkey"] = presharedkey
    if tun is not None:
        body["tun"] = tun
    return await _client.request(
        "POST",
        "/api/v2/vpn/wireguard/peer",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_wire_guard_peer(
    id: str | int,
    confirm: bool = False,
    allowedips: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    enabled: bool | None = None,
    endpoint: str | None = None,
    persistentkeepalive: int | None = None,
    port: str | None = None,
    presharedkey: str | None = None,
    publickey: str | None = None,
    tun: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/wireguard/peer

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    allowedips: The allowed IP/subnets for this WireGuard peer.
    descr: The description for this peer.
    enabled: Enables or disables this WireGuard peer.
    endpoint: The IP address or hostname of the remote peer. Set to `null` to make this a dynamic endpoint.
    persistentkeepalive: The interval (in seconds) for Keep Alive packets sent to this peer. Set to `null` to disable.
    port: The port used by the remote peer. Valid options are: a TCP/UDP port numberThis field is only available when the following conditions are met:- `endpoint` must not be equal to `NULL`
    presharedkey: The pre-shared key for this tunnel.
    publickey: The public key for this peer.
    tun: The WireGuard tunnel for this peer.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/wireguard/peer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if allowedips is not None:
        body["allowedips"] = allowedips
    if descr is not None:
        body["descr"] = descr
    if enabled is not None:
        body["enabled"] = enabled
    if endpoint is not None:
        body["endpoint"] = endpoint
    if persistentkeepalive is not None:
        body["persistentkeepalive"] = persistentkeepalive
    if port is not None:
        body["port"] = port
    if presharedkey is not None:
        body["presharedkey"] = presharedkey
    if publickey is not None:
        body["publickey"] = publickey
    if tun is not None:
        body["tun"] = tun
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/wireguard/peer",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_peer(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/peer

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/peer. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/peer",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_wire_guard_peers(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/peers

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/peers",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_vpn_wire_guard_peers(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/vpn/wireguard/peers

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/vpn/wireguard/peers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/vpn/wireguard/peers",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_peers(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/peers

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/peers. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/peers",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_settings(
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/settings
    """
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/settings",
    )


@mcp.tool()
async def pfsense_update_vpn_wire_guard_settings(
    confirm: bool = False,
    enable: bool | None = None,
    hide_peers: bool | None = None,
    hide_secrets: bool | None = None,
    interface_group: str | None = None,
    keep_conf: bool | None = None,
    resolve_interval: int | None = None,
    resolve_interval_track: bool | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/wireguard/settings

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    enable: Enables or disables WireGuard on this system. WireGuard cannot be disabled when one or more tunnels is assigned to a pfSense interface.
    hide_peers: Enables or disables initially hiding all peers in the user interface.
    hide_secrets: Enables or disables hiding all secrets (private and pre-shared keys) in the user interface.
    interface_group: Configures which WireGuard tunnels are members of the WireGuard interface group. Valid values: ['all', 'unassigned', 'none']
    keep_conf: Enables or disables keeping the WireGuard configuration when the package is uninstalled/reinstalled.
    resolve_interval: The interval (in seconds) for re-resolving endpoint host/domain names.This field is only available when the following conditions are met:- `resolve_interval_track` must be equal to `false`
    resolve_interval_track: Enables or disables tracking the 'Aliases Hostnames Resolve Interval' value as the `resolve_internal` value instead of specifying a value directly.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/wireguard/settings. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if enable is not None:
        body["enable"] = enable
    if hide_peers is not None:
        body["hide_peers"] = hide_peers
    if hide_secrets is not None:
        body["hide_secrets"] = hide_secrets
    if interface_group is not None:
        body["interface_group"] = interface_group
    if keep_conf is not None:
        body["keep_conf"] = keep_conf
    if resolve_interval is not None:
        body["resolve_interval"] = resolve_interval
    if resolve_interval_track is not None:
        body["resolve_interval_track"] = resolve_interval_track
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/wireguard/settings",
        json_body=body,
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_tunnel_address(
    id: str | int,
    parent_id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/tunnel/address

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/tunnel/address",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_wire_guard_tunnel_address(
    address: str,
    mask: int,
    parent_id: str | int,
    confirm: bool = False,
    descr: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/wireguard/tunnel/address

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    address: The IPv4 or IPv6 address for this WireGuard tunnel.
    mask: The subnet mask for this WireGuard tunnel.
    parent_id: The ID of the parent this object is nested under.
    descr: A description for this WireGuard tunnel address entry.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/wireguard/tunnel/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if address is not None:
        body["address"] = address
    if mask is not None:
        body["mask"] = mask
    if parent_id is not None:
        body["parent_id"] = parent_id
    if descr is not None:
        body["descr"] = descr
    return await _client.request(
        "POST",
        "/api/v2/vpn/wireguard/tunnel/address",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_wire_guard_tunnel_address(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
    address: str | None = None,
    descr: str | None = None,
    mask: int | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/wireguard/tunnel/address

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    parent_id: The ID of the parent this object is nested under.
    address: The IPv4 or IPv6 address for this WireGuard tunnel.
    descr: A description for this WireGuard tunnel address entry.
    mask: The subnet mask for this WireGuard tunnel.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/wireguard/tunnel/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if parent_id is not None:
        body["parent_id"] = parent_id
    if address is not None:
        body["address"] = address
    if descr is not None:
        body["descr"] = descr
    if mask is not None:
        body["mask"] = mask
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/wireguard/tunnel/address",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_tunnel_address(
    id: str | int,
    parent_id: str | int,
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/tunnel/address

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object to target.
    parent_id: The ID of the parent this object is nested under.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/tunnel/address. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if parent_id is not None:
        params["parent_id"] = parent_id
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/tunnel/address",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_wire_guard_tunnel_addresses(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/tunnel/addresses

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/tunnel/addresses",
        params=params,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_tunnel_addresses(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/tunnel/addresses

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/tunnel/addresses. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/tunnel/addresses",
        params=params,
    )


@mcp.tool()
async def pfsense_get_vpn_wire_guard_tunnel(
    id: str | int,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/tunnel

    id: The ID of the object to target.
    """
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/tunnel",
        params=params,
    )


@mcp.tool()
async def pfsense_create_vpn_wire_guard_tunnel(
    privatekey: str,
    confirm: bool = False,
    addresses: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    enabled: bool | None = True,
    listenport: str | None = '51820',
    mtu: int | None = 1420,
) -> dict[str, Any] | list[Any] | str:
    """POST /api/v2/vpn/wireguard/tunnel

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    privatekey: The private key for this tunnel.
    addresses: The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.
    descr: A description for this WireGuard tunnel.
    enabled: Enables or disables this tunnels and any associated peers.
    listenport: The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number
    mtu: The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.
    """
    if not confirm:
        return (
            "This is a POST operation on /api/v2/vpn/wireguard/tunnel. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if privatekey is not None:
        body["privatekey"] = privatekey
    if addresses is not None:
        body["addresses"] = addresses
    if descr is not None:
        body["descr"] = descr
    if enabled is not None:
        body["enabled"] = enabled
    if listenport is not None:
        body["listenport"] = listenport
    if mtu is not None:
        body["mtu"] = mtu
    return await _client.request(
        "POST",
        "/api/v2/vpn/wireguard/tunnel",
        json_body=body,
    )


@mcp.tool()
async def pfsense_update_vpn_wire_guard_tunnel(
    id: str | int,
    confirm: bool = False,
    addresses: list[dict[str, Any]] | None = None,
    descr: str | None = None,
    enabled: bool | None = None,
    listenport: str | None = None,
    mtu: int | None = None,
    privatekey: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """PATCH /api/v2/vpn/wireguard/tunnel

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object or resource to interact with.
    addresses: The IPv4 or IPv6 addresses to assign this WireGuard tunnel interface. This field is ignored if this tunnel interface is assigned to an existing pfSense interface object.
    descr: A description for this WireGuard tunnel.
    enabled: Enables or disables this tunnels and any associated peers.
    listenport: The port WireGuard will listen on for this tunnel. Valid options are: a TCP/UDP port number
    mtu: The MTU for this WireGuard tunnel interface. This value is ignored if this tunnel is assigned as a pfSense interface.
    privatekey: The private key for this tunnel.
    """
    if not confirm:
        return (
            "This is a PATCH operation on /api/v2/vpn/wireguard/tunnel. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body: dict[str, Any] = {}
    if id is not None:
        body["id"] = id
    if addresses is not None:
        body["addresses"] = addresses
    if descr is not None:
        body["descr"] = descr
    if enabled is not None:
        body["enabled"] = enabled
    if listenport is not None:
        body["listenport"] = listenport
    if mtu is not None:
        body["mtu"] = mtu
    if privatekey is not None:
        body["privatekey"] = privatekey
    return await _client.request(
        "PATCH",
        "/api/v2/vpn/wireguard/tunnel",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_tunnel(
    id: str | int,
    confirm: bool = False,
    apply: bool | None = False,
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/tunnel

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    id: The ID of the object to target.
    apply: Apply this deletion immediately.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/tunnel. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if id is not None:
        params["id"] = id
    if apply is not None:
        params["apply"] = apply
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/tunnel",
        params=params,
    )


@mcp.tool()
async def pfsense_list_vpn_wire_guard_tunnels(
    limit: int | None = 0,
    offset: int | None = 0,
    sort_by: list[str] | None = None,
    sort_flags: str | None = None,
    sort_order: str | None = None,
) -> dict[str, Any] | list[Any] | str:
    """GET /api/v2/vpn/wireguard/tunnels

    limit: The number of objects to obtain at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    sort_by: The fields to sort response data by.
    sort_flags: The sort flag to use to customize the behavior of the sort. Valid values: ['SORT_REGULAR', 'SORT_NUMERIC', 'SORT_STRING', 'SORT_LOCALE_STRING', 'SORT_NATURAL', 'SORT_FLAG_CASE']
    sort_order: The order to sort response data by. Valid values: ['SORT_ASC', 'SORT_DESC']
    """
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if sort_by is not None:
        params["sort_by"] = sort_by
    if sort_flags is not None:
        params["sort_flags"] = sort_flags
    if sort_order is not None:
        params["sort_order"] = sort_order
    return await _client.request(
        "GET",
        "/api/v2/vpn/wireguard/tunnels",
        params=params,
    )


@mcp.tool()
async def pfsense_replace_vpn_wire_guard_tunnels(
    items: list[dict[str, Any]],
    confirm: bool = False,
) -> dict[str, Any] | list[Any] | str:
    """PUT /api/v2/vpn/wireguard/tunnels

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    items: List of objects for bulk replacement.
    """
    if not confirm:
        return (
            "This is a PUT operation on /api/v2/vpn/wireguard/tunnels. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    body = items
    return await _client.request(
        "PUT",
        "/api/v2/vpn/wireguard/tunnels",
        json_body=body,
    )


@mcp.tool()
async def pfsense_delete_vpn_wire_guard_tunnels(
    confirm: bool = False,
    limit: int | None = 0,
    offset: int | None = 0,
    query: dict[str, Any] | None = {},
) -> dict[str, Any] | list[Any] | str:
    """DELETE /api/v2/vpn/wireguard/tunnels

    Note: Call pfsense_vpn_wireguard_apply after this to apply changes.

    limit: The maximum number of objects to delete at once. Set to 0 for no limit.
    offset: The starting point in the dataset to begin fetching objects.
    query: The arbitrary query parameters to include in the request.Note: This does not define an actual parameter, rather it allows for any arbitrary query parameters to be included in the request.
    """
    if not confirm:
        return (
            "This is a DELETE operation on /api/v2/vpn/wireguard/tunnels. "
            "Set confirm=True to execute."
            "\n\nNote: After this operation, call pfsense_vpn_wireguard_apply to apply changes."
        )
    params: dict[str, Any] = {}
    if limit is not None:
        params["limit"] = limit
    if offset is not None:
        params["offset"] = offset
    if query is not None:
        params.update(query)
    return await _client.request(
        "DELETE",
        "/api/v2/vpn/wireguard/tunnels",
        params=params,
    )

